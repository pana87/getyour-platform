export class Helper {
  // change name of Helper ??
  // make it shorter

  static add(event, input) {
    // add event to input
    // no dom creation, events only

    if (event === "accept") {

      const accept = input.node.getAttribute("accept")
      input.node.setAttribute("accept", `${accept}, ${input.type}`)
    }

    if (event === "cite-button") {

      let citeButton = document.querySelector("div.cite-button")
      if (!citeButton) {
        citeButton = this.create("cite-button", document.body)
      }
      citeButton.addEventListener("click", (ev) => {
        ev.stopPropagation()
        ev.preventDefault()
        navigator.clipboard.writeText(input).then(() => window.alert(`${input}\n\nQuelle wurde erfolgreich in deiner Zwischenablage gespeichert.`))
      })
    }

    if (event === "background/node/hover") {

      input.addEventListener("mouseover", () => {
        input.style.backgroundColor = "#999"
      })

      input.addEventListener("mouseout", () => {
        input.style.backgroundColor = null
      })

    }

    if (event === "cite-checker") {

      const cites = document.querySelectorAll(`[class*="cite"]`)
      cites.forEach(cite => {
        this.add("outline-hover", cite)
        cite.onclick = () => {
          const originalTextContent = cite.textContent

          function createIntegrations(text) {
            const webSearchEngines = [
              { name: 'Google', url: `https://www.google.com/search?q=${text}` },
              { name: 'Bing', url: `https://www.bing.com/search?q=${text}` },
              { name: 'Yahoo', url: `https://search.yahoo.com/search?p=${text}` },
              { name: 'DuckDuckGo', url: `https://duckduckgo.com/?q=${text}` },
              { name: 'Baidu', url: `https://www.baidu.com/s?wd=${text}` },
              { name: 'Yandex', url: `https://yandex.com/search/?text=${text}` },
            ]

            const academicSearchEngines = [
              { name: 'Google Books', url: `https://books.google.com/books?q=${encodeURIComponent(text)}` },
              { name: 'WorldCat', url: `https://www.worldcat.org/search?q=${encodeURIComponent(text)}` },
              { name: 'Open Library', url: `https://openlibrary.org/search?q=${encodeURIComponent(text)}` },
              { name: 'Internet Archive', url: `https://archive.org/search.php?query=${encodeURIComponent(text)}` },
              { name: 'Library of Congress', url: `https://catalog.loc.gov/vwebv/search?searchArg=${encodeURIComponent(text)}&searchCode=GKEY%5E*&searchType=0&recCount=25` },
              { name: 'Google Scholar', url: `https://scholar.google.com/scholar?q=${text}` },
              { name: 'PubMed', url: `https://pubmed.ncbi.nlm.nih.gov/?term=${text}` },
              { name: 'CrossRef', url: `https://search.crossref.org/search/works?q=${text}&from_ui=yes` },
              { name: 'Semantic Scholar', url: `https://www.semanticscholar.org/search?q=${text}` },
              { name: 'IEEE Xplore', url: `https://ieeexplore.ieee.org/search/searchresult.jsp?queryText=${text}` },
              { name: 'SpringerLink', url: `https://link.springer.com/search?query=${text}` },
              { name: 'Wiley Online Library', url: `https://onlinelibrary.wiley.com/action/doSearch?AllField=${text}` },
              { name: 'ResearchGate', url: `https://www.researchgate.net/search?q=${text}` },
            ]

            const codingPlatforms = [
              { name: 'GitHub', url: `https://github.com/search?q=${encodeURIComponent(text)}` },
              { name: 'CodePen', url: `https://codepen.io/search/pens?q=${encodeURIComponent(text)}` }
            ]

            const developerCommunities = [
              { name: 'Stack Overflow', url: `https://stackoverflow.com/search?q=${encodeURIComponent(text)}` },
              { name: 'Stack Exchange', url: `https://stackexchange.com/search?q=${text}` },
              { name: 'Dev.to', url: `https://dev.to/search?q=${encodeURIComponent(text)}` }
            ]

            const translationTools = [
              { name: 'DeepL', url: `https://www.deepl.com/translator#auto/de/${encodeURIComponent(text)}` },
              { name: 'Google Translate', url: `https://translate.google.com/?sl=auto&tl=de&text=${encodeURIComponent(text)}&op=translate` },
            ]

            const informationReference = [
              { name: 'Wikipedia', url: `https://www.wikipedia.org/wiki/Special:Search?search=${text}` },
              { name: 'Wikileaks', url: `https://wikileaks.org/wiki/Special:Search?search=${text}` },
              { name: 'Infoplease', url: `https://www.infoplease.com/search/${text}` },
            ]

            const integrations = [
              ...webSearchEngines,
              ...academicSearchEngines,
              ...codingPlatforms,
              ...developerCommunities,
              ...translationTools,
              ...informationReference,
            ]

            integrations.sort((a, b) => a.name.localeCompare(b.name))
            return integrations
          }

          function createIntegrationButton(text, node) {
            const button = Helper.create("toolbox/left-right", node)
            button.right.remove()
            button.left.textContent = text
            button.onclick = () => {
              Helper.overlay("pop", overlay => {
                overlay.info.textContent = text
                const content = overlay.content
                const integrations = createIntegrations(text)
                const windowOpenButton = Helper.create("toolbox/left-right", content)
                windowOpenButton.left.textContent = "window.open"
                windowOpenButton.right.textContent = "Öffne den Inhalt in einem neuen Tab"
                windowOpenButton.onclick = () => {
                  if (text.startsWith("www.")) {
                    window.open(`https://${text}`, "_blank")
                    return
                  }

                  if (text.startsWith("https://")) {
                    window.open(text, "_blank")
                    return
                  }
                  window.open(`https://www.${text}`, "_blank")
                }
                const copyToClipboardButton = Helper.create("toolbox/left-right", content)
                copyToClipboardButton.left.textContent = ".copy-to-clipboard"
                copyToClipboardButton.right.textContent = "Inhalt in die Zwischenablage speichern"
                copyToClipboardButton.onclick = async () => {
                  console.log(text);
                  try {
                    await navigator.clipboard.writeText(text)
                    window.alert("Inhalt wurde erfolgreich in die Zwischenablage gespeichert.")
                  } catch (error) {
                    console.error(error)
                    window.alert("Fehler.. Bitte wiederholen.")
                  }
                }
                for (let i = 0; i < integrations.length; i++) {
                  const integration = integrations[i]
                  const button = Helper.create("toolbox/left-right", content)
                  button.left.textContent = integration.name
                  button.right.textContent = "Öffnet ein neues Fenster"
                  button.onclick = () => {
                    window.open(integration.url, "_blank")
                    Helper.remove("overlays")
                  }
                }
              })
            }
          }

          if (cite.classList.contains("full-cite")) {

            const parts = originalTextContent.split(', ')
            this.overlay("pop", overlay => {
              overlay.info.textContent = ".cite-checker"
              const content = overlay.content
              this.render("text/h2", "Inhalt wählen", content)
              createIntegrationButton(parts.join(", "), content)
              for (let i = 0; i < parts.length; i++) {
                const part = parts[i]
                createIntegrationButton(part, content)
              }
            })
          }

          if (cite.classList.contains("inline-cite")) {

            const splitString = window.prompt("Gebe ein Zeichen oder eine Zeichenkette ein, nach der du den Inhalt aufteilen möchtest.")
            if (splitString === null) return
            const splittedTextContent = originalTextContent.split(splitString)
            this.overlay("pop", overlay => {
              overlay.info.textContent = ".cite-checker"
              const content = overlay.content
              this.render("text/h2", "Inhalt wählen", content)
              for (let i = 0; i < splittedTextContent.length; i++) {
                const splittedText = splittedTextContent[i]
                const trimmedText = splittedText.trim()
                if (this.verifyIs("text/empty", splittedText)) continue
                createIntegrationButton(trimmedText, content)
              }
            })
          }

        }
      })
    }

    if (event === "contacts") {

      const button = this.create("button/left-right", input)
      button.left.textContent = ".contacts"
      button.right.textContent = "Deine Kontakte"
      button.onclick = () => {
        this.overlay("contacts")
      }
    }

    if (event === "groups") {

      const button = this.create("button/left-right", input)
      button.left.textContent = ".groups"
      button.right.textContent = "Schnell, einfach und sicher Kontakte gruppieren"
      button.onclick = () => {
        this.overlay("popup", async overlay => {
          overlay.info.textContent = ".groups"

          async function renderInfo(prefix, path, postfix, parent) {
            const fragment = document.createDocumentFragment()
            const info = Helper.createNode("div", fragment)
            info.style.margin = "21px 34px"
            const span1 = Helper.createNode("span", info, prefix)
            const span2 = Helper.createNode("span", info)
            Helper.style(span2, {width: "34px", margin: "0 5px"})
            const icon = await Helper.convert("path/icon", path)
            Helper.style(icon, {display: "inline-block", width: "34px"})
            span2.appendChild(icon)
            Helper.createNode("span", info, postfix)
            parent?.appendChild(fragment)
            return fragment
          }

          async function defineNewGroup(overlay) {
            Helper.render("text/h1", "Neue Gruppe definieren", overlay)
            const funnel = Helper.create("div/scrollable", overlay)
            const emailSelect = Helper.create("email-select", funnel)
            const res = await Helper.request("/get/user/tree-closed/", {tree: "contacts"})
            if (res.status === 200) {
              const contacts = JSON.parse(res.response)
              emailSelect.renderEmails(contacts)
              emailSelect.filterEmailsOnSearch(contacts)
            }
            emailSelect.submit = Helper.create("toolbox/action", funnel)
            emailSelect.submit.textContent = "Gruppe jetzt speichern"
            return emailSelect
          }

          const addGroup = this.create("button/add", overlay)
          addGroup.onclick = () => {
            this.overlay("popup", async overlay => {
              const emailSelect = await defineNewGroup(overlay)
              emailSelect.submit.onclick = () => {
                const emails = emailSelect.selectedEmails()
                if (this.verifyIs("array/empty", emails)) {
                  window.alert("Wähle mindestens eine E-Mail Adresse.")
                  this.add("style/not-valid", emailSelect.field.input)
                  return
                }
                this.overlay("security", async securityOverlay => {
                  const res = await this.request("/register/groups/self/", {emails})
                  if (res.status === 200) {
                    window.alert("Deine Gruppe wurde erfolgreich gespeichert.")
                    await getAndRenderGroups(groupsContainer)
                    securityOverlay.remove()
                    overlay.remove()
                  }
                })
              }
            })
          }

          const searchField = this.create("input/text", overlay)
          searchField.input.placeholder = "Filter nach E-Mail Adresse oder Alias"

          const groupsContainer = this.create("info/loading", overlay)
          await getAndRenderGroups(groupsContainer)

          function renderGroupEmails(group, parent) {
            const fragment = document.createDocumentFragment()
            for (let i = 0; i < group.emails.length; i++) {
              const email = group.emails[i]
              const div = Helper.create("div", fragment)
              div.textContent = email
              fragment.appendChild(div)
            }
            parent?.appendChild(fragment)
            return fragment
          }

          function filterGroupsByEmail(array, parent) {
            searchField.input.oninput = (ev) => {
              const filtered = array.filter(it => {
                const lowercase = ev.target.value.toLowerCase()
                if (it.emails && it.emails.length > 0) {
                  return it.emails.some(email => email.includes(lowercase)) || (it.alias && it.alias.toLowerCase().includes(lowercase))
                } else {
                  if (it.alias && it.alias.toLowerCase().includes(lowercase)) {
                    return true
                  }
                  return false
                }
              })
              renderGroupButtons(filtered, parent, ev.target.value)
            }
          }

          function markQueryInNode(node, query) {
            if (node.children.length > 0) {
              for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i]
                markQueryInNode(child, query)
              }
            } else {
              Helper.convert("node/marked", {node, query})
            }

          }

          function renderGroupButtons(groups, parent, query = "") {
            const fragment = document.createDocumentFragment()

            Helper.convert("parent/scrollable", parent)
            for (let i = 0; i < groups.length; i++) {
              const group = groups[i]

              const groupButton = Helper.create("toolbox/left-right", fragment)
              if (Helper.verifyIs("text/empty", query)) {
                if (!Helper.verifyIs("text/empty", group.alias)) {
                  Helper.createNode("span", groupButton.left, `${group.alias}`)
                } else {
                  renderGroupEmails(group, groupButton.left)
                }
              } else {
                if (!Helper.verifyIs("text/empty", group.alias)) {
                  Helper.createNode("span", groupButton.left, `${group.alias}:`)
                  renderGroupEmails(group, groupButton.left)
                } else {
                  renderGroupEmails(group, groupButton.left)
                }
              }
              markQueryInNode(groupButton.left, query)
              groupButton.onclick = () => {
                Helper.overlay("popup", buttonsOverlay => {
                  buttonsOverlay.info.textContent = group.emails.join(", ")

                  const buttons = Helper.create("div/scrollable", buttonsOverlay)

                  Helper.request("/verify/group/is-creator/", {id: group.created}).then(res => {
                    if (res.status === 200) {
                      {
                        const button = Helper.create("toolbox/left-right", buttons)
                        button.left.textContent = ".alias"
                        button.right.textContent = "Gebe deiner Gruppe einen alternativen Namen"
                        button.onclick = () => {
                          Helper.overlay("popup", overlay => {
                            overlay.info.textContent = group.emails.join(", ")
                            const funnel = Helper.create("div/scrollable", overlay)
                            const aliasField = Helper.create("field/text", funnel)
                            aliasField.label.textContent = "Alternative Bezeichnung für deine Gruppe"
                            aliasField.input.placeholder = "Family, Friends, Work.."
                            if (group.alias !== undefined) {
                              aliasField.input.value = group.alias
                            }
                            Helper.verify("input/value", aliasField.input)
                            Helper.add("outline-hover", aliasField.input)
                            aliasField.input.oninput = () => Helper.verify("input/value", aliasField.input)
                            const submit = Helper.create("button/action", funnel)
                            Helper.add("outline-hover", submit)
                            submit.textContent = "Alias jetzt speichern"
                            submit.onclick = async () => {
                              await Helper.verify("input/value", aliasField.input)
                              Helper.overlay("security", async securityOverlay => {
                                const res = await Helper.request("/register/groups/alias/", {id: group.created, alias: aliasField.input.value})
                                if (res.status === 200) {
                                  window.alert("Alias erfolgreich gespeichert.")
                                  await getAndRenderGroups(groupsContainer)
                                  overlay.remove()
                                  buttonsOverlay.remove()
                                  securityOverlay.remove()
                                } else {
                                  window.alert("Fehler.. Bitte wiederholen.")
                                  securityOverlay.remove()
                                }
                              })
                            }
                          })
                        }
                      }
                      {
                        const button = Helper.create("toolbox/left-right", buttons)
                        button.left.textContent = ".emails"
                        button.right.textContent = "Aktualisiere die Mitglieder deiner Gruppe"
                        button.onclick = () => {
                          Helper.overlay("popup", async overlay => {
                            const emailSelect = await defineNewGroup(overlay, (emails) => Helper.request("/register/groups/emails-self/", {id: group.created, emails}))
                            for (let i = 0; i < emailSelect.field.input.options.length; i++) {
                              const option = emailSelect.field.input.options[i]
                              if (group.emails.includes(option.value)) {
                                option.selected = true
                              }
                            }
                            emailSelect.submit.onclick = () => {
                              const emails = emailSelect.selectedEmails()
                              if (Helper.verifyIs("array/empty", emails)) {
                                window.alert("Wähle mindestens eine E-Mail Adresse.")
                                Helper.add("style/not-valid", emailSelect.field.input)
                                return
                              }
                              Helper.overlay("security", async securityOverlay => {
                                const res = await Helper.request("/register/groups/emails-self/", {id: group.created, emails})
                                if (res.status === 200) {
                                  window.alert("Deine Gruppe wurde erfolgreich gespeichert.")
                                  await getAndRenderGroups(groupsContainer)
                                  overlay.remove()
                                  buttonsOverlay.remove()
                                  securityOverlay.remove()
                                } else {
                                  window.alert("Fehler.. Bitte wiederholen.")
                                  securityOverlay.remove()
                                }
                              })
                            }
                          })
                        }
                      }
                    }
                  })

                  {
                    const button = Helper.create("button/left-right", buttons)
                    button.left.textContent = ".send-template"
                    button.right.textContent = "Sende ein HTML Template an deine Gruppe"
                    button.onclick = () => {

                      async function renderTemplates(templates, node, callback) {
                        Helper.convert("parent/scrollable", node)
                        for (let i = 0; i < templates.length; i++) {
                          const template = templates[i]
                          const templateButton = Helper.create("button/left-right", node)
                          templateButton.left.innerHTML = await Helper.convert("text/purified", template.html)
                          templateButton.right.style.fontSize = "21px"
                          templateButton.onclick = () => callback(template)
                        }
                      }

                      function openSendTemplateOverlay(template, emails) {

                        Helper.overlay("popup", async overlay => {
                          overlay.info.textContent = emails.join(", ")
                          const funnel = Helper.create("div/scrollable", overlay)

                          const subjectField = Helper.create("field/text", funnel)
                          subjectField.label.textContent = "Betreff"
                          subjectField.input.setAttribute("required", "true")
                          subjectField.style.margin = "21px 34px"
                          subjectField.input.oninput = () => Helper.verify("input/value", subjectField.input)
                          Helper.verify("input/value", subjectField.input)
                          const buttons = Helper.create("div/flex-row", funnel)
                          const testTemplateButton = Helper.create("button/action", buttons)
                          testTemplateButton.textContent = "Test senden"
                          testTemplateButton.style.background = Helper.colors.light.success
                          testTemplateButton.style.width = "233px"
                          testTemplateButton.onclick = async () => {
                            await Helper.verify("input/value", subjectField.input)
                            Helper.overlay("security", async securityOverlay => {
                              securityOverlay.remove()
                              const res = await Helper.request("/send/email/test-template/", {template: template.html, subject: subjectField.input.value})
                              if (res.status === 200) {
                                window.alert("Template erfolgreich gesendet.")
                                securityOverlay.remove()
                              }
                            })
                          }
                          const sendTemplateButton = Helper.create("button/action", buttons)
                          sendTemplateButton.textContent = "Template senden"
                          sendTemplateButton.style.width = "233px"
                          sendTemplateButton.onclick = async () => {

                            const res = await Helper.request("/get/user/tree-closed/", {tree: "email"})
                            let userEmail
                            if (res.status === 200) {
                              userEmail = res.response
                            }
                            if (!userEmail) return window.alert("Fehler.. Bitte wiederholen.")

                            await Helper.verify("input/value", subjectField.input)
                            Helper.overlay("security", async securityOverlay => {
                              try {
                                securityOverlay.textContent = ""
                                securityOverlay.style.display = "flex"
                                securityOverlay.style.flexDirection = "column"
                                securityOverlay.style.justifyContent = "center"

                                await renderEmailStatus(userEmail, group.emails, securityOverlay)
                                Helper.removeOverlayButton(securityOverlay)

                                for (let i = 0; i < group.emails.length; i++) {
                                  const email = group.emails[i]
                                  if (userEmail === email) continue

                                  document.querySelectorAll(".email-status").forEach(emailStatus => {
                                    if (emailStatus.textContent.includes(email)) {
                                      const sign = emailStatus.querySelector(".sign")

                                      Helper.request("/send/email/send-template/", {email, template: template.html, subject: subjectField.input.value})
                                      .then((res) => {
                                        if (res.status === 200) {
                                          sign.style.color = Helper.colors.dark.success
                                          sign.textContent = "Erfolgreich gesendet.."
                                        } else {
                                          sign.style.color = Helper.colors.dark.error
                                          sign.textContent = "Fehler beim Senden.."
                                        }
                                      })
                                      .catch((error) => {
                                        sign.style.color = Helper.colors.dark.error
                                        sign.textContent = "Fehler beim Senden.."
                                      })

                                    }
                                  })

                                }

                              } catch (error) {
                                window.alert("Fehler.. Bitte wiederholen.")
                                console.error(error)
                              }
                            })
                          }

                        })

                      }

                      Helper.overlay("popup", async overlay => {
                        overlay.info.textContent = group.emails.join(", ")
                        const searchField = Helper.create("input/text", overlay)
                        searchField.input.placeholder = "Suche nach Text in deinem Template"
                        searchField.style.margin = "21px 34px"
                        Helper.verify("input/value", searchField.input)
                        Helper.add("outline-hover", searchField.input)
                        const contactsDiv = Helper.create("div/scrollable", overlay)
                        const res = await Helper.request("/get/templates/closed/")
                        if (res.status === 200) {
                          const templates = JSON.parse(res.response)
                          let filtered
                          searchField.input.oninput = async (ev) => {
                            filtered = templates.filter(it => it.html.toLowerCase().includes(ev.target.value.toLowerCase()))
                            const highlighted = filtered.map(it => {
                              const highlightedHtml = it.html.replace(new RegExp(ev.target.value, 'i'), `<mark>${ev.target.value}</mark>`)
                              return { ...it, html: highlightedHtml }
                            })
                            await renderTemplates(highlighted, contactsDiv, (template) => openSendTemplateOverlay(template, group.emails))
                          }
                          await renderTemplates(templates, contactsDiv, (template) => openSendTemplateOverlay(template, group.emails))
                        } else {
                          Helper.convert("parent/info", contactsDiv)
                          contactsDiv.textContent = "Keine Templates gefunden"
                        }
                      })

                    }
                  }

                  {
                    const button = Helper.create("button/left-right", buttons)
                    button.left.textContent = ".web-call"
                    button.right.textContent = "Verbinde dich per Videochat mit deiner Gruppe"
                    button.onclick = () => {

                      if (group.emails.length > 5) {
                        window.alert("Es dürfen maximal 5 Nutzer an einem Webcall teilnehmen.")
                        return
                      }

                      const confirm = window.confirm("Wenn du dem Webcall beitrittst, wirst du direkt als online angezeigt.\n\nMöchtest du diesem Webcall beitreten?")
                      if (confirm !== true) return
                      Helper.overlay("popup", async overlay => {
                        overlay.info.textContent = ".web-call"
                        const content = Helper.create("info/loading", overlay)
                        let res = await Helper.request("/verify/user/jwt-in-emails/", {emails: group.emails})
                        if (res.status !== 200) {
                          window.alert("Fehler.. Bitte wiederholen.")
                          overlay.remove()
                          return
                        }

                        res = await Helper.request("/get/user/tree-closed/", {tree: "email"})
                        if (res.status !== 200) {
                          window.alert("Fehler.. Bitte wiederholen.")
                          overlay.remove()
                          return
                        }

                        Helper.convert("parent/scrollable", content)

                        const localStream = await navigator.mediaDevices.getUserMedia({video: true, audio: true})
                        const userEmail = res.response
                        const peerConnections = {}

                        overlay.removeOverlayButton.addEventListener("click", () => {
                          stopLocalStream(localStream)
                          send("stop")
                          socket.close()
                        })

                        function escapeCSSId(id) {
                          return id.replace(/\./g, "-").replace(/@/g, "-")
                        }

                        const container = document.createElement("div")
                        Helper.style(container, {margin: "21px 34px", display: "flex", flexWrap: "wrap", justifyContent: "space-around", alignItems: "center"})
                        content.appendChild(container)
                        const fragment = document.createDocumentFragment()

                        function updateStatus(node) {
                          const video = node.querySelector("video")
                          const status = node.querySelector(".status")
                          if (video.srcObject) {
                            status.textContent = "on"
                            status.style.backgroundColor = "green"
                          } else {
                            status.textContent = "off"
                            status.style.backgroundColor = "red"
                          }
                        }

                        function createUserBox(email, node) {

                          const userBox = document.createElement("div")
                          Helper.style(userBox, {fontSize: "21px", fontFamily: "sans-serif", position: "relative", borderRadius: "13px", margin: "8px", padding: "8px", minWidth: "55px"})
                          Helper.convert("dark-light", userBox)
                          userBox.className = "user"

                          userBox.video = document.createElement("video")
                          userBox.video.id = escapeCSSId(email)
                          userBox.video.autoplay = true
                          userBox.video.controls = true
                          userBox.video.style.width = "100%"
                          userBox.appendChild(userBox.video)

                          userBox.info = document.createElement("div")
                          Helper.style(userBox.info, {display: "flex", justifyContent: "space-between", alignItems: "center"})
                          userBox.appendChild(userBox.info)

                          userBox.email = document.createElement("div")
                          userBox.email.className = "email"
                          userBox.email.textContent = email
                          Helper.style(userBox.email, {whiteSpace: "nowrap", overflow: "auto"})
                          userBox.info.appendChild(userBox.email)

                          userBox.status = document.createElement("div")
                          userBox.status.className = "status"
                          Helper.style(userBox.status, {display: "flex", justifyContent: "center", alignItems: "center", width: "34px", height: "34px", borderRadius: "50%"})
                          userBox.info.appendChild(userBox.status)
                          updateStatus(userBox)

                          node?.appendChild(userBox)
                          return userBox
                        }

                        const localUserBox = createUserBox(userEmail, fragment)
                        localUserBox.video.srcObject = localStream
                        updateStatus(localUserBox)

                        for (let i = 0; i < group.emails.length; i++) {
                          const email = group.emails[i]
                          if (email === userEmail) continue
                          createUserBox(email, fragment)
                        }
                        container.appendChild(fragment)

                        function stopLocalStream(stream) {
                          stream.getTracks().forEach(track => track.stop())
                        }

                        const socket = new WebSocket(`wss://${window.location.host}`)

                        function send(type, data = {}) {
                          socket.send(JSON.stringify({type, emails: group.emails, ...data}))
                        }

                        socket.onopen = async ev => {
                          console.log('WebSocket connected.')
                          setTimeout(() => send("start"), 610)
                        }

                        function createPeerConnection(email) {
                          const peerConnection = new RTCPeerConnection({iceServers: [{urls: "stun:stun.l.google.com:19302"}]})
                          peerConnection.onicecandidate = ev => {
                            if (ev.candidate) send("iceCandidate", {candidate: ev.candidate})
                          }
                          peerConnection.ontrack = ev => {
                            const [remoteStream] = ev.streams
                            const videoTag = document.querySelector(`video#${escapeCSSId(email)}`)
                            if (videoTag) {
                              videoTag.srcObject = remoteStream
                              updateStatus(videoTag.parentElement)
                            }
                          }
                          localStream.getTracks().forEach(track => {
                            peerConnection.addTrack(track, localStream)
                          })
                          return peerConnection
                        }

                        function closePeerConnection(email) {
                          if (peerConnections[email]) {
                            peerConnections[email].close()
                            delete peerConnections[email]
                            const video = document.querySelector(`video#${escapeCSSId(email)}`)
                            video.srcObject = null
                            const status = video.parentElement.querySelector(".status")
                            status.textContent = "off"
                            status.style.backgroundColor = "red"
                          }
                        }

                        socket.onmessage = async ev => {

                          const data = JSON.parse(ev.data)
                          // todo test in production what is happening??
                          console.log("Received message:", data)

                          if (data.type === "start") {
                            if (!peerConnections[data.from]) peerConnections[data.from] = createPeerConnection(data.from)
                            const offer = await peerConnections[data.from].createOffer()
                            await peerConnections[data.from].setLocalDescription(offer)
                            send("offer", {offer, from: data.from})
                          }

                          if (data.type === "offer") {
                            if (!peerConnections[data.from]) peerConnections[data.from] = createPeerConnection(data.from)
                            peerConnections[data.from].setRemoteDescription(new RTCSessionDescription(data.offer))
                            const answer = await peerConnections[data.from].createAnswer()
                            await peerConnections[data.from].setLocalDescription(answer)
                            send("answer", {answer})
                          }

                          if (data.type === "answer") {
                            await peerConnections[data.from].setRemoteDescription(new RTCSessionDescription(data.answer))
                          }

                          if (data.type === "iceCandidate") {
                            if (peerConnections[data.from]) peerConnections[data.from].addIceCandidate(new RTCIceCandidate(data.candidate))
                          }

                          if (data.type === "stop") {
                            closePeerConnection(data.from)
                          }

                        }

                        socket.onerror = (error) => {
                          console.error('WebSocket error:', error)
                          socket.close()
                        }

                        socket.onclose = (event) => {
                          console.log('WebSocket closed.')
                        }

                      })

                    }
                  }

                  {
                    const button = Helper.create("button/left-right", buttons)
                    button.left.textContent = ".web-chat"
                    button.right.textContent = "Schreibe deiner Gruppe Nachrichten"

                  }

                  {
                    const button = Helper.create("button/left-right", buttons)
                    button.left.textContent = ".file-sharing"
                    button.right.textContent = "Teile Daten mit deiner Gruppe"

                  }

                  function renderEmailStatus(except, emails, node) {
                    return new Promise((resolve, reject) => {
                      try {
                        let iterations = 0

                        for (let i = 0; i < emails.length; i++) {
                          const email = emails[i]
                          if (except && except === email) continue
                          const container = Helper.create("div", node)
                          container.className = "email-status"
                          Helper.style(container, {wordBreak: "break-word", display: "flex", flexWrap: "wrap", margin: "21px 34px", fontSize: "21px", fontFamily: "sans-serif", alignItems: "center"})
                          container.style.color = Helper.colors.light.text
                          if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                            container.style.color = Helper.colors.dark.text
                          }
                          const emailDiv = Helper.create("div", container)
                          emailDiv.textContent = `${email}: `
                          const signDiv = Helper.create("div", container)
                          signDiv.className = "sign"
                          signDiv.style.marginLeft = "34px"
                          Helper.render("icon/node/path", "/public/loading.svg", signDiv)
                          iterations++
                        }

                        if (iterations === emails.length - 1) {
                          return resolve()
                        } else {
                          throw new Error("iterations mismatch")
                        }

                      } catch (error) {
                        console.error(error)
                        reject(error)
                      }

                    })

                  }


                  {
                    const button = Helper.create("button/left-right", buttons)
                    button.left.textContent = ".location-sharing"
                    button.right.textContent = "Teile deinen Standort mit deiner Gruppe"
                    button.onclick = async () => {

                      function getCoords() {
                        return new Promise((resolve, reject) => {
                          function success(pos) {
                            resolve(pos.coords)
                          }

                          function error(err) {
                            reject(err)
                          }

                          navigator.geolocation.getCurrentPosition(success, error, {
                            enableHighAccuracy: true,
                            timeout: 5000,
                            maximumAge: 0
                          })
                        })
                      }

                      const res = await Helper.request("/get/user/tree-closed/", {tree: "email"})
                      let userEmail
                      if (res.status === 200) {
                        userEmail = res.response
                      }
                      if (!userEmail) return window.alert("Fehler.. Bitte wiederholen.")

                      Helper.overlay("security", async securityOverlay => {
                        try {
                          securityOverlay.textContent = ""
                          securityOverlay.style.display = "flex"
                          securityOverlay.style.flexDirection = "column"
                          securityOverlay.style.justifyContent = "center"

                          await renderEmailStatus(userEmail, group.emails, securityOverlay)

                          Helper.removeOverlayButton(securityOverlay)

                          let coords
                          try {
                            coords = await getCoords()
                          } catch (error) {
                            window.alert("Fehler.. Bitte wiederholen.")
                            console.error(error)
                            securityOverlay.remove()
                            return
                          }
                          if (!coords) return

                          for (let i = 0; i < group.emails.length; i++) {
                            const email = group.emails[i]
                            if (userEmail === email) continue

                            document.querySelectorAll(".email-status").forEach(emailStatus => {
                              if (emailStatus.textContent.includes(email)) {
                                const sign = emailStatus.querySelector(".sign")

                                Helper.request("/send/email/lat-lon/", {to: email, lat: coords.latitude, lon: coords.longitude})
                                .then((res) => {
                                  if (res.status === 200) {
                                    sign.style.color = Helper.colors.dark.success
                                    sign.textContent = "Erfolgreich gesendet.."
                                  } else {
                                    sign.style.color = Helper.colors.dark.error
                                    sign.textContent = "Fehler beim Senden.."
                                  }
                                })
                                .catch((error) => {
                                  sign.style.color = Helper.colors.dark.error
                                  sign.textContent = "Fehler beim Senden.."
                                })

                              }
                            })


                          }

                        } catch (error) {
                          console.error(error);
                        }
                      })
                    }
                  }
                  {
                    const button = Helper.create("button/left-right", buttons)
                    button.left.textContent = ".remove"
                    button.right.textContent = "Gruppe entfernen"
                    button.onclick = () => {

                      const confirm = window.confirm("Möchtest du deine Gruppe wirklich entfernen?")
                      if (confirm === true) {
                        Helper.overlay("security", async securityOverlay => {
                          const res = await Helper.request("/remove/groups/id-self/", {id: group.created})
                          if (res.status === 200) {
                            window.alert("Gruppe erfolgreich entfernt.")
                            groupButton.remove()
                            buttonsOverlay.remove()
                            securityOverlay.remove()
                          } else {
                            window.alert("Fehler.. Bitte wiederholen.")
                            securityOverlay.remove()
                          }
                        })
                      }
                    }
                  }
                })

              }

            }
            parent?.appendChild(fragment)
            return fragment
          }

          async function getAndRenderGroups(parent) {
            const res = await Helper.request("/get/groups/self/")
            if (res.status === 200) {
              const groups = JSON.parse(res.response)
              renderGroupButtons(groups, parent)
              filterGroupsByEmail(groups, parent)
            } else {
              Helper.convert("parent/info", parent)
              renderInfo("Deine E-Mail Adresse wurde in keiner Gruppe gefunden. Erstelle eine neue Gruppe in dem du auf", "/public/add.svg", "klickst.", parent)
            }
          }

        })
      }
    }

    if (event === "id/total-amount") {

      return new Promise(async(resolve, reject) => {
        try {

          const node = await this.verifyIs("id/loaded", input)

          for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i]

            const input = child.querySelector("input.quantity")

            input.oninput = (ev) => {

              const price = child.querySelector("span.single-price")

              const target = child.querySelector("span.total-amount")

              const result = parseFloat(price.textContent) * parseInt(ev.target.value)

              target.textContent = result.toFixed(2).replace(".", ",")

            }

          }

        } catch (error) {
          reject(error)
        }
      })

    }

    if (event === "select-options") {

      input.select.textContent = ""
      for (let i = 0; i < input.options.length; i++) {
        const option = document.createElement("option")
        option.value = input.options[i]
        option.text = input.options[i]
        input.select.appendChild(option)
      }
    }

    if (event === "selected/node") {
      input.setAttribute("selected-node", "true")
      input.style.outline = "3px solid #777"
    }

    if (event === "selector/reputation-self") {
      const node = document.querySelector(input)

      if (node) {

        this.request("/verify/user/closed/").then((res) => {

          if (res.status === 200) {
            this.request("/get/user/reputation-self/").then((res) => {

              if (this.verifyIs("text/int", res.response)) {
                node.textContent = res.response
              }

            })
          }

        }).catch(() => node.textContent = 0)

      }

    }

    if (event === "element/selected-node") {
      input.setAttribute("selected-node", "true")
      input.style.outline = "3px solid #777"
    }

    if (event === "my-value-units") {

      return new Promise(async(resolve, reject) => {
        try {
          const valueUnitsDiv = document.querySelector(".my-value-units")
          valueUnitsDiv.style.display = "flex"
          this.style(valueUnitsDiv, {display: "flex", overflowX: "auto", whiteSpace: "nowrap"})
          if (valueUnitsDiv) {
            const res = await this.request("/get/platform/values-writable/")
            if (res.status === 200) {
              const valueUnits = JSON.parse(res.response)
              valueUnitsDiv.textContent = ""
              for (let i = 0; i < valueUnits.length; i++) {
                const value = valueUnits[i]
                const valueBox = this.create("div")
                this.style(valueBox, {cursor: "pointer", width: "144px", borderRadius: "5px", margin: "21px 13px", fontFamily: "sans-serif", boxShadow: "rgba(0, 0, 0, 0.13) 0px 1px 3px"})
                valueUnitsDiv.appendChild(valueBox)
                this.add("outline-hover", valueBox)
                valueBox.onclick = () => {
                  window.open(value.path, "_blank")
                }
                const img = document.createElement("img")
                img.src = value.image
                if (value.image === undefined) img.src = "/public/image.svg"
                img.style.width = "100%"
                valueBox.appendChild(img)
                const title = document.createElement("div")
                title.textContent = value.alias
                this.style(title, {margin: "13px", overflow: "hidden", textOverflow: "ellipsis"})
                valueBox.appendChild(title)
                const requested = document.createElement("div")
                requested.textContent = `Angefordert: ${value.requested.length}`
                this.style(requested, {margin: "13px", whiteSpace: "break-word"})
                valueBox.appendChild(requested)
                function closedState(node) {
                  node.checked = false
                  Helper.add("style/not-valid", node)
                }
                function openState(node) {
                  node.checked = true
                  Helper.add("style/valid", node)
                }
                const openClosedField = this.create("input/checkbox", valueBox)
                openClosedField.input.onclick = (ev) => {
                  ev.stopPropagation()
                  if (openClosedField.input.checked === false) {
                    this.add("style/not-valid", openClosedField.input)
                    const confirm = window.confirm("Diese Werteinheit wird für keinen Sichtbar sein.\n\nMöchtest du fortfahren?")
                    if (confirm === false) {
                      if (openClosedField.input.checked === true) {
                        closedState(openClosedField.input)
                      }
                      if (openClosedField.input.checked === false) {
                        openState(openClosedField.input)
                      }
                      return
                    }
                    if (confirm === true) {
                      this.overlay("security", async securityOverlay => {
                        const res = await this.request("/register/platform/value-visibility-writable/", {path: value.path, visibility: "closed"})
                        if (res.status === 200) {
                          closedState(openClosedField.input)
                          window.alert("Sichtbarkeit wurde gespeichert.")
                          securityOverlay.remove()
                        } else {
                          openState(openClosedField.input)
                          window.alert("Fehler.. Bitte wiederholen.")
                          securityOverlay.remove()
                        }
                      })
                    }
                  }
                  if (openClosedField.input.checked === true) {
                    this.add("style/valid", openClosedField.input)
                    const confirm = window.confirm("Diese Werteinheit wird für alle Sichtbar sein.\n\nMöchtest du fortfahren?")
                    if (confirm === false) {
                      closedState(openClosedField.input)
                      return
                    }
                    if (confirm === true) {
                      this.overlay("security", async securityOverlay => {
                        const res = await this.request("/register/platform/value-visibility-writable/", {path: value.path, visibility: "open"})
                        if (res.status === 200) {
                          openState(openClosedField.input)
                          window.alert("Sichtbarkeit wurde gespeichert.")
                          securityOverlay.remove()
                        } else {
                          closedState(openClosedField.input)
                          window.alert("Fehler.. Bitte wiederholen.")
                          securityOverlay.remove()
                        }
                      })
                    }
                  }
                }
                if (value.visibility === "open") {
                  openState(openClosedField.input)
                }
                if (openClosedField.input.checked === false) {
                  closedState(openClosedField.input)
                }
              }
            } else {
              valueUnitsDiv.textContent = "Es wurden keine Werteinheiten gefunden."

            }
            resolve()
          }
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "node/onbody") {

      return new Promise(async(resolve, reject) => {

        try {
          if (document) {
            if (document.body) {
              document.body.append(input)
              resolve()
            }
          }
        } catch (error) {
          reject(error)
        }

      })

    }

    if (event === "numerology") {

      const birthdateField = document.querySelector("#birthdate")
      this.convert("dark-light", birthdateField)
      const birthdateInput = birthdateField.querySelector("input[type='date']")
      birthdateInput.value = Helper.convert("millis/yyyy-mm-dd", Date.now())
      birthdateInput.oninput = () => this.add("style/valid", birthdateInput)
      this.add("outline-hover", birthdateInput)

      this.request("/verify/user/closed/").then(async res => {
        if (res.status === 200) {
          const birthnameTree = "numerologie.birthname"
          const birthdateTree = "numerologie.birthdate"
          res = await this.request("/get/user/tree-closed/", {tree: birthdateTree})
          if (res.status === 200) {
            birthdateInput.value = res.response.split("T")[0]
          }
        } else {

          const buttons = this.create("div")
          submit.after(buttons)
          buttons.style.display = "flex"
          buttons.style.flexDirection = "column"
          buttons.style.alignItems = "center"

          const orDiv = this.create("div")
          buttons.appendChild(orDiv)
          orDiv.textContent = "oder"
          orDiv.style.textAlign = "center"
          orDiv.style.margin = "21px 0"

          const toLogin = this.create("toolbox/action")
          buttons.appendChild(toLogin)
          toLogin.textContent = "Jetzt anmelden"
          this.style(toLogin, {width: "233px", padding: "13px 21px", margin: "0", height: "auto"})
          toLogin.onclick = () => window.location.assign("/entwicklung/numerologie/login/")

        }
      })

      const submit = document.querySelector(".submit-numerology")
      this.add("outline-hover", submit)
      submit.onclick = () => {

        const birthdateField = document.querySelector("#birthdate")
        const birthdateInput = birthdateField.querySelector("input[type='date']")
        const birthdateValue = birthdateInput.value
        const numerology = this.fn("numerology")

        if (this.verifyIs("text/empty", birthdateValue)) {
          window.alert("Du hast vergessen dein Geburtsdatum einzugeben.")
          this.add("style/not-valid", birthdateInput)
          return
        } else {
          this.add("style/valid", birthdateInput)
        }

        this.overlay("popup", async numerologyOverlay => {
          const date = new Date(birthdateValue)
          const content = this.create("div/scrollable", numerologyOverlay)
          this.render("text/h1", `Numerologie Rechner`, content)
          numerology.renderAge(date, content)
          numerology.renderLifePath(date, content)
          numerology.renderMaster(date, content)
          numerology.renderBirthDayEnergy(date, content)
          numerology.renderPrevailingEnergies(date, content)
          numerology.renderRecedingEnergies(date, content)
          numerology.renderTones(date, content)
          numerology.renderFirstCycle(date, content)
          numerology.renderFirstKeyTone(date, content)
          numerology.renderSecondCycle(date, content)
          numerology.renderSecondKeyTone(date, content)
          numerology.renderThirdCycle(date, content)
          numerology.renderThirdKeyTone(date, content)
          numerology.renderFourthCycle(date, content)
          numerology.renderFourthKeyTone(date, content)

          const res = await this.request("/verify/user/closed/")
          if (res.status === 200) {
            const birthNameField = this.create("input/text", content)
            birthNameField.input.placeholder = "Gebe deinen Geburtsnamen ein.."
            const birthnameTree = "numerologie.birthname"
            const res = await this.request("/get/user/tree-closed/", {tree: birthnameTree})
            if (res.status === 200) {
              birthNameField.input.value = res.response
            }
            birthNameField.input.oninput = (ev) => {
              const birthname = ev.target.value
              if (this.verifyIs("text/empty", birthname)) {
                this.add("style/not-valid", birthNameField.input)
                return
              }
              numerology.updateBirthNameFunctions(birthname)
              this.add("style/valid", birthNameField.input)
            }
            numerology.renderBirthNameFunctions(birthNameField.input.value, content)
            const toSave = this.create("toolbox/action", content)
            toSave.textContent = "Zu deinem Profil"
            toSave.onclick = () => {
              this.overlay("security", async securityOverlay => {
                const res = await this.request("/register/location/map-self/", {map: {birthname: birthNameField.input.value, birthdate: new Date(birthdateValue).toISOString()}})
                if (res.status === 200) {
                  window.alert("Deine Daten wurden erfolgreich gespeichert.")
                  const res = await this.request("/get/user/tree-closed/", {tree: "id"})
                  if (res.status === 200) {
                    window.location.assign(`/entwicklung/numerologie/profil/${res.response}/`)
                  }
                } else {
                  window.alert("Fehler.. Bitte wiederholen.")
                  securityOverlay.remove()
                }
              })
            }
          } else {
            const toSave = this.create("toolbox/action", content)
            toSave.textContent = "Jetzt Geburtsname berechnen"
            toSave.onclick = () => window.location.assign("/entwicklung/numerologie/login/")
          }

        })

      }

    }

    if (event === "oninput/verify-positive-integer") {

      input.addEventListener("input", () => {
        if (this.verifyIs("text/+int", input.value)) {
          this.add("style/valid", input)
        } else {
          this.add("style/not-valid", input)
        }
      })

    }

    if (event === "onclick/overlay-owner-funnel") {

      input.addEventListener("click", () => {

        this.overlay("toolbox", async overlay => {

          this.removeOverlayButton(overlay)

          const res = await this.request("/get/owner/closed/")
          if (res.status === 200) {
            const owner = JSON.parse(res.response)
            this.render("field-funnel/owner", owner, overlay)
          }

          if (res.status !== 200) {
            this.render("field-funnel/owner", overlay)
          }

        })

      })

    }

    if (event === "onclick/assign-expert-home") {

      input.addEventListener("click", async () => {

        const res = await this.request("/get/expert/name-self/")
        if (res.status === 200) {
          const name = res.response
          window.location.assign(`/${name}/`)
        }

      })

    }

    if (event === "onclick/selector/contact-location-expert") {
      document.querySelectorAll(input).forEach(node => {
        this.add("outline-hover", node)
        node.onclick = () => {

          this.overlay("popup", overlay => {
            this.render("text/h1", "Kontakt anfragen", overlay)

            const funnel = this.create("div/scrollable", overlay)

            const preferenceField = this.create("field/select", funnel)
            preferenceField.label.textContent = "Wie möchten Sie gerne kontaktiert werden"
            preferenceField.input.add(["E-Mail", "Telefon", "Webcall"])
            this.add("outline-hover", preferenceField.input)
            this.verify("input/value", preferenceField.input)

            const emailField = this.create("field/email", funnel)
            this.add("outline-hover", emailField.input)
            this.verify("input/value", emailField.input)
            emailField.input.oninput = () => this.verify("input/value", emailField.input)

            const subjectField = this.create("field/textarea", funnel)
            subjectField.label.textContent = "Betreff"
            subjectField.input.style.height = "89px"
            subjectField.input.placeholder = "Für eine schnelle Bearbeitung, können Sie uns hier den Grund Ihrer Kontaktanfrage nennen."
            subjectField.input.setAttribute("required", "true")
            this.add("outline-hover", subjectField.input)
            this.verify("input/value", subjectField.input)
            subjectField.input.oninput = () => this.verify("input/value", subjectField.input)

            const placeholderDiv = this.create("div", funnel)
            let telField
            preferenceField.input.oninput = () => {
              const value = preferenceField.input.value
              placeholderDiv.textContent = ""
              if (value === "Telefon") {
                telField = this.create("field/tel", placeholderDiv)
                telField.label.textContent = "Telefon Nummer"
                telField.input.placeholder = "+49.."
                telField.input.setAttribute("required", "true")
                telField.input.setAttribute("accept", "text/tel")
                telField.input.oninput = () => this.verify("input/value", telField.input)
                this.add("outline-hover", telField.input)
                this.verify("input/value", telField.input)
              } else {
                telField = undefined
              }

            }

            const submit = this.create("button/action", funnel)
            submit.textContent = "Kontakt jetzt anfragen"
            this.add("outline-hover", submit)
            submit.onclick = async () => {
              await this.verify("field-funnel", funnel)

              const preference = preferenceField.input.value
              const email = emailField.input.value
              const subject = subjectField.input.value
              if (subject.length > 144) {
                this.add("style/not-valid", subjectField.input)
                window.alert("Betreff darf nur 144 Zeichen enthalten.")
                return
              }
              let tel
              if (telField) {
                tel = telField.input.value
              } else {
                tel = undefined
              }

              this.callback("email/pin-verified", email, async overlay => {
                const res = await this.request("/register/contacts/lead-location-expert/", {preference, email, subject, tel})
                if (res.status === 200) {
                  window.alert(`Ihre Anfrage wurde erfolgreich weitergeleitet.\n\nIhr Ansprechpartner wird sich, per ${preference}, bei Ihnen melden.`)
                  overlay.remove()
                } else {
                  window.alert("Fehler.. Bitte wiederholen.")
                }
              })

            }

          })
        }
      })
    }

    if (event === "field/image-url") {
      const field = this.create("field/url", input)
      field.input.setAttribute("required", "true")
      field.input.accept = "text/https"
      field.label.textContent = "Gebe hier die Quell-Url für dein Bild ein"
      field.input.placeholder = "https://www.meine-quelle.de"
      this.verify("input/value", field.input)
      field.input.addEventListener("input", () => this.verify("input/value", field.input))

      if (input) input.append(field)
      return field
    }

    if (event === "field/image-url") {
      const field = this.create("field/url")
      field.input.setAttribute("required", "true")
      field.input.accept = "text/https"
      field.label.textContent = "Gebe hier die Quell-Url für dein Bild ein"
      field.input.placeholder = "https://www.meine-quelle.de"

      this.verify("input/value", field.input)
      field.input.oninput = () => this.verify("input/value", field.input)

      if (input) input.append(field)
      return field
    }

    if (event === "observer/id-mutation") {

      const cache = {}

      const observer = new MutationObserver((mutations, observer) => {
        for (let i = 0; i < mutations.length; i++) {
          const mutation = mutations[i]

          if (mutation.type === "childList") {

            mutation.removedNodes.forEach(node => {


              if (!this.verifyIs("text/empty", node.id)) {

                const borderStyle = "2px dashed rgb(176, 53, 53)"

                const ids = document.querySelectorAll(`#${node.id}`)

                if (ids[1] !== undefined) {
                  cache.id = node.id
                  document.querySelectorAll(`#${ids[1].id}`).forEach(id => {
                    id.style.border = borderStyle
                  })
                }

                if (ids[1] === undefined) {

                  if (cache.id !== undefined) {

                    const oldIds = document.querySelectorAll(`#${cache.id}`)

                    if (oldIds[1] !== undefined) {
                      document.querySelectorAll(`#${oldIds[1].id}`).forEach(id => {
                        id.style.border = borderStyle
                      })
                    }

                    if (oldIds[1] === undefined) {

                      oldIds.forEach(id => {

                        if (id.style.border === borderStyle) {
                          id.style.border = null
                        }

                      })

                    }


                  }

                  ids.forEach(id => {

                    if (id.style.border === borderStyle) {
                      id.style.border = null
                    }

                  })

                }

              }


            })

            mutation.addedNodes.forEach(node => {

              if (!this.verifyIs("text/empty", node.id)) {

                const borderStyle = "2px dashed rgb(176, 53, 53)"

                const ids = document.querySelectorAll(`#${node.id}`)

                if (ids[1] !== undefined) {
                  cache.id = node.id
                  document.querySelectorAll(`#${ids[1].id}`).forEach(id => {
                    id.style.border = borderStyle
                  })
                }

                if (ids[1] === undefined) {

                  if (cache.id !== undefined) {

                    const oldIds = document.querySelectorAll(`#${cache.id}`)

                    if (oldIds[1] !== undefined) {
                      document.querySelectorAll(`#${oldIds[1].id}`).forEach(id => {
                        id.style.border = borderStyle
                      })
                    }

                    if (oldIds[1] === undefined) {

                      oldIds.forEach(id => {

                        if (id.style.border === borderStyle) {
                          id.style.border = null
                        }

                      })

                    }


                  }

                  ids.forEach(id => {

                    if (id.style.border === borderStyle) {
                      id.style.border = null
                    }

                  })

                }

              }


            })

          }

          if (mutation.type === 'attributes' && mutation.attributeName === 'id') {

            if (!this.verifyIs("text/empty", mutation.target.id)) {


              const borderStyle = "2px dashed rgb(176, 53, 53)"

              const ids = document.querySelectorAll(`#${mutation.target.id}`)

              if (ids[1] !== undefined) {
                cache.id = mutation.target.id
                document.querySelectorAll(`#${ids[1].id}`).forEach(id => {
                  id.style.border = borderStyle
                })
              }

              if (ids[1] === undefined) {

                if (cache.id !== undefined) {

                  const oldIds = document.querySelectorAll(`#${cache.id}`)

                  if (oldIds[1] !== undefined) {
                    document.querySelectorAll(`#${oldIds[1].id}`).forEach(id => {
                      id.style.border = borderStyle
                    })
                  }

                  if (oldIds[1] === undefined) {

                    oldIds.forEach(id => {

                      if (id.style.border === borderStyle) {
                        id.style.border = null
                      }

                    })

                  }


                }

                ids.forEach(id => {

                  if (id.style.border === borderStyle) {
                    id.style.border = null
                  }

                })

              }


            }
          }

        }
      })
      observer.observe(document.documentElement, {
        childList: true,
        subtree: true,
        attributes: true,
      })

    }

    if (event === "open-toolbox") {

      const back = this.create("toolbox/back")
      const toolbox = this.create("toolbox/getyour")

      toolbox.style.zIndex = "2"

      back.setAttribute("data-id", "toolbox")
      toolbox.setAttribute("data-id", "toolbox")

      document.body.insertBefore(back, document.querySelector("#toolbox"))
      document.body.insertBefore(toolbox, document.querySelector("#toolbox"))

      toolbox.addEventListener("click", () => {
        this.overlay("tools")
      })
    }

    if (event === "oscillator") {

      const audioContext = new (window.AudioContext || window.webkitAudioContext)()
      const source = audioContext.createMediaStreamSource(input.stream)
      const analyser = audioContext.createAnalyser()
      analyser.fftSize = 2048
      source.connect(analyser)
      const bufferLength = analyser.frequencyBinCount
      const dataArray = new Uint8Array(bufferLength)
      function draw(node) {
        requestAnimationFrame(() => draw(node))
        analyser.getByteTimeDomainData(dataArray)
        let canvas = node.querySelector("canvas")
        if (!canvas) {
          canvas = document.createElement("canvas")
          Helper.style(canvas, {position: "absolute", left: "0", top: "34%"})
          node.appendChild(canvas)
          canvas.width = node.offsetWidth
          canvas.height = 200
        }
        const canvasCtx = canvas.getContext("2d")
        canvasCtx.clearRect(0, 0, canvas.width, canvas.height)
        canvasCtx.lineWidth = 2
        canvasCtx.strokeStyle = "rgb(0, 255, 0)"
        canvasCtx.beginPath()
        const sliceWidth = (canvas.width * 1.0) / bufferLength
        let x = 0
        for (let i = 0; i < bufferLength ;i++) {
          const v = dataArray[i] / 128.0
          const y = (v * canvas.height) / 2
          if (i === 0) {
            canvasCtx.moveTo(x, y)
          } else {
            canvasCtx.lineTo(x, y)
          }
          x += sliceWidth
        }
        canvasCtx.lineTo(canvas.width, canvas.height / 2)
        canvasCtx.stroke()
      }
      return {draw}
    }

    if (event === "pointer") {

      input.setAttribute("onmouseover", "this.style.cursor = 'pointer'; this.style.outline = '3px solid #999'")
      input.setAttribute("onmouseout", "this.style.cursor = null; this.style.outline = null")
    }

    if (event === "toolbox/buttons") {

      const back = this.create("toolbox/back")
      const toolbox = this.create("toolbox/getyour")

      toolbox.style.zIndex = "2"

      back.setAttribute("data-id", "toolbox")
      toolbox.setAttribute("data-id", "toolbox")

      document.body.insertBefore(back, document.querySelector("#toolbox"))
      document.body.insertBefore(toolbox, document.querySelector("#toolbox"))

      toolbox.addEventListener("click", () => {
        this.overlay("tools", {save: true, type: "expert"})
      })
    }

    if (event === "toolbox-getter") {

      const script = this.create("script", {id: "toolbox-getter", js: "await Helper.add('toolbox/onbody')"})
      this.add("script-onbody", script)
    }

    if (event === "toolbox/onbody") {

      return new Promise(async(resolve, reject) => {

        try {

          function addToolbox(){

            if (Helper.verifyIs("path/valid")) {
              Helper.add("toolbox/buttons")
              Helper.add("observer/id-mutation")
              const save = (ev) => {
                if ((ev.ctrlKey || ev.metaKey) && ev.key === 's') {
                  ev.preventDefault()
                  Helper.add("register-html")
                }
              }
              window.addEventListener('keydown', save)
            }
          }

          const res = await this.request("/verify/user/closed/")
          if (res.status === 200) {
            const res = await this.request("/verify/user/location-expert/")
            if (res.status === 200) {
              addToolbox()
              resolve()
            }

            if (res.status !== 200) {
              const res = await this.request("/verify/user/location-writable/")
              if (res.status === 200) {
                addToolbox()
                resolve()
              }
            }
          }

          reject()

        } catch (error) {
          reject(error)
        }

      })

    }

    if (event === "field-funnel/oninput-sign-support") {
      input.querySelectorAll(".field").forEach(field => {
        const input = field.querySelector(".field-input")
        input.oninput = () => this.verify("input/value", input)
      })
    }

    if (event === "ms/timeout") {
      return new Promise(resolve => {
        setTimeout(() => {
          return resolve()
        }, input)
      })
    }

    if (event === "event/service-creator") {

      return new Promise(async(resolve, reject) => {
        try {

          const companyName = document.querySelector("div.company-name")
          const totalPrice = document.querySelector("span.total-price")
          const singlePrice = document.querySelector("span.single-price")
          const serviceUnits = document.querySelectorAll("span.service-unit")
          const quantityInput = document.querySelector("input.quantity")
          const serviceSelect = document.querySelector("div.service-select").firstChild

          let selectedServices
          serviceSelect.oninput = (ev) => {
            const selected = ev.target.value

            companyName.textContent = "Firma"
            singlePrice.textContent = "0,00"
            totalPrice.textContent = "0,00"
            selectedServices = []

            this.overlay("toolbox", async roleListOverlay => {
              // this.removeOverlayButton(roleListOverlay)

              const buttons = this.create("info/loading", roleListOverlay)

              const res = await this.request("/get/user/trees-open/", {trees: [`${window.location.pathname.split("/")[2]}.${selected}`, `${window.location.pathname.split("/")[2]}.company.name`, `${window.location.pathname.split("/")[2]}.services`, "reputation"]})
              if (res.status === 200) {
                const users = JSON.parse(res.response)

                this.sort("array/reputation/descending", users)

                this.convert("parent/scrollable", buttons)

                this.render("text/h1", `${this.convert("text/capital-first-letter", selected)} auswählen`, buttons)

                for (let i = 0; i < users.length; i++) {
                  const user = users[i]

                  const button = this.create("button/left-right", buttons)
                  button.left.textContent = user[`${window.location.pathname.split("/")[2]}.company.name`]
                  button.right.textContent = `${user[`${window.location.pathname.split("/")[2]}.services`].length} Dienstleistungen`
                  button.onclick = () => {
                    this.overlay("toolbox", selectServicesOverlay => {
                      overlay.registerHtmlButton.onclick = () => {

                        if (selectedServices === undefined || selectedServices.length === 0) {
                          window.alert("Es wurde keine Leistung ausgewählt.")
                        }

                        if (selectedServices !== undefined && selectedServices.length > 0) {
                          const serviceOptions = document.querySelector("div.service-options")
                          const serviceBox = this.create("div/service-box", serviceOptions)
                          serviceBox.checkbox.checked = true
                          serviceBox.quantity.textContent = document.querySelector("input.quantity").value
                          const company = document.createElement("p")
                          company.style.fontWeight = "bold"
                          company.textContent = document.querySelector("div.company-name").textContent
                          serviceBox.service.appendChild(company)
                          for (let i = 0; i < selectedServices.length; i++) {
                            const service = selectedServices[i]
                            const serviceDiv = document.createElement("div")
                            serviceDiv.textContent = service.name
                            serviceBox.service.append(serviceDiv)
                          }
                          serviceBox.singlePrice.textContent = document.querySelector("div.single-price").textContent
                          serviceBox.totalPrice.textContent = document.querySelector("div.total-price").textContent
                          this.remove("overlays")
                        }

                      }

                      const serviceButtons = this.create("div/scrollable", selectServicesOverlay)

                      this.render("text/h1", `Leistungen auswählen`, serviceButtons)

                      for (let i = 0; i < user[`${window.location.pathname.split("/")[2]}.services`].length; i++) {
                        const locationList = user[`${window.location.pathname.split("/")[2]}.services`][i]

                        const button = this.create("button/left-right", serviceButtons)

                        const checkbox = this.create("input/checkbox", button.left)
                        checkbox.style.transform = "scale(2)"
                        checkbox.style.margin = "0 21px"
                        checkbox.style.cursor = "pointer"
                        for (let i = 0; i < selectedServices.length; i++) {
                          const selectedService = selectedServices[i]
                          if (selectedService.name === locationList.funnel.name) {
                            checkbox.checked = true
                          }
                        }
                        checkbox.addEventListener("click", () => checkbox.checked = !checkbox.checked)

                        button.left.style.display = "flex"
                        button.left.style.alignItems = "center"
                        button.left.style.width = "233px"
                        button.left.append(locationList.funnel.name)
                        button.right.textContent = `${locationList.funnel.price} €`
                        button.right.style.fontSize = "34px"
                        if (locationList.funnel.unit !== undefined) {
                          button.right.textContent = `${locationList.funnel.price} ${locationList.funnel.unit}`
                        }

                        button.onclick = () => {
                          this.remove("node/sign", serviceSelect)
                          checkbox.checked = !checkbox.checked

                          const service = {}
                          service.name = locationList.funnel.name
                          service.price = locationList.funnel.price

                          companyName.textContent = user[`${window.location.pathname.split("/")[2]}.company.name`]

                          if (checkbox.checked === true) {
                            selectedServices.push(service)
                          }

                          if (checkbox.checked === false) {
                            const index = selectedServices.findIndex(it => it.name === service.name)
                            if (index !== -1) {
                              selectedServices.splice(index, 1)
                            }
                          }

                          const sum = selectedServices.reduce((accumulator, current) => {
                            return accumulator + Number(current.price)
                          }, 0)

                          singlePrice.textContent = `${sum.toFixed(2).replace(".", ",")} `
                          totalPrice.textContent = `${sum.toFixed(2).replace(".", ",")} `
                          quantityInput.value = 1

                          if (locationList.funnel.unit !== undefined) {
                            serviceUnit.textContent = locationList.funnel.unit
                          }

                        }


                      }

                    })
                  }

                }

              }

              if (res.status !== 200) {
                this.convert("parent/info", buttons)
                buttons.textContent = `Keine ${this.convert("text/capital-first-letter", selected)} gefunden.`
              }

            })
          }

          const res = await this.request("/get/user/trees-open/", {trees: ["getyour.expert.platforms"]})
          if (res.status === 200) {
            const users = JSON.parse(res.response)
            for (let i = 0; i < users.length; i++) {
              const user = users[i]
              if (user["getyour.expert.platforms"] !== undefined) {
                for (let i = 0; i < user["getyour.expert.platforms"].length; i++) {
                  const platform = user["getyour.expert.platforms"][i]
                  if (platform.name === window.location.pathname.split("/")[2]) {
                    if (platform.roles !== undefined) {
                      serviceSelect.textContent = ""
                      for (let i = 0; i < platform.roles.length; i++) {
                        const role = platform.roles[i]
                        const option = document.createElement("option")
                        option.text = this.convert("text/capital-first-letter", role.name)
                        option.value = role.name
                        serviceSelect.append(option)
                      }
                    }
                  }
                }
              }
            }
          }

          quantityInput.oninput = (ev) => {
            const totalPrice = document.querySelector("span.total-price")
            const singlePrice = document.querySelector("span.single-price")
            totalPrice.textContent = `${(Number(singlePrice.textContent.replace(",", ".")) * ev.target.value).toFixed(2).replace(".", ",")} `
          }

          const addService = document.querySelector("div.add-service")
          addService.style.cursor = "pointer"
          addService.onclick = () => {

            if (selectedServices === undefined || selectedServices.length === 0) {
              window.alert("Es wurde keine Leistung ausgewählt.")
              this.add("style/not-valid", serviceSelect)
            }

            if (selectedServices !== undefined && selectedServices.length > 0) {
              const serviceOptions = document.querySelector("div.service-options")
              const serviceBox = this.create("div/service-box", serviceOptions)
              serviceBox.checkbox.checked = true
              serviceBox.quantity.textContent = document.querySelector("input.quantity").value
              const company = document.createElement("p")
              company.style.fontWeight = "bold"
              company.textContent = document.querySelector("div.company-name").textContent
              serviceBox.service.appendChild(company)
              for (let i = 0; i < selectedServices.length; i++) {
                const service = selectedServices[i]
                const serviceDiv = document.createElement("div")
                serviceDiv.textContent = service.name
                serviceBox.service.append(serviceDiv)
              }
              serviceBox.singlePrice.textContent = document.querySelector("div.single-price").textContent
              serviceBox.totalPrice.textContent = document.querySelector("div.total-price").textContent
            }

          }

        } catch (error) {
          reject(error)
        }
      })


    }

    if (event === "event/role-apps") {

      const button = document.querySelector(".role-apps-button")

      if (button !== null) {

        button.onclick = async () => {

          this.overlay("toolbox", overlay => {
            this.removeOverlayButton(overlay)
            const info = this.create("header/info", overlay)
            info.append(this.convert("text/span", input.tag))

            this.get("role-apps/closed", overlay, input.id)

          })

        }

      }

    }

    if (event === "location-list-funnel") {

      const button = document.getElementById(`${input.tag}-location-list-button`)

      if (button !== null) {
        button.onclick = () => {

          this.overlay("toolbox", async overlay => {

            this.removeOverlayButton(overlay)
            const info = this.create("header/info", overlay)
            info.textContent = "." + input.tag

            const create = this.create("button/left-right", overlay)
            create.left.textContent = ".create"
            create.right.textContent = this.convert("text/capital-first-letter", input.tag) + " definieren"
            create.addEventListener("click", () => {

              this.overlay("toolbox", async overlay => {
                this.removeOverlayButton(overlay)
                const info = this.create("header/info", overlay)
                info.append(this.convert("text/span", input.tag + ".create"))

                const content = this.create("div/scrollable", overlay)
                const fieldFunnel = await this.convert("path/field-funnel", input.path)
                content.append(fieldFunnel)

                this.verifyIs("field-funnel/valid", fieldFunnel)

                const submitButton = fieldFunnel.querySelector(".submit-field-funnel-button")

                if (submitButton) {

                  submitButton.textContent = `${this.convert("text/capital-first-letter", input.tag)} jetzt speichern`
                  submitButton.onclick = async () => {

                    await this.verify("field-funnel", fieldFunnel)

                    const map = await this.convert("field-funnel/map", fieldFunnel)

                    this.overlay("security", async securityOverlay => {

                      const register = {}
                      register.tag = input.tag
                      register.map = map
                      const res = await this.request("register/location/list-self/", register)

                      if (res.status === 200) {
                        window.alert("Daten erfolgreich gespeichert.")

                        const res = await this.request("/get/location/tag-self/", {tag: input.tag})
                        if (res.status === 200) {
                          const tag = JSON.parse(res.response)
                          this.render("location-list/node/closed", {list: tag[input.tag], tag: input.tag, path: input.path}, locationList)
                        }
                        if (res.status !== 200) {
                          this.convert("parent/info", locationList)
                          locationList.textContent = `Keine ${this.convert("text/capital-first-letter", input.tag)} gefunden`
                        }
                        securityOverlay.remove()
                      }

                      if (res.status !== 200) {
                        window.alert("Fehler.. Bitte wiederholen.")
                        securityOverlay.remove()
                      }

                    })

                  }

                } else {
                  window.alert("Field Funnel besitzt keinen Button mit der Klasse 'submit-field-funnel-button'")
                }


              })

            })

            this.render("text/hr", "Meine " + this.convert("text/capital-first-letter", input.tag), overlay)

            const locationList = this.create("info/loading", overlay)
            const res = await this.request("/get/location/tag-self/", {tag: input.tag})
            if (res.status === 200) {
              const tag = JSON.parse(res.response)
              this.render("location-list/node/closed", {list: tag[input.tag], tag: input.tag, path: input.path}, locationList)
            }
            if (res.status !== 200) {
              this.convert("parent/info", locationList)
              locationList.textContent = `Keine ${this.comvert("text/capital-first-letter", input.tag)} gefunden`
            }

          })

        }
      }

    }

    if (event === "prefill-field-funnel") {

      return new Promise(async(resolve, reject) => {
        try {
          for (let i = 0; i < document.querySelectorAll(".field-funnel").length; i++) {
            const funnel = document.querySelectorAll(".field-funnel")[i]
            const res = await this.request("/get/user/location-list-closed/", {platform: window.location.pathname.split("/")[2], id: funnel.id})
            if (res.status === 200) {
              const map = JSON.parse(res.response)
              this.render("map/field-funnel", map, funnel)
            }
          }
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "submit-field-funnel") {

      document.querySelectorAll(".field-funnel").forEach(funnel => {
        this.add("outline-hover/field-funnel", funnel)
        const submitButton = funnel.querySelector(".submit-field-funnel-button")
        if (submitButton !== null) {
          if (submitButton.onclick === null) {
            submitButton.onclick = async () => {
              if (this.verifyIs("tag/empty", funnel.id)) {
                window.alert("Funnel ist nicht gültig: id ist kein tag")
                throw new Error("funnel tag is empty")
              }
              const map = await this.convert("field-funnel/map", funnel)
              if (map !== undefined) {
                this.overlay("security", async securityOverlay => {
                  const res = await this.request("/register/location/list-self/", {tag: funnel.id, map})
                  if (res.status === 200) {
                    window.alert("Daten wurden erfolgreich gespeichert.")
                    if (funnel.hasAttribute("next-path")) {
                      window.location.assign(funnel.getAttribute("next-path"))
                    }
                    securityOverlay.remove()
                  } else {
                    window.alert("Fehler.. Bitte wiederholen.")
                    securityOverlay.remove()
                  }
                })
              }
            }
          }
        }
      })
    }

    if (event === "on-info-click") {

      document.querySelectorAll(".field").forEach(field => {
        if (field.hasAttribute("on-info-click")) {
          this.convert("field/on-info-click", field)
        }
      })
    }

    if (event === "open-profiles") {

      const searchField = Helper.create("input/text", document.body)
      this.add("style/valid", searchField.input)
      searchField.input.placeholder = "Suche nach Schlüsselwörter"
      this.request("/get/user/profiles-open/").then(res => {
        if (res.status === 200) {
          const profiles = JSON.parse(res.response)
          const csvParts = []
          for (let i = 0; i < profiles.length; i++) {
            const profile = profiles[i]
            profile.csv = ""
            for (const [key, value] of Object.entries(profile)) {
              if (key === "created" || key === "visibility" || key === "messages" || key === "weakness") continue
              if (!this.verifyIs("text/empty", value)) {
                csvParts.push(value)
              }
            }
            profile.csv = csvParts.join(", ")
          }

          searchField.input.oninput = (ev) => {
            const userInput = ev.target.value.toLowerCase()

            if (this.verifyIs("text/empty", userInput)) {
              this.render("open-profiles", profiles, profilesDiv)
              return
            }

            const filtered = profiles.filter(it => it.csv.toLowerCase().includes(userInput))
            const highlighted = filtered.map(it => {

              const highlightedProfile = {}
              const escapedTerm = userInput.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')

              for (const [key, value] of Object.entries(it)) {
                if (typeof value === 'string') {
                  const highlightedValue = value.replace(new RegExp(escapedTerm, 'gi'), match => `<mark>${match}</mark>`)
                  highlightedProfile[key] = highlightedValue
                } else {
                  highlightedProfile[key] = value
                }
              }

              return highlightedProfile
            })
            this.render("open-profiles", highlighted, profilesDiv)
          }
          this.render("open-profiles", profiles, profilesDiv)
        } else {
          this.convert("parent/info", profilesDiv)
          profilesDiv.textContent = `Es wurden keine Profile gefunden.`
        }
      })
      const profilesDiv = Helper.render("selector", "div.profiles", document.body)
    }

    if (event === "event/dbltouch") {
      let lastTapTime = 0

      input.node.addEventListener("touchend", ev => {
        const currentTime = new Date().getTime()
        const timeDifference = currentTime - lastTapTime

        if (timeDifference < 300 && timeDifference > 0) {
          input.callback(ev)
        }

        lastTapTime = currentTime
      })
    }

    if (event === "field-funnel-sign-support") {

      document.querySelectorAll(".field-funnel").forEach(funnel => {
        this.verifyIs("field-funnel/valid", funnel)
      })

      document.querySelectorAll(".field-funnel").forEach(funnel => {
        funnel.querySelectorAll(".field").forEach(field => {
          const input = field.querySelector(".field-input")
          input.addEventListener("input", () => this.verify("input/value", input))
        })
      })

    }

    if (event === "event/soundbox") {

      return new Promise(async(resolve, reject) => {
        try {

          const fileImport = document.querySelector("[soundbox-file-import]")
          fileImport.oninput = async () => {

            const promises = []
            for (let i = 0; i < fileImport.files.length; i++) {
              const file = fileImport.files[i]
              const promise = this.verifyIs("file/mp3", file)
              promises.push(promise)
            }

            const results = await Promise.all(promises)

            if (results.every(result => result === true)) {
              this.add("style/valid", fileImport)

              this.overlay("security", async securityOverlay => {

                const progress = this.create("div/progress-bar", securityOverlay)

                for (var i = 0; i < fileImport.files.length; i++) {
                  const file = fileImport.files[i]

                  // nginx file too large error
                  // mit salih klären todo

                  await new Promise(async(resolve, reject) => {
                    const formdata = new FormData()
                    formdata.append('mp3-file', file)

                    const res = await fetch('/upload/mp3-file/self/', {
                      method: 'POST',
                      body: formdata,
                    })

                    if (res.status === 200) {

                      progress.bar.style.backgroundColor = '#4CAF50'
                      progress.bar.style.width = ((i + 1) / fileImport.files.length) * 100 + '%'

                      resolve()
                    }


                    if (res.status !== 200) {

                      progress.bar.style.backgroundColor = '#FF5733'
                      progress.bar.style.width = ((i + 1) / fileImport.files.length) * 100 + '%'

                      resolve()
                    }

                  })

                }

                window.alert("Sound erfolgreich gespeichert.")
                securityOverlay.remove()

              })

            } else {
              window.alert("Nicht alle Uploads sind mp3 Dateien.")
              console.error("Not all files are mp3")
              this.add("style/not-valid", fileImport)
            }


          }

          const audioList = document.querySelector("[soundbox-audio-list]")
          if (audioList !== null) {

            const res = await this.request("/get/sounds/cids-self/")

            if (res.status === 200) {
              const sounds = JSON.parse(res.response)

              for (let i = 0; i < sounds.length; i++) {
                const sound = sounds[i]

                const audioField = this.create("field/audio", audioList)
                audioField.audio.id = sound.created
                audioField.audio.src = `https://ipfs.io/ipfs/${sound.cid}/`

                const track = document.createElement("div")
                track.classList.add("track")
                track.textContent = sound.track
                audioField.label.append(track)

                const creator = document.createElement("div")
                creator.classList.add("creator")
                creator.textContent = `${sound.creator} - ${sound.album}`
                audioField.label.append(creator)

                const played = document.createElement("div")
                played.classList.add("played")

                if (sound.played) {
                  played.textContent = sound.played
                } else {
                  played.textContent = "0"
                }

                played.style.position = "absolute"
                played.style.top = "0"
                played.style.right = "0"
                played.style.margin = "21px 34px 0 0"
                audioField.label.append(played)

                const reloadTimeout = setTimeout(audioField.audio.load(), 3000)
                audioField.audio.addEventListener("canplay", () => {
                  clearTimeout(reloadTimeout)
                })
                audioField.audio.addEventListener("error", () => {
                  audioField.remove()
                })

                audioField.label.style.cursor = "pointer"
                audioField.label.addEventListener("click", () => {
                  console.log(audioField.audio.id)

                  this.overlay("toolbox", overlay => {
                    this.removeOverlayButton(overlay)

                    const funnel = this.create("div/scrollable", overlay)

                    const trackField = this.create("field/textarea", funnel)
                    trackField.label.textContent = "Track"
                    trackField.input.style.fontSize = "13px"
                    trackField.input.setAttribute("required", "true")
                    if (sound.track) trackField.input.value = sound.track
                    trackField.input.oninput = () => this.verify("input/value", trackField.input)
                    this.verify("input/value", trackField.input)

                    const creatorField = this.create("field/textarea", funnel)
                    creatorField.label.textContent = "Schöpfer"
                    creatorField.input.style.fontSize = "13px"
                    creatorField.input.setAttribute("required", "true")
                    if (sound.creator) creatorField.input.value = sound.creator
                    creatorField.input.oninput = () => this.verify("input/value", creatorField.input)
                    this.verify("input/value", creatorField.input)

                    const albumField = this.create("field/textarea", funnel)
                    albumField.label.textContent = "Album"
                    albumField.input.style.fontSize = "13px"
                    albumField.input.setAttribute("required", "true")
                    if (sound.album) albumField.input.value = sound.album
                    albumField.input.oninput = () => this.verify("input/value", albumField.input)
                    this.verify("input/value", albumField.input)

                    const submit = this.create("button/action", funnel)
                    submit.textContent = "Daten jetzt speichern"
                    submit.onclick = async () => {
                      await this.verify("input/value", trackField.input)
                      await this.verify("input/value", creatorField.input)
                      await this.verify("input/value", albumField.input)

                      this.overlay("security", async securityOverlay => {

                        const register = {}
                        register.id = audioField.audio.id
                        register.track = trackField.input.value
                        register.creator = creatorField.input.value
                        register.album = albumField.input.value
                        const res = await this.request("/register/sounds/meta-self/", register)

                        if (res.status === 200) {
                          window.alert("Metadaten erfolgreich gespeichert.")
                          window.location.reload()
                        }

                        if (res.status !== 200) {
                          window.alert("Fehler.. Bitte wiederholen.")
                          securityOverlay.remove()
                        }
                      })

                    }




                  })

                })

                audioField.audio.addEventListener("ended", () => {
                  this.request("/register/sounds/played/", audioField.audio.id, "beacon").then(res => {
                    if (res.status === 200) {
                      played.textContent = parseInt(played.textContent) + 1
                    }
                  })

                })


              }



            }

          }

        } catch (error) {
          reject(error)
        }
      })

    }

    if (event === "register-html") {

      this.overlay("security", async securityOverlay => {

        // prepare html state
        this.remove("element/selector", {element: document, selector: "[data-id]"})
        this.remove("element/selector", {element: document, selector: "#toolbox"})
        this.remove("element/selector", {element: document, selector: ".overlay"})
        const html = document.documentElement.outerHTML.replace(/<html>/, "<!DOCTYPE html><html>")

        const successMessage = "Dokument erfolgreich gespeichert. +1 XP"

        // save html state
        const res = await this.request("/register/platform/value-html-location-expert/", {html})
        if (res.status === 200) {
          window.alert(successMessage)
          window.location.reload()
        }

        if (res.status !== 200) {

          const res = await this.request("/register/platform/value-html-writable/", {html})
          if (res.status === 200) {
            window.alert(successMessage)
            window.location.reload()
          }

          if (res.status !== 200) {

            window.alert("Fehler.. Bitte wiederholen.")
            await this.add("toolbox/onbody")
            securityOverlay.remove()

          }

        }

      })

    }

    if (event === "lazy-loading") {

      const observer = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            input.src = input.dataset.src
            observer.unobserve(entry.target)
          }
        })
      }, { threshold: 0 })
      observer.observe(input)
    }

    if (event === "closed-creator") {

      return new Promise(async(resolve, reject) => {
        try {

          let button = document.querySelector(`.${event}`)
          if (!button) {
            button = this.create("button/bottom-right", document.body)
            button.classList.add(event)
            const icon = await this.convert("path/icon", "/public/pencil-ruler.svg")
            button.appendChild(icon)
          }
          this.add("outline-hover", button)
          button.onclick = () => {
            this.overlay("tools", {type: "closed"})
          }
          resolve()
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "html-feedback") {

      const feedback = this.fn("feedback")
      feedback.bodyButton()
    }

    if (event === "event/click-funnel") {

      document.querySelectorAll(".click-funnel").forEach(funnel => {

        const startButton = funnel.querySelector(".start-click-funnel-button")

        if (startButton.onclick === null) {
          startButton.onclick = () => {

            startButton.style.display = "none"

            const questions = []
            for (let i = 0; i < funnel.children.length; i++) {
              const child = funnel.children[i]
              if (child.classList.contains("click-field")) {
                questions.push(child)
                child.style.display = "flex"
                break
              }
            }

            if (questions.length <= 0) {
              this.add("click-funnel/end", funnel)
              return
            }
          }
        }

        for (let i = 0; i < funnel.children.length; i++) {
          const child = funnel.children[i]

          if (child.classList.contains("click-field")) {

            child.querySelectorAll(".answer-box").forEach(box => {

              if (box.onclick === null) {

                box.onclick = () => {

                  child.style.display = "none"

                  box.querySelectorAll(".answer").forEach(answer => {
                    answer.setAttribute("clicked", true)
                  })

                  if (child.nextSibling === null) {

                    this.add("click-funnel/end", funnel)

                    return

                  }

                  if (box.hasAttribute("onclick-condition")) {
                    const condition = JSON.parse(box.getAttribute("onclick-condition"))

                    if (condition.action === "skip") {
                      try {
                        this.skipSiblings(parseInt(condition.skip) + 1, child)

                        return
                      } catch (error) {

                        this.add("click-funnel/end", funnel)

                        return

                      }
                    }

                    if (condition.action === "path") {
                      window.location.assign(condition.path)
                      return
                    }

                  }

                  child.nextSibling.style.display = "flex"

                }

              }



            })

          }

        }

      })

    }

    if (event === "open-creator") {

      return new Promise(async(resolve, reject) => {
        try {
          let button = document.querySelector(`.${event}`)
          if (!button) {
            button = this.create("button/bottom-right", document.body)
            button.classList.add(event)
            const icon = await this.convert("path/icon", "/public/pencil-ruler.svg")
            button.appendChild(icon)
          }
          this.add("outline-hover", button)
          button.onclick = () => {
            this.overlay("tools")
          }
          resolve()
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "underline-hover/node") {
      input.addEventListener("mouseover", () => {
        input.style.textDecoration = "underline"
      })

      input.addEventListener("mouseout", () => {
        input.style.textDecoration = null
      })
    }

    if (event === "user-profile-button") {

      this.create("add-button", input)
      document.querySelector("div.add.button").onclick = () => {
        this.overlay("popup", overlay => {
          overlay.onlyClosedUser()
          const content = this.create("div/scrollable", overlay)
          const funnel = this.create("funnel/profile", content)

          funnel.submit.onclick = async () => {
            await this.verify("funnel", funnel)
            this.overlay("security", async securityOverlay => {
              const res = await Helper.request("/register/user/profile/", {aboutYou: funnel.aboutYou.input.value, whyThis: funnel.whyThis.input.value, whyYou: funnel.whyYou.input.value, strength: funnel.strength.input.value, weakness: funnel.weakness.input.value, motivation: funnel.motivation.input.value, visibility: funnel.visibility.input.value})
              if (res.status === 200) {
                window.alert("Deine Daten wurden erfolgreich gespeichert.")
                window.location.reload()
              } else {
                window.alert("Fehler.. Bitte wiederholen.")
                securityOverlay.remove()
              }
            })

          }
        })
      }
    }

    if (event === "click-funnel/end") {

      const endButton = input.querySelector(".end-click-funnel-button")
      const buttonIcon = endButton.children[0]
      const buttonText = endButton.children[1]

      if (endButton.onclick === null) {

        endButton.onclick = () => {

          const funnelTag = input.id

          if (!this.verifyIs("text/tag", funnelTag)) {
            window.alert("Funnel Id ist ungültig.")
            throw new Error("id not a tag")
          }

          const map = {}
          input.querySelectorAll(".click-field").forEach(field => {
            field.querySelectorAll(".answer").forEach(answer => {
              if (answer.getAttribute("clicked") === "true") {
                map[field.id] = answer.textContent
              }
            })
          })

          this.overlay("toolbox", async securityOverlay => {
            this.create("info/loading", securityOverlay)

            const res = await this.request("/register/location/list-self/", {tag: funnelTag, map})

            if (res.status === 200) {

              buttonIcon.textContent = ""
              this.render("icon/node/path", "/public/check-animated.svg", buttonIcon)
              buttonText.textContent = "Erfolgreich"

              endButton.onclick = () => window.location.reload()

              window.alert("Ihre Daten wurden erfolgreich gespeichert.")

              if (input.hasAttribute("next-path")) {
                window.location.assign(input.getAttribute("next-path"))
              }

              securityOverlay.remove()


            } else {
              window.alert("Fehler.. Bitte wiederholen.")

              buttonIcon.textContent = ""
              this.render("icon/node/path", "/public/exclamation-triangle.svg", buttonIcon)
              buttonText.textContent = "Fehler"

              endButton.onclick = () => window.location.reload()

              securityOverlay.remove()
            }
          })


        }

      }

      endButton.style.display = "flex"

    }

    if (event === "icon/touch") {
      this.render("icon/node/path", "/public/touch.svg").then(icon => {
        icon.classList.add("touch")
        icon.style.marginLeft = "21px"
        input?.querySelectorAll(".icon.touch").forEach(it => it.remove())
        input?.append(icon)
      })
    }

    if (event === "id-onbody") {
      const node = document.getElementById(input.id)
      if (!node) {
        document.body.appendChild(input)
        window.alert("Element wurde erfolgreich anhgehängt.")
      } else {
        window.alert("Element existiert bereits.")
      }
    }

    if (event === "onbody") {

      document.body.appendChild(input)
    }

    if (event === "onbody-once") {

      if (input.id) document.querySelectorAll(`#${input.id}`).forEach(node => node.remove())
      document.body.appendChild(input)
    }

    if (event === "onmouseout") {

      const onmouseout = input.node.getAttribute("onmouseout")
      input.node.setAttribute("onmouseout", `${onmouseout}; ${input.type}`)
    }

    if (event === "onmouseover") {

      const onmouseover = input.node.getAttribute("onmouseover")
      input.node.setAttribute("onmouseover", `${onmouseover}; ${input.type}`)
    }

    if (event === "profile-surveys") {
      // umfragen können auch direkt im html gemacht werden mit dem field funnel
      // oder dem click funnel
      // hol dir die platform.profile.surveys
      // vom url id param 4
      // wenn eins existiert
      return new Promise(async(resolve, reject) => {
        try {

          // console.log("nhi");




          const profileSurveysDiv = document.querySelector("div.profile-surveys")
          // console.log(profileSurveysDiv);

          // check profile path of location
          // if id is not undefined
          // then give the url id closed jwt.id

          if (profileSurveysDiv) {


            // always create overlays


            const res = await this.request("/get/platform/surveys/", {path: window.location.pathname})
            // console.log(id);
            console.log(res);
            if (res.status === 200) {

              // get alle umfragen von der id in der url

              // alle umfragen anzeigen all user.platform.surveys
              // meine umfragen anzeigen closed user.platform.surveys
              // seine umfragen anzeigen url id = jwt.id user.platform.surveys
              // wie so tabs

              // todo umfragen
              // umfrage erstellen button
              // nur wenn der user closed ist und er die selbe jwt.id hat wie in der url
              // umfrage boxen
              // umfragen löschen
              // umfragen ergebnisse anzeigen
              // empfehlungen geben

            } else {
              profileSurveysDiv.textContent = "Es wurden keine Umfragen gefunden."

            }



            // if the user is closed jwt and url id the same
            // then provide a button to create new surveys
            const res1 = await this.request("/verify/user/url-id/")
            if (res1.status === 200) {
              // do something with profileSurveyDiv
              // create a button where an overlay comes
              // and the the overlay can create new surveys


              // add edit icon to node

              // this.create("icon/edit", profileSurveysDiv)


              profileSurveysDiv.parentElement.style.position = "relative"
              const editIcon = document.createElement('div')
              editIcon.className = 'edit-icon'
              this.style(editIcon, {width: "55px", margin: "13px", alignItems: "center", justifyContent: "center", display: "flex", borderRadius: "50%", fontSize: "34px", position: "absolute", top: "0", right: "0"})
              editIcon.innerHTML = '&#9998;'
              this.add("outline-hover", editIcon)
              profileSurveysDiv.parentElement.appendChild(editIcon)




              editIcon.onclick = () => {
                this.overlay("popup", overlay => {
                  overlay.info.textContent = ".surveys"

                  const addButton = this.create("toolbox/add", overlay)
                  addButton.onclick = () => {
                    // funnel to create a survey
                    // ist eigentlich wie funnel um ein funnel zu erstellen
                    // div.survey

                    // function update answersContainer



                    this.overlay("popup", createSurveyOverlay => {
                      const surveyFunnel = this.create("div/scrollable", createSurveyOverlay)
                      const questionField = this.create("input/textarea", surveyFunnel)
                      questionField.input.setAttribute("required", "true")
                      questionField.input.placeholder = "Frage"
                      questionField.input.maxLength = "144"
                      questionField.input.oninput = () => this.verify("input/value", questionField.input)
                      this.verify("input/value", questionField.input)
                      // question is einzigartig
                      // kann nicht mehr geändert werden
                      // muss gelöscht und neu gemacht werden
                      // frage bearbeiten ???
                      // dann stimmt die frage zu den antworrten nicht mehr
                      // this.add("oninput/verify-input", questionField.input)
                      const typeField = this.create("input/select", surveyFunnel)
                      // typeField.input.
                      this.add("select-options", {select: typeField.input, options: ["Freitext", "Multiple Choice", "Geschlossen", "Bewertung", "Skala"]})

                      // ON INPUT CHANGE THE ANSWERS FIELD

                      const answerContainer = this.create("div", surveyFunnel)

                      const submit = this.create("toolbox/action", surveyFunnel)
                      submit.textContent = "Umfrage jetzt speichern"
                      submit.onclick = async () => {
                        // check the input
                        await this.verify("input/value", questionField.input)
                        console.log(this.convert("text/tag", questionField.input.value));

                        return

                        this.overlay("security", async securityOverlay => {
                          const res = await this.request("/register/survey/closed/", {})
                        })
                      }




                    })
                  }

                  // .create
                  // rechts unten ein button

                  // show and edit own surveys
                })
              }




            }











          }






          // const id = window.location.pathname.split("/")[4]
          // if (!this.verifyIs("text/empty", id)) {
          // } else {
          // }


        } catch (error) {
          reject(error)
        }
      })



    }

    if (event === "recorder") {

      let mediaRecorder
      let chunks = []
      let timerInterval
      let seconds = 0
      const fragment = document.createDocumentFragment()
      const controls = Helper.create("div", fragment)
      controls.className = "controls"
      controls.timer = Helper.render("text/link", "Aufnahmezeit: 0s", controls)
      controls.pause = Helper.render("text/link", "Pause", controls)
      controls.stop = Helper.render("text/link", "Stop", controls)
      controls.pause.onclick = pause
      controls.stop.onclick = stop
      if (!document.querySelector("div.controls")) input?.node?.appendChild(fragment)
      function pause() {

        if (mediaRecorder.state === 'recording') {
          mediaRecorder.pause()
          clearInterval(timerInterval)
          Helper.add("style/green", controls.pause)
          return
        }
        if (mediaRecorder.state === 'paused') {
          mediaRecorder.resume()
          timerInterval = setInterval(updateTimer, 1000)
          Helper.add("style/dark-light", controls.pause)
          return
        }
      }
      function stop() {

        mediaRecorder.stop()
      }
      async function start(stream, o) {

        if (["audio"].includes(input.type)) {
          const oscillator = Helper.add("oscillator", {stream})
          oscillator.draw(o)
        }
        mediaRecorder = new MediaRecorder(stream)
        chunks = []
        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            chunks.push(event.data)
          }
        }
        mediaRecorder.onstop = async () => {

          clearInterval(timerInterval)
          const file = new File(chunks, { type: input.type })
          const a = document.createElement("a")
          const hash = await Helper.digest(file)
          const url = URL.createObjectURL(file)
          a.href = url
          a.download = `${hash}.${Helper.convert("type/extension", input.type)}`
          document.body.appendChild(a)
          a.click()
          setTimeout(() => {
            document.body.removeChild(a)
            URL.revokeObjectURL(url)
            stream.getTracks().forEach(track => track.stop())
            controls.remove()
            o.remove()
          }, 100)
        }
        mediaRecorder.start()
        o.appendChild(controls)
        timerInterval = setInterval(updateTimer, 1000)
        Helper.add("style/red", controls.timer)
      }
      function updateTimer() {
        seconds++
        controls.timer.textContent = `Aufnahmezeit: ${seconds}s`
      }
      return {controls, pause, start, stop}
    }

    if (event === "role-login") {

      const submit = document.querySelector(".start-login-event")
      const emailInput = document.querySelector(".email-input")
      const dsgvoInput = document.querySelector(".dsgvo-input")
      const emailField = emailInput.closest(".field")
      const dsgvoField = dsgvoInput.closest(".field")
      this.convert("dark-light", emailField)
      this.convert("dark-light", dsgvoField)
      this.verify("input/value", emailInput)
      this.verify("input/value", dsgvoInput)

      if (window.localStorage.getItem("email") !== null) {
        emailInput.value = window.localStorage.getItem("email")
        this.verify("input/value", emailInput)
      }

      this.add("oninput/verify-input", emailInput)
      this.add("oninput/verify-input", dsgvoInput)
      this.add("outline-hover", emailInput)
      this.add("outline-hover", submit)
      for (let i = 0; i < dsgvoField.querySelectorAll(".button").length; i++) {
        const child = dsgvoField.querySelectorAll(".button")[i]
        this.add("outline-hover", child)
      }
      submit.onclick = async () => {
        await this.verify("input/value", emailInput)
        await this.verify("input/value", dsgvoInput)
        await this.callback("email/pin-verified", emailInput.value, async () => {
          const res = await this.request("/register/email/location/", {id: input.id, email: emailInput.value, name: input.name})
          {
            const res = await this.request("/register/session/")
            if (res.status === 200) {
              const res = await this.request("/redirect/user/closed/")
              if (res.status === 200) window.location.assign(res.response)
            } else {
              window.history.back()
            }
          }
        })
      }
    }

    if (event === "script/click-funnel-event") {

      const script = this.create(event)

      if (input !== undefined) {
        document.querySelectorAll(`#${script.id}`).forEach(script => script.remove())
        input.append(script)
      }

      return script

    }

    if (event === "script/toolbox-getter") {

      return new Promise(async(resolve) => {
        const script = document.createElement("script")
        script.id = "toolbox-getter"
        script.type = "module"
        script.textContent = 'import {Helper} from "/js/Helper.js"\nawait Helper.add("toolbox/onbody")'
        if (document.body) {
          document.querySelectorAll("#toolbox-getter").forEach(getter => getter.remove())
          document.body.appendChild(script)
          resolve(script)
        } else {
          await this.add("ms/timeout", 3000)
          await this.add("script/toolbox-getter")
        }
      })
    }

    if (event === "script-onbody") {

      const exist = document.getElementById(input.id)
      if (exist) {
        exist.remove()
      }
      document.body.appendChild(input)
    }

    if (event === "session-login") {

      this.convert("dark-light", input)
      const backButton = document.querySelector("div.button.back")
      this.convert("dark-light", backButton)
      const startButton = document.querySelector("div.button.start")
      this.add("outline-hover", startButton)
      this.convert("dark-light", startButton)
      startButton.onclick = () => {
        this.overlay("popup", overlay => {
          const content = this.create("div/scrollable", overlay)
          this.render("nav/open", content)
        })
      }
      const mailtoInfo = document.querySelector("a[href='mailto:datenschutz@get-your.de']")
      this.add("outline-hover", mailtoInfo)
      const emailInput = document.querySelector("input.email-input")
      const dsgvoInput = document.querySelector("input.dsgvo-input")
      this.verify("input/value", dsgvoInput)
      this.add("oninput/verify-input", emailInput)
      this.add("oninput/verify-input", dsgvoInput)
      this.add("outline-hover", emailInput)
      if (window.localStorage.getItem("email") !== null) {
        emailInput.value = window.localStorage.getItem("email")
      }
      this.verify("input/value", emailInput)
      const submit = document.querySelector(".session-login-submit")
      this.add("outline-hover", submit)
      submit.onclick = async () => {
        await this.verify("input/value", emailInput)
        await this.verify("input/value", dsgvoInput)
        this.callback("email/pin-verified", emailInput.value, async () => {
          const res = await this.request("/register/session/")
          if (res.status === 200) {
            const res = await this.request("/redirect/user/closed/")
            if (res.status === 200) {
              window.location.assign(res.response)
            } else if (!Helper.verifyIs("text/empty", document.referrer)) {
              window.location.assign(document.referrer)
            } else {
              window.history.back()
            }
          } else {
            window.history.back()
          }
        })
      }
      for (let i = 0; i < document.links.length; i++) {
        const link = document.links[i]
        this.convert("link-colors", link)
      }
      document.querySelectorAll("a.button").forEach(button => this.add("outline-hover", button))
    }

    if (event === "signs") {

      input.querySelectorAll("input, select, textarea").forEach(node => {
        console.log(node);
        this.verify("input/value", node)
        // this.addd("style/not-valid", node)
      })
    }

    if (event === "stream/cam") {

      return new Promise(async(resolve, reject) => {
        try {
          const {deviceId, video} = input
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { deviceId: { exact: deviceId } }
          })
          video.srcObject = stream
          resolve(stream)
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "stream/vid") {

      return new Promise(async(resolve, reject) => {
        try {
          const {deviceId, video} = input
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { deviceId: { exact: deviceId } },
            audio: true
          })
          video.srcObject = stream
          resolve(stream)
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "style/dark") {

      input.style.color = this.colors.dark.text
      input.style.background = this.colors.dark.background
      return input
    }

    if (event === "style/dark-light") {

      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        this.add("style/dark", input)
      } else {
        this.add("style/light", input)
      }
    }

    if (event === "style/not-valid") {

      const color = this.colors.light.error
      input.style.border = `2px solid ${color}`
      if (input.type === "checkbox") {
        input.style.outline = `2px solid ${color}`
      }
      const signs = input.parentNode.querySelectorAll("div[class='sign']")
      signs.forEach(sign => sign.remove())
      if (signs.length === 0) {
        const sign = document.createElement("div")
        sign.classList.add("sign")
        sign.textContent = "x"
        sign.style.position = "absolute"
        sign.style.right = "0"
        sign.style.top = "-5px"
        sign.style.color = color
        sign.style.fontSize = "34px"
        sign.style.fontFamily = "sans-serif"
        input.parentNode.append(sign)
        return input
      }
      if (signs.length > 0) {
        const sign = document.createElement("div")
        sign.classList.add("sign")
        sign.textContent = "x"
        sign.style.position = "absolute"
        sign.style.right = "0"
        sign.style.top = "-5px"
        sign.style.color = color
        sign.style.fontSize = "34px"
        sign.style.fontFamily = "sans-serif"
        input.parentNode.append(sign)
        return input
      }
      return input
    }

    if (event === "style/selected") {

      this.add("style/circle", input)
      this.add("style/green", input)
    }

    if (event === "style/valid") {
      input.style.border = "2px solid #00c853"
      if (input.type === "checkbox") {
        input.style.outline = "2px solid #00c853"
      }
      input.style.borderRadius = "3px"
      const signs = input.parentNode.querySelectorAll("div[class='sign']")
      if (signs.length === 0) {
        const sign = document.createElement("div")
        sign.classList.add("sign")

        sign.textContent = "✓"
        sign.style.position = "absolute"
        sign.style.right = "0"
        sign.style.top = "-5px"
        sign.style.color = "#00c853"
        sign.style.fontSize = "34px"
        sign.style.fontFamily = "sans-serif"
        input.parentNode.append(sign)
        return input
      }
      if (signs.length > 0) {
        signs.forEach(sign => sign.remove())
        const sign = document.createElement("div")
        sign.classList.add("sign")

        sign.textContent = "✓"
        sign.style.position = "absolute"
        sign.style.right = "0"
        sign.style.top = "-5px"
        sign.style.color = "#00c853"
        sign.style.fontSize = "34px"
        sign.style.fontFamily = "sans-serif"
        input.parentNode.append(sign)
        return input
      }
      return input
    }

    if (event === "style/green") {

      input.style.background = "#71EEB8"
      input.style.color = this.colors.dark.background
      input.style.border = `3px solid ${this.colors.dark.background}`
      return input
    }

    if (event === "style/light") {

      input.style.color = this.colors.light.text
      input.style.background = this.colors.light.background
      return input
    }

    if (event === "style/new-message") {

      this.render("text/node/bottom-right-onhover", "Neue Nachrichten gefunden", input)
      const dot = this.render("text/top-right", "●", input)
      dot.style.color = "green"
      dot.style.fontSize = "21px"
      this.add("style/green", input)
      return input
    }

    if (event === "style/red") {

      input.style.background = "#FA503D"
      input.style.color = this.colors.dark.background
      input.style.border = `3px solid ${this.colors.dark.background}`
      return input
    }

    if (event === "style/circle") {

      this.style(input, {borderRadius: "50%", border: "3px solid black", width: "34px", height: "34px", backgroundColor: "black"})
    }

    if (event === "style/yellow") {
      input.style.background = "#EAC07F"
      input.style.color = this.colors.dark.background
      input.style.border = `3px solid ${this.colors.dark.background}`
      return input
    }

    if (event === "next-steps") {

      const button = this.create("button/left-right")
      button.left.textContent = ".next-steps"
      button.right.textContent = "Was sind deine nächsten Schritte"
      button.onclick = () => {
        this.overlay("popup", async nextStepOverlay => {
          nextStepOverlay.info.textContent = ".next-steps"
          const content = this.create("div/scrollable", nextStepOverlay)
          this.render("text/h1", "Nächste Schritte", content)
          const options = this.create("div/flex-row", content)
          options.style.justifyContent = "flex-start"
          const updateNext = this.render("text/link", "Aktualisieren", options)
          const nextList = this.create("div/scrollable", content)
          this.render("contacts/node/next-list", nextList)
          updateNext.onclick = async () => {
            await this.render("contacts/node/next-list", nextList)
            window.alert("Deine Liste wurde erfolgreich aktualisiert.")
          }
        })
      }
      input?.appendChild(button)
      return button
    }

    if (event === "button/assign-expert-home") {

      return new Promise(async(resolve, reject) => {
        try {

          const res = await this.request("/get/expert/name-self/")
          if (res.status === 200) {
            const name = res.response

            const button = this.create("button/left-right")
            button.left.textContent = ".expert"
            button.right.textContent = "Der Bereich für Experten"
            button.onclick = () => window.open(`/${name}/`, "_blank")

            if (input) input.append(button)
            resolve(button)
          }

        } catch (error) {
          reject(error)
        }
      })

    }

    if (event === "admin-login") {

      const emailInput = document.querySelector(".email-input")
      const dsgvoInput = document.querySelector(".dsgvo-input")
      const submit = document.querySelector(".start-login-event")
      submit.onclick = async () => {
        await this.verify("input/value", emailInput)
        await this.verify("input/value", dsgvoInput)
        this.callback("email/pin-verified", emailInput.value, async () => {
          const res = await this.request("/register/user/super-admin", {email: emailInput.value})
          if (res.status === 200) {
            window.alert("Du kannst dich ab sofort auf deiner Plattform anmelden")
            window.location.assign("/login/")
          } else {
            window.alert("Fehler.. Bitte wiederholen.")
            this.add("style/not-valid", emailInput)
          }
        })
      }
    }

    if (event === "oninput/verify-input") {

      if (input.type === "email") {
        input.addEventListener("input", (ev) => {
          this.verify("input/value", ev.target)
        })
      }
      if (input.type === "checkbox") {
        input.addEventListener("input", (ev) => {
          if (ev.target.checked === true) {
            ev.target.setAttribute("checked", "true")
          } else {
            ev.target.removeAttribute("checked")
          }
          this.verify("input/value", ev.target)
        })
      }
    }

    if (event === "outline-hover") {

      input.setAttribute("onmouseover", "this.style.cursor = 'pointer'; this.style.outline = '3px solid #999'")
      input.setAttribute("onmouseout", "this.style.cursor = null; this.style.outline = null")
    }

    if (event === "outline-hover/field-funnel") {
      for (let i = 0; i < input.querySelectorAll("*").length; i++) {
        const node = input.querySelectorAll("*")[i]
        if (node.classList.contains("field-input") || node.classList.contains("submit-field-funnel-button")) {
          this.add("outline-hover", node)
        }
      }
    }

    if (event === "user-json/keydown-event") {

      if (input.classList.contains("user-json")) {

        input.onkeydown = (ev) => {
          if (ev.key === 'Enter') {
            ev.preventDefault()
            if (input.onenter !== undefined) input.onenter(ev)
          }
        }

      }

    }

  }

  static animate(event, input) {
    // event = input/animation

    if (event === "bounce") {

      const keyframes = [
        { transform: 'translateY(-21px)' },
        { transform: 'translateY(8px)' },
        { transform: 'translateY(-21px)' }
      ]
      const options = {
        duration: 2000,
        iterations: Infinity,
        easing: 'ease-in-out'
      }
      input.animate(keyframes, options)
    }

    if (event === "fade-up") {
      return input?.animate([
        { opacity: 0, transform: 'translateY(13px)' },
        { opacity: 1, transform: 'translateY(0)' },
      ], {
        duration: 233,
        easing: 'ease-in-out',
        fill: "forwards"
      })
    }

    if (event === "node/pulsate") {
      return input?.animate(
        [
          { transform: 'scale(1)' },
          { transform: 'scale(1.1)' },
          { transform: 'scale(1)' }
        ],
        {
          duration: 3000,
          easing: 'ease-in-out',
          iterations: Infinity
        }
      )
    }

    if (event === "node/border-ripple-out") {

      input.style.position = "relative"

      const rippleNode = input.cloneNode("true")
      rippleNode.classList.add("ripple-out")
      rippleNode.textContent = ""
      rippleNode.style.position = "absolute"
      rippleNode.style.top = "-8px"
      rippleNode.style.left = "-8px"
      input.querySelectorAll(".ripple-out").forEach(it => it.remove())
      input.appendChild(rippleNode)

      rippleNode.animate(
        [
          { transform: 'scale(1)', opacity: 1 },
          { transform: 'scale(2)', opacity: 0 }
        ],
        {
          duration: 3000,
          easing: 'ease-in-out',
          iterations: Infinity,
        }
      )

    }

  }

  static append(node, to){

    const fragment = document.createDocumentFragment()
    fragment.appendChild(node)
    to?.appendChild(fragment)
  }

  static callback(event, input, callback) {
    // event = input/algo

    if (event === "email/pin-verified") {

      return new Promise(async(resolve, reject) => {
        try {

          this.overlay("security", async overlay => {

            const content = document.createElement("div")
            content.style.display = "flex"
            content.style.flexDirection = "column"
            content.style.justifyContent = "center"
            content.style.alignItems = "center"
            content.style.height = `${window.innerHeight}px`
            overlay.append(content)

            try {
              const res = await this.request("/send/email/with/pin/", {email: input})
              if (res.status === 200) {
                overlay.info.remove()
                this.convert("element/reset", content)
                content.style.overflowY = "auto"
                const pinField = this.create("field/hex", content)
                pinField.label.textContent = "Meine PIN"
                this.add("style/not-valid", pinField.input)
                pinField.input.addEventListener("input", () => {
                  this.verify("input/value", pinField.input)
                })
                const button = this.create("button/action", content)
                button.style.fontSize = "34px"
                button.textContent = "PIN bestätigen"
                this.add("outline-hover", button)
                button.addEventListener("click", async () => {

                  this.overlay("security", async securityOverlay => {
                    try {
                      await this.verify("input/value", pinField.input)
                      const res = await this.request("/verify/pin/", {userPin: pinField.input.value})
                      if (res.status === 200) {
                        window.localStorage.setItem("email", input)
                        window.localStorage.setItem("localStorageId", await this.convert("text/digest", JSON.stringify({email: input, verified: true})))
                        await callback(overlay)
                      }
                    } catch (error) {
                      EventTarget.prototype.addEventListener = function(type, listener, options) {
                        console.log('Event listeners blocked')
                      }
                      window.XMLHttpRequest = function() {
                        console.log('XHR blocked')
                      }
                      window.alert("Es tut uns sehr leid, dass ein Fehler aufgetreten ist. Wir verstehen, wie frustrierend es sein kann, wenn Dinge nicht so funktionieren, wie sie sollten. Wir möchten Sie gerne beruhigen und Ihnen versichern, dass unser Team hart daran arbeitet, diesen Fehler so schnell wie möglich zu beheben. Wir hoffen, dass Sie uns die Gelegenheit geben werden, das Problem zu lösen. Falls der Fehler noch einmal auftritt, stehen wir Ihnen gerne zur Verfügung. Bitte zögern Sie nicht, uns unter 'datenschutz@get-your.de' zu kontaktieren, damit wir Ihnen helfen können. In der Zwischenzeit möchten wir Sie ermutigen, es einfach noch einmal zu versuchen. Vielen Dank für Ihr Verständnis und Ihre Geduld.")
                      reject(error)
                    }
                  })
                })
                const infoBox = this.create("info/success", content)
                infoBox.style.fontSize = "21px"
                const p1 = this.createNode("p", infoBox, `PIN erfolgreich an '${input}' gesendet.`)
                const span1 = this.createNode("span", p1, "✓")
                span1.style.fontSize = "34px"
                this.createNode("p", infoBox, "Es ist wichtig, dass deine PIN geheim gehalten wird, da sie als persönliches Kennwort dient und den Zugriff auf sensible Informationen oder Ressourcen ermöglicht. Teile deine PIN niemals mit anderen Personen. Das gilt selbst für enge Freunde, Familienmitglieder oder Mitarbeiter. Deine PIN sollte nur dir bekannt sein.")
                this.createNode("p", infoBox, "Bitte bestätige deine PIN um fortzufahren.")
              } else {
                window.alert("Fehler.. Bitte wiederholen.")
                window.location.reload()
              }
            } catch (error) {
              EventTarget.prototype.addEventListener = function(type, listener, options) {
                console.log('Event listeners blocked')
              }
              window.XMLHttpRequest = function() {
                console.log('XHR blocked')
              }
              window.alert(`Es konnte keine E-Mail an '${input}' verschickt werden.`)
              reject(error)
            }
          })

        } catch (error) {
          reject(error)
        }
      })

    }

  }

  static design(tree, input, parent) {

    if (tree === "numerologie") {

      if (input.birthdate) {
        const birthdate = input.birthdate
        const numerology = this.fn("numerology")
        const date = new Date(birthdate)
        const lifepath = numerology.dateToLifePath(date)
        const button = this.create("toolbox/left-right")
        button.left.className = "flex align center circle bg-green w55 h55"
        button.left.textContent = lifepath
        button.right.textContent = "Weiter zum Profil"
        if (parent) this.append(button, parent)
        return button
      }
    }

  }

  static div(className, node) {

    const div = document.createElement("div")
    div.className = className
    if (node) this.append(div, node)
    return div
  }

  static create(event, input) {

    // no events, only creation
    // event = thing/algo
    if (event === "add-button") {

      const button = this.create("button/add")
      this.add("outline-hover", button)
      button.classList.add("add")
      let exist = false
      document.querySelectorAll("*").forEach(node => {
        if (node.classList.contains("add") && node.classList.contains("button")) {
          this.add("outline-hover", node)
          exist = true
        }
      })
      if (exist === false) input?.appendChild(button)
      return button
    }

    if (event === "arrow-down") {

      const fragment = document.createDocumentFragment()
      const img = document.createElement("img")
      img.src = "/public/arrow-down-without-line.svg"
      this.style(img, {position: "absolute", bottom: "0", left: "50%", width: "34px"})
      fragment.appendChild(img)
      input?.appendChild(fragment)
      return img
    }

    if (event === "cite-button") {

      const it = document.createElement("div")
      it.className = "cite-button"
      it.textContent = "Dieses Dokument zitieren."
      Helper.style(it, {display: "inline-block", textDecoration: "underline", fontSize: "21px", margin: "34px 0", fontFamily: "sans-serif"})
      Helper.add("pointer", it)
      Helper.convert("link/dark-light", it)
      input?.appendChild(it)
      return it
    }

    if (event === "email-select") {

      function renderEmails(array, select) {
        const fragment = document.createDocumentFragment()
        field.input.textContent = ""
        for (let i = 0; i < array.length; i++) {
          const it = array[i]
          if (it.email !== undefined) {
            const option = document.createElement("option")
            option.text = it.email
            option.value = it.email
            fragment.appendChild(option)
          }
        }
        field.input.appendChild(fragment)
      }

      const searchField = this.create("field/text", input)
      searchField.label.textContent = "Suche nach E-Mail Adresse"
      searchField.input.placeholder = "Filter nach Text.."
      searchField.style.margin = "21px 34px 5px 34px"
      this.verify("input/value", searchField.input)
      this.add("outline-hover", searchField.input)

      function filterEmailsOnSearch(array) {
        searchField.input.oninput = (ev) => {
          const filtered = array.filter(it => it.email.toLowerCase().includes(ev.target.value.toLowerCase()))
          renderEmails(filtered, field.input)
        }
      }

      function selectedEmails() {
        return Array.from(field.input.selectedOptions).map(it => it.value)
      }

      const field = this.create("field/select", input)
      field.label.textContent = "E-Mails auswählen"
      field.input.setAttribute("multiple", "true")
      field.input.style.height = "34vh"
      this.add("outline-hover", field.input)
      this.verify("input/value", field.input)
      field.input.oninput = () => this.verify("input/value", field.input)
      return {field, renderEmails, filterEmailsOnSearch, selectedEmails}
    }

    if (event === "overlay/security") {
      const overlay = document.createElement("div")
      overlay.classList.add("overlay")
      overlay.style.height = "100%"
      overlay.style.overscrollBehavior = "none"
      overlay.style.width = "100%"
      overlay.style.zIndex = "99999999999999"
      overlay.style.position = "fixed"
      overlay.style.top = "0"
      overlay.style.left = "0"
      overlay.style.display = "flex"
      overlay.style.flexDirection = "column"
      overlay.style.background = this.colors.light.background

      this.create("info/loading", overlay)

      input?.append(overlay)
      return overlay
    }

    if (event === "template/checklist") {

      const items = []
      items.push({title: "Angebotsübersicht", description: "Hier können Sie ihr Angebot prüfen und anpassen, nähere Produktinformationen erhalten, Allgemeine Geschäftsbedingungen aufrufen und mehr über den Hersteller erfahren."})
      items.push({title: "Angebot hochladen", description: "Wenn Sie noch Fragen haben, finden Sie hier einen kompetenten Ansprechpartner. Haben Sie ihr Angebot geprüft und ggf. geändert, können Sie es hier drucken, hochladen und somit zur Prüfung freigeben."})
      items.push({title: "Baugo", description: "Ihr Angebot wird geprüft und ggf. freigegeben. Hier finden Sie ihren Projektbericht."})
      items.push({title: "Projektvorbereitung", description: "Um einen einwandfreien Aufbau ihres Energiekonzeptes zu ermöglichen, finden Sie hier eine Liste von Aufgaben, die Sie noch vor der Montage erledigen müssen."})
      items.push({title: "Bestätigen Sie die Warenlieferung", description: "Damit zusätzliche Kosten leicht vermieden werden können, prüfen Sie bitte mit Sorgfalt, ob alle gekauften Artikel angeliefert wurden. Die Bestätigung der Ware ist unerlässlich, um weitere Schritte des Aufbaus abzuschließen."})
      items.push({title: "DC-Ansprechpartner", description: "Ihren persönlichen Ansprechpartner für technische Fragen während der Montage finden Sie hier."})
      items.push({title: "Dachmontage - Termin vereinbaren", description: "Über den Terminkalender können Sie einfach und bequem ihren Wunschtermin mit dem Montageteam vereinbaren."})
      items.push({title: "Abnahmeprotokoll DC hochladen", description: "Nachdem unser Monteur das Abnahmeprotokoll aufgenommen hat, prüfen wir es zu ihrem Schutz."})
      items.push({title: "AC-Ansprechpartner", description: "Ihren persönlichen Ansprechpartner für technische Fragen während der Montage finden Sie hier."})
      items.push({title: "Hauselektrik - Termin vereinbaren", description: "Über den Terminkalender können Sie einfach und bequem ihren Wunschtermin mit dem Montageteam vereinbaren."})
      items.push({title: "Abnahmeprotokoll AC hochladen", description: "Nachdem unser Monteur das Abnahmeprotokoll aufgenommen hat, prüfen wir es zu ihrem Schutz."})
      items.push({title: "WP-Ansprechpartner", description: "Ihren persönlichen Ansprechpartner für technische Fragen während der Montage finden Sie hier."})
      items.push({title: "Wärmepumpe - Termin vereinbaren", description: "Über den Terminkalender können Sie einfach und bequem ihren Wunschtermin mit dem Montageteam vereinbaren."})
      items.push({title: "Abnahmeprotokoll WP hochladen", description: "Nachdem unser Monteur das Abnahmeprotokoll aufgenommen hat, prüfen wir es zu ihrem Schutz."})
      items.push({title: "Feedback", description: "Um uns stetig verbessern zu können, brauchen wir ihre Mithilfe. Geben Sie uns ihr Feedback zur Montage, damit unsere Prozesse noch einfacher und schneller werden."})

      this.create("header/left-right", input)
      this.create("header/nav", input)

      this.render("text/title", "Essentielles zum Anlagenaufbau", input)

      const info = this.create("info/success", input)
      info.textContent = "Bitte befolgen Sie diese Schritte, um den einwandfreien Aufbau ihres Energiesystems vorzubereiten."

      const checklist = this.render("checklist/items", items, input)

      return checklist

    }

    if (event === "session-login") {
      const backButton = this.create("back-button", input)
      this.convert("dark-light", backButton)

      const startButton = this.create("button/getyour", input)
      startButton.classList.add("start")
      this.convert("dark-light", startButton)

      const info = this.create("info/success", input)
      this.style(info, {fontSize: "13px", margin: "0", padding: "13px"})
      const div1 = this.createNode("div", info, "Unser Login Prozess ist intuitiv gestaltet und erfordert nur wenige Klicks. Du musst lediglich Deine E-Mail Adresse eingeben, um dich einzuloggen. Wir möchten, dass Du den Login Prozess als einfach und stressfrei erlebst.")
      const mailto = this.createNode("a", div1, " Wenn Du Probleme hast oder Hilfe benötigst, stehen wir Dir jederzeit zur Verfügung, um Dir schnell und effektiv weiter zu helfen.")
      mailto.className = "button"
      mailto.href = "mailto:datenschutz@get-your.de"

      const div2 = this.createNode("div", info, "Die Plattform von getyour soll ein sicheres und vertrauenswürdiges Umfeld bieten, damit Du dich auf Deine Daten verlassen kannst.")
      div2.style.marginTop = "13px"

      const emailField = this.create("input/email", input)
      emailField.style.margin = "21px 0"

      const dsgvoField = this.create("input/checkbox", input)
      dsgvoField.input.classList.add("dsgvo-input")
      dsgvoField.input.setAttribute("required", "true")
      this.style(dsgvoField, {margin: "21px 8px"})

      const label = this.createNode("div", input)
      this.style(label, {fontFamily: "sans-serif", margin: "21px 0"})
      this.createNode("span", label, "Ich habe die")
      const a1 = this.createNode("a", label, "Nutzervereinbarungen")
      a1.style.margin = "0 5px"
      a1.className = "button"
      a1.href = "/nutzervereinbarung/"
      this.createNode("span", label, "und die")
      const a2 = this.createNode("a", label, "Datenschutz Richtlinien")
      a2.style.margin = "0 5px"
      a2.className = "button"
      a2.href = "/datenschutz/"
      this.createNode("span", label, "gelesen und verstanden. Durch meine Anmeldung stimme ich ihnen zu.")

      const submit = this.create("button/action", input)
      this.style(submit, {fontSize: "34px", margin: "0"})
      submit.classList.add("session-login-submit")
      submit.textContent = "Jetzt anmelden"

    }

    if (event === "soundbox") {

      const fileImportField = this.create("field/file", input)
      fileImportField.label.textContent = "MP3 to CID"
      fileImportField.input.setAttribute("accept", "audio/mp3")
      fileImportField.input.setAttribute("required", "true")
      fileImportField.input.setAttribute("multiple", "true")
      fileImportField.input.setAttribute("soundbox-file-import", "")
      this.verify("input/value", fileImportField.input)

      this.create("script/soundbox", input)

      const div = this.create("div/top-bottom", input)
      div.top.setAttribute("soundbox-tools", "")
      div.bottom.setAttribute("soundbox-audio-list", "")

    }

    if (event === "input/alias"){

      const alias = this.create("input/text")
      alias.input.maxLength = "55"
      alias.input.placeholder = "Alternativer Name"
      alias.input.addEventListener("input", () => this.verify("input/value", alias.input))
      alias.input.setAttribute("required", "true")
      alias.input.setAttribute("accept", "text/length")
      this.add("outline-hover", alias.input)
      this.verify("input/value", alias.input)
      if (input) this.render("node", alias, input)
      return alias
    }

    if (event === "input/path") {

      const fragment = document.createDocumentFragment()
      const field = this.create("input/text", fragment)
      field.input.placeholder = "/mein/pfad/../ (text/path)"
      field.input.setAttribute("required", "true")
      field.input.setAttribute("accept", "text/path")
      input?.appendChild(fragment)
      return field
    }

    if (event === "input/script") {

      const field = this.create("input/textarea")
      field.input.placeholder = "<script>..</script>"
      this.style(field.input, {height: "55px", fontSize: "13px", fontFamily: "monospace"})
      field.input.setAttribute("required", "true")
      field.input.setAttribute("accept", "text/script")
      this.verify("input/value", field.input)
      field.input.addEventListener("input", ev => this.verify("input/value", field.input))
      input?.appendChild(field)
      return field
    }

    if (event === "input/select") {

      const div = document.createElement("div")
      this.style(div, {margin: "21px 34px", position: "relative"})
      div.input = document.createElement("select")
      div.appendChild(div.input)
      div.input.add = (options) => {
        div.input.textContent = ""
        for (let i = 0; i < options.length; i++) {
          const option = document.createElement("option")
          option.value = options[i]
          option.text = options[i]
          div.input.appendChild(option)
        }
      }
      div.input.addEventListener("input", ev => {
        if (ev.target.value.startsWith("--")) {
          this.add("style/not-valid", div.input)
          return
        }
        this.add("style/valid", div.input)
      })
      this.style(div.input, {width: "89%", fontSize: "21px"})
      this.add("outline-hover", div.input)
      this.convert("dark-light", div.input)
      input?.appendChild(div)
      return div
    }

    if (event === "input/textarea") {

      const div = document.createElement("div")
      this.style(div, {margin: "21px 34px", position: "relative"})
      div.input = document.createElement("textarea")
      div.appendChild(div.input)
      div.input.addEventListener("input", ev => this.verify("input/value", div.input))
      this.add("outline-hover", div.input)
      this.convert("dark-light", div.input)
      this.style(div.input, {width: "89%", fontSize: "21px"})
      this.verify("input/value", div.input)
      input?.appendChild(div)
      return div
    }

    if (event === "input/checkbox") {

      const div = document.createElement("div")
      this.style(div, {display: "flex", alignItems: "center", height: "34px", width: "55px", margin: "21px 34px", position: "relative"})
      div.input = document.createElement("input")
      div.appendChild(div.input)
      div.input.type = "checkbox"
      div.input.style.transform = "scale(2)"
      this.verify("input/value", div.input)
      this.convert("dark-light", div.input)
      input?.appendChild(div)
      return div
    }

    if (event === "input/date") {

      const div = document.createElement("div")
      this.style(div, {margin: "21px 34px", position: "relative"})
      div.input = document.createElement("input")
      div.appendChild(div.input)
      div.input.type = "date"
      this.style(div.input, {width: "89%", fontSize: "21px"})
      this.add("outline-hover", div.input)
      this.verify("input/value", div.input)
      this.convert("dark-light", div.input)
      input?.appendChild(div)
      return div
    }

    if (event === "input/email") {

      const div = document.createElement("div")
      this.style(div, {margin: "21px 34px", position: "relative"})
      div.input = document.createElement("input")
      div.appendChild(div.input)
      div.input.classList.add("email-input")
      div.input.type = "email"
      div.input.placeholder = "E-Mail Adresse"
      div.input.addEventListener("input", ev => this.verify("input/value", div.input))
      div.input.setAttribute("required", "true")
      div.input.setAttribute("accept", "text/email")
      this.style(div.input, {width: "89%", fontSize: "21px"})
      this.add("outline-hover", div.input)
      this.verify("input/value", div.input)
      this.convert("dark-light", div.input)
      input?.appendChild(div)
      return div
    }

    if (event === "input/file") {

      const div = document.createElement("div")
      this.style(div, {margin: "21px 34px", position: "relative"})
      div.input = document.createElement("input")
      div.appendChild(div.input)
      div.input.type = "file"
      this.style(div.input, {width: "89%", fontSize: "21px"})
      this.add("outline-hover", div.input)
      this.verify("input/value", div.input)
      this.convert("dark-light", div.input)
      input?.appendChild(div)
      return div
    }

    if (event === "input/id") {

      const id = this.create("input/text", input)
      id.input.placeholder = "Id eingeben (text/tag)"
      id.input.setAttribute("required", "true")
      id.input.setAttribute("accept", "text/tag, text/length")
      id.input.maxLength = "34"
      id.input.addEventListener("input", ev => this.verify("input/value", id.input))
      this.verify("input/value", id.input)
      return id
    }

    if (event === "input/number") {

      const div = document.createElement("div")
      this.style(div, {margin: "21px 34px", position: "relative"})
      div.input = document.createElement("input")
      div.appendChild(div.input)
      div.input.type = "number"
      this.style(div.input, {width: "89%", fontSize: "21px"})
      this.add("outline-hover", div.input)
      this.verify("input/value", div.input)
      this.convert("dark-light", div.input)
      input?.appendChild(div)
      return div
    }

    if (event === "input/password") {

      const div = document.createElement("div")
      this.style(div, {margin: "21px 34px", position: "relative"})
      div.input = document.createElement("input")
      div.appendChild(div.input)
      div.input.type = "password"
      this.style(div.input, {width: "89%", fontSize: "21px"})
      this.add("outline-hover", div.input)
      this.verify("input/value", div.input)
      this.convert("dark-light", div.input)
      input?.appendChild(div)
      return div
    }

    if (event === "input/range") {

      const div = document.createElement("div")
      this.style(div, {margin: "21px 34px", position: "relative"})
      div.input = document.createElement("input")
      div.appendChild(div.input)
      div.input.type = "range"
      this.style(div.input, {width: "89%", fontSize: "21px"})
      this.add("outline-hover", div.input)
      this.verify("input/value", div.input)
      this.convert("dark-light", div.input)
      input?.appendChild(div)
      return div
    }

    if (event === "input/phone") {

      const div = document.createElement("div")
      this.style(div, {margin: "21px 34px", position: "relative"})
      div.input = document.createElement("input")
      this.append(div.input, div)
      div.input.type = "tel"
      div.input.placeholder = "Telefon Nummer"
      div.input.addEventListener("input", ev => this.verify("input/value", div.input))
      div.input.setAttribute("required", "true")
      div.input.setAttribute("accept", "text/tel")
      this.add("outline-hover", div.input)
      this.convert("dark-light", div.input)
      this.style(div.input, {width: "89%", fontSize: "21px"})
      this.verify("input/value", div.input)
      if (input) this.append(div, input)
      return div
    }

    if (event === "input/tel") {

      const div = document.createElement("div")
      this.style(div, {margin: "21px 34px", position: "relative"})
      div.input = document.createElement("input")
      this.append(div.input, div)
      div.input.type = "tel"
      div.input.addEventListener("input", ev => this.verify("input/value", div.input))
      this.add("outline-hover", div.input)
      this.convert("dark-light", div.input)
      this.style(div.input, {width: "89%", fontSize: "21px"})
      this.verify("input/value", div.input)
      if (input) this.append(div, input)
      return div
    }

    if (event === "input/text") {

      const div = document.createElement("div")
      this.style(div, {margin: "21px 34px", position: "relative"})
      div.input = document.createElement("input")
      this.append(div.input, div)
      div.input.type = "text"
      div.input.addEventListener("input", ev => this.verify("input/value", div.input))
      this.add("outline-hover", div.input)
      this.convert("dark-light", div.input)
      this.verify("input/value", div.input)
      this.style(div.input, {width: "89%", fontSize: "21px"})
      if (input) this.append(div, input)
      return div
    }

    if (event === "input/url"){

      const div = this.create("input/text")
      div.input.placeholder = "Webseiten URL (text/url)"
      div.input.setAttribute("required", "true")
      div.input.setAttribute("accept", "text/url")
      this.verify("input/value", div.input)
      if (input) this.append(div, input)
      return div
    }

    if (event === "input/visibility") {

      const field = this.create("input/text", input)
      field.input.placeholder = "Sichtbarkeit (open/closed)"
      field.input.value = "closed"
      field.input.setAttribute("required", "true")
      field.input.addEventListener("input", ev => this.verify("input/value", field.input))
      this.verify("input/value", field.input)
      return field
    }

    if (event === "img") {

      const img = document.createElement("img")
      img.src = "/public/image-placeholder.svg"
      img.style.width = "34px"
      img.style.margin = "21px 34px"

      input?.append(img)
      return img
    }

    if (event === "p") {

      const p = document.createElement("p")
      p.style.margin = "21px 34px"
      p.style.fontFamily = "sans-serif"
      p.style.fontWeight = "normal"
      p.style.fontSize = "21px"
      input?.appendChild(p)
      return p

    }

    if (event === "h3") {

      const h3 = document.createElement("h3")
      h3.style.margin = "21px 34px"
      h3.style.fontFamily = "sans-serif"
      h3.style.fontWeight = "normal"

      input?.append(h3)
      return h3
    }

    if (event === "h2") {

      const h2 = document.createElement("h2")
      h2.style.margin = "21px 34px"
      h2.style.fontFamily = "sans-serif"
      h2.style.fontWeight = "normal"

      input?.append(h2)
      return h2
    }

    if (event === "h1") {

      const h1 = document.createElement("h1")
      h1.style.margin = "21px 34px"
      h1.style.fontFamily = "sans-serif"
      h1.style.fontWeight = "normal"

      input?.append(h1)
      return h1
    }

    if (event === "hr") {

      const hr = document.createElement("hr")

      if (input) input.append(hr)
      return hr
    }

    if (event === "funnel/source") {

      const fragment = document.createDocumentFragment()
      const funnel = this.create("div/scrollable", fragment)
      funnel.id = "source"
      funnel.authors = this.create("input/textarea", funnel)
      funnel.authors.id = "authors"
      funnel.authors.input.placeholder = "author1, author2, .., authorN"
      funnel.authors.input.setAttribute("required", "true")
      funnel.authors.input.oninput = () => this.verify("input/value", funnel.authors.input)
      this.verify("input/value", funnel.authors.input)
      funnel.titel = this.create("input/textarea", funnel)
      funnel.titel.id = "title"
      funnel.titel.input.placeholder = "JavaScript für Anfänger"
      funnel.titel.input.setAttribute("required", "true")
      funnel.titel.input.oninput = () => this.verify("input/value", funnel.titel.input)
      this.verify("input/value", funnel.titel.input)
      funnel.edition = this.create("input/tel", funnel)
      funnel.edition.id = "edition"
      funnel.edition.input.placeholder = "Auflage"
      funnel.edition.input.oninput = () => this.verify("input/value", funnel.edition.input)
      this.verify("input/value", funnel.edition.input)
      funnel.publisher = this.create("input/textarea", funnel)
      funnel.publisher.id = "publisher"
      funnel.publisher.input.placeholder = "publisher1, publisher2, .., publisherN"
      funnel.publisher.input.setAttribute("required", "true")
      funnel.publisher.input.oninput = () => this.verify("input/value", funnel.publisher.input)
      this.verify("input/value", funnel.publisher.input)
      funnel.published = this.create("input/tel", funnel)
      funnel.published.id = "published"
      funnel.published.input.placeholder = "Jahr der Herausgabe"
      funnel.published.input.setAttribute("required", "true")
      funnel.published.input.oninput = () => this.verify("input/value", funnel.published.input)
      this.verify("input/value", funnel.published.input)
      funnel.isbn = this.create("input/text", funnel)
      funnel.isbn.id = "isbn"
      funnel.isbn.input.placeholder = "isbn1, isbn2, .., isbnN"
      funnel.isbn.input.oninput = () => this.verify("input/value", funnel.isbn.input)
      this.verify("input/value", funnel.isbn.input)
      funnel.weblink = this.create("input/text", funnel)
      funnel.weblink.id = "weblink"
      funnel.weblink.input.placeholder = "Web URL zur Quelle"
      funnel.weblink.input.oninput = () => this.verify("input/value", funnel.weblink.input)
      this.verify("input/value", funnel.weblink.input)
      funnel.language = this.create("input/text", funnel)
      funnel.language.id = "language"
      funnel.language.input.placeholder = "de, en, fr, .."
      funnel.language.input.oninput = () => this.verify("input/value", funnel.language.input)
      this.verify("input/value", funnel.language.input)
      funnel.type = this.create("input/text", funnel)
      funnel.type.id = "type"
      funnel.type.input.placeholder = "text/book"
      funnel.type.input.oninput = () => this.verify("input/value", funnel.type.input)
      this.verify("input/value", funnel.type.input)
      funnel.keywords = this.create("input/textarea", funnel)
      funnel.keywords.id = "keywords"
      funnel.keywords.input.placeholder = "keyword1, keyword2, .., keywordN"
      funnel.keywords.input.style.height = "144px"
      funnel.keywords.input.oninput = () => this.verify("input/value", funnel.keywords.input)
      this.verify("input/value", funnel.keywords.input)
      funnel.description = this.create("input/textarea", funnel)
      funnel.description.id = "description"
      funnel.description.input.placeholder = "Beschreibung oder Notizen zu deiner Quelle"
      funnel.description.input.style.height = "144px"
      funnel.description.input.oninput = () => this.verify("input/value", funnel.description.input)
      this.verify("input/value", funnel.description.input)
      funnel.image = this.create("input/text", funnel)
      funnel.image.id = "image"
      funnel.image.input.placeholder = "Bild URL deiner Quelle"
      funnel.image.input.oninput = () => this.verify("input/value", funnel.image.input)
      this.verify("input/value", funnel.image.input)
      funnel.submit = this.create("toolbox/action", funnel)
      funnel.submit.className = "submit-field-funnel-button"
      funnel.submit.textContent = "Quelle jetzt speichern"
      input?.appendChild(fragment)
      return funnel
    }

    if (event === "field-funnel/source") {

      const funnel = this.create("div/scrollable", input)
      funnel.id = "source"

      funnel.authorsField = this.create("field/textarea", funnel)
      funnel.authorsField.id = "authors"
      funnel.authorsField.label.textContent = "Authoren (mit Komma trennen)"
      funnel.authorsField.input.placeholder = "author1, author2, .., authorN"
      funnel.authorsField.input.setAttribute("required", "true")
      funnel.authorsField.input.oninput = () => this.verify("input/value", funnel.authorsField.input)
      this.verify("input/value", funnel.authorsField.input)
      this.add("outline-hover", funnel.authorsField.input)

      funnel.titleField = this.create("field/textarea", funnel)
      funnel.titleField.id = "title"
      funnel.titleField.label.textContent = "Titel der Quelle"
      funnel.titleField.input.placeholder = "JavaScript für Anfänger"
      funnel.titleField.input.setAttribute("required", "true")
      funnel.titleField.input.oninput = () => this.verify("input/value", funnel.titleField.input)
      this.verify("input/value", funnel.titleField.input)
      this.add("outline-hover", funnel.titleField.input)

      funnel.editionField = this.create("field/tel", funnel)
      funnel.editionField.id = "edition"
      funnel.editionField.label.textContent = "Auflage"
      funnel.editionField.input.placeholder = "0"
      funnel.editionField.input.oninput = () => this.verify("input/value", funnel.editionField.input)
      this.verify("input/value", funnel.editionField.input)
      this.add("outline-hover", funnel.editionField.input)

      funnel.publisherField = this.create("field/textarea", funnel)
      funnel.publisherField.id = "publisher"
      funnel.publisherField.label.textContent = "Herausgeber (mit Komma trennen)"
      funnel.publisherField.input.placeholder = "publisher1, publisher2, .., publisherN"
      funnel.publisherField.input.setAttribute("required", "true")
      funnel.publisherField.input.oninput = () => this.verify("input/value", funnel.publisherField.input)
      this.verify("input/value", funnel.publisherField.input)
      this.add("outline-hover", funnel.publisherField.input)

      funnel.publishedField = this.create("field/tel", funnel)
      funnel.publishedField.id = "published"
      funnel.publishedField.label.textContent = "Jahr der Herausgabe"
      funnel.publishedField.input.placeholder = "2019"
      funnel.publishedField.input.setAttribute("required", "true")
      funnel.publishedField.input.oninput = () => this.verify("input/value", funnel.publishedField.input)
      this.verify("input/value", funnel.publishedField.input)
      this.add("outline-hover", funnel.publishedField.input)

      funnel.isbnField = this.create("field/text", funnel)
      funnel.isbnField.id = "isbn"
      funnel.isbnField.label.textContent = "ISBN Nummern (mit Komma trennen)"
      funnel.isbnField.input.placeholder = "isbn1, isbn2, .., isbnN"
      funnel.isbnField.input.oninput = () => this.verify("input/value", funnel.isbnField.input)
      this.verify("input/value", funnel.isbnField.input)
      this.add("outline-hover", funnel.isbnField.input)

      funnel.weblinkField = this.create("field/text", funnel)
      funnel.weblinkField.id = "weblink"
      funnel.weblinkField.label.textContent = "Web Link zur Quelle"
      funnel.weblinkField.input.placeholder = "https://www.meine-infos.de/meine-quelle/"
      funnel.weblinkField.input.oninput = () => this.verify("input/value", funnel.weblinkField.input)
      this.verify("input/value", funnel.weblinkField.input)
      this.add("outline-hover", funnel.weblinkField.input)

      funnel.languageField = this.create("field/text", funnel)
      funnel.languageField.id = "language"
      funnel.languageField.label.textContent = "Sprachen erste 2 Buchstaben (mit Komma trennen)"
      funnel.languageField.input.placeholder = "de, en, fr, .."
      funnel.languageField.input.oninput = () => this.verify("input/value", funnel.languageField.input)
      this.verify("input/value", funnel.languageField.input)
      this.add("outline-hover", funnel.languageField.input)

      funnel.typeField = this.create("field/text", funnel)
      funnel.typeField.id = "type"
      funnel.typeField.label.textContent = "Art der Quelle"
      funnel.typeField.input.placeholder = "text/book"
      funnel.typeField.input.oninput = () => this.verify("input/value", funnel.typeField.input)
      this.verify("input/value", funnel.typeField.input)
      this.add("outline-hover", funnel.typeField.input)

      funnel.keywordsField = this.create("field/textarea", funnel)
      funnel.keywordsField.id = "keywords"
      funnel.keywordsField.label.textContent = "Schlüsselwörter deiner Quelle (mit Komma trennen)"
      funnel.keywordsField.input.placeholder = "keyword1, keyword2, .., keywordN"
      funnel.keywordsField.input.style.height = "144px"
      funnel.keywordsField.input.oninput = () => this.verify("input/value", funnel.keywordsField.input)
      this.verify("input/value", funnel.keywordsField.input)
      this.add("outline-hover", funnel.keywordsField.input)

      funnel.descriptionField = this.create("field/textarea", funnel)
      funnel.descriptionField.id = "description"
      funnel.descriptionField.label.textContent = "Beschreibung oder Notizen zu deiner Quelle"
      funnel.descriptionField.input.placeholder = "Hier findest du mehr Informationen über deine Quelle .."
      funnel.descriptionField.input.style.height = "144px"
      funnel.descriptionField.input.oninput = () => this.verify("input/value", funnel.descriptionField.input)
      this.verify("input/value", funnel.descriptionField.input)
      this.add("outline-hover", funnel.descriptionField.input)

      funnel.imageField = this.create("field/text", funnel)
      funnel.imageField.id = "image"
      funnel.imageField.label.textContent = "Bild URL deiner Quelle"
      funnel.imageField.input.placeholder = "https://www.meine-infos.de/meine-quellbild.jpg"
      funnel.imageField.input.oninput = () => this.verify("input/value", funnel.imageField.input)
      this.verify("input/value", funnel.imageField.input)
      this.add("outline-hover", funnel.imageField.input)

      funnel.submit = this.create("button/action", funnel)
      funnel.submit.className = "submit-field-funnel-button"
      this.add("outline-hover", funnel.submit)
      funnel.submit.textContent = "Quelle jetzt speichern"
      return funnel

    }

    if (event === "funnel/conflict") {
      const it = {}

      it.environment = this.create("input/textarea", input)
      const environmentPlaceholder = `Environments: Beschreibe deine Umgebung ?

- URL Link
- Browser
- App
      `
      it.environment.input.placeholder = environmentPlaceholder
      it.environment.input.style.height = "144px"
      this.add("style/valid", it.environment.input)
      it.environment.input.style.fontSize = "13px"

      it.reproduce = this.create("input/textarea", input)
      const reproducePlaceholder = `Steps to reproduce: Reproduziere den Konflikt ?`
      it.reproduce.input.placeholder = reproducePlaceholder
      it.reproduce.input.style.height = "144px"
      this.add("style/valid", it.reproduce.input)
      it.reproduce.input.style.fontSize = "13px"

      it.expected = this.create("input/textarea", input)
      const expectedPlaceholder = `Expected behavior: Erwartetes Verhalten ?`
      it.expected.input.placeholder = expectedPlaceholder
      it.expected.input.style.height = "144px"
      this.add("style/valid", it.expected.input)
      it.expected.input.style.fontSize = "13px"

      it.actual = this.create("input/textarea", input)
      const actualPlaceholder = `Actual behavior: Wirkliches Verhalten ?`
      it.actual.input.placeholder = actualPlaceholder
      it.actual.input.style.height = "144px"
      this.add("style/valid", it.actual.input)
      it.actual.input.style.fontSize = "13px"

      it.visibility = this.create("input/visibility", input)
      it.visibility.input.value = "open"

      it.submit = this.create("toolbox/action", input)
      it.submit.textContent = "Konflikt jetzt melden"

      return it
    }

    if (event === "funnel/condition") {

      const funnel = this.create("div/scrollable")

      funnel.leftField = this.create("field/tree", funnel)
      funnel.leftField.label.textContent = "Nach welcher Datenstruktur soll die Plattform suchen"
      funnel.leftField.input.maxLength = "55"
      funnel.leftField.input.placeholder = "getyour.expert.name"
      this.verify("input/value", funnel.leftField.input)
      funnel.leftField.input.oninput = () => this.verify("input/value", funnel.leftField.input)

      funnel.operatorField = this.create("field/operator", funnel)
      this.verify("input/value", funnel.operatorField.input)
      funnel.operatorField.input.oninput = () => this.verify("input/value", funnel.operatorField.input)

      funnel.rightField = this.create("field/text", funnel)
      funnel.rightField.label.textContent = "Vergleichswert"
      funnel.rightField.input.maxLength = "55"
      funnel.rightField.input.setAttribute("required", "true")
      funnel.rightField.input.placeholder = "any"
      this.verify("input/value", funnel.rightField.input)
      funnel.rightField.input.oninput = () => this.verify("input/value", funnel.rightField.input)

      funnel.submit = this.create("button/action", funnel)
      funnel.submit.textContent = "Bedingung jetzt speichern"


      if (input !== undefined) input.append(funnel)
      return funnel
    }

    if (event === "funnel/profile") {
      const it = {}

      this.request("/get/user/tree-closed/", {tree: "profile"}).then(async res => {
        if (res.status === 200) {
          const profile = JSON.parse(res.response)

          const messagesDiv = document.createElement("div")
          this.style(messagesDiv, {display: "flex", flexWrap: "wrap", justifyContent: "space-around"})
          input.prepend(messagesDiv)

          if (profile.messages !== undefined) {
            for (let i = 0; i < profile.messages.length; i++) {
              const message = profile.messages[i]
              const box = this.create("box", messagesDiv)
              this.style(box, {fontFamily: "sans-serif", fontSize: "21px"})
              box.innerHTML = await this.convert("text/purified", message.html)
              box.onclick = () => {
                this.overlay("popup", overlay => {
                  const content = this.create("div/scrollable", overlay)
                  {
                    const button = this.create("toolbox/left-right", content)
                    button.left.textContent = ".remove"
                    button.right.textContent = "Nachricht entfernen"
                    button.onclick = () => {
                      const confirm = window.confirm("Möchtest du diese Nachricht wirklich entfernen?")
                      if (confirm === true) {
                        this.overlay("security", async securityOverlay => {
                          const res = await this.request("/remove/user/profile-message/", {id: message.created})
                          if (res.status === 200) {
                            window.alert("Deine Nachricht wurde erfolgreich entfernt.")
                            box.remove()
                            overlay.remove()
                            securityOverlay.remove()
                          } else {
                            window.alert("Fehler.. Bitte wiederholen.")
                            securityOverlay.remove()
                          }
                        })
                      }
                    }
                  }
                })
              }
            }
          }

          const title = this.render("text/h2", "Meine Nachrichten")
          input.prepend(title)


          it.aboutYou.input.value = profile.aboutYou
          it.whyThis.input.value = profile.whyThis
          it.whyYou.input.value = profile.whyYou
          it.strength.input.value = profile.strength
          it.weakness.input.value = profile.weakness
          it.motivation.input.value = profile.motivation
          it.visibility.input.value = profile.visibility
        }
      })

      it.aboutYou = this.create("input/textarea", input)
      const aboutYouPlaceholder = `Erzähl etwas über dich ?

- was du gerade machst (beruflich oder privat)
- etwas was dem anderen hilft
- von jetzt sprechen
- praktische Beispiele (beruflich oder privat)
- Schlüsselwörter benutzen (IT, Beratung)

z.b., ich bin ... (deine Person), das heißt ... (Vorteil), das bedeutet für dich ... (Nutzen für den anderen).
      `
      it.aboutYou.input.placeholder = aboutYouPlaceholder
      it.aboutYou.input.style.height = "144px"
      this.add("style/valid", it.aboutYou.input)
      it.aboutYou.input.style.fontSize = "13px"
      it.aboutYou.input.setAttribute("accept", "text/length")
      it.aboutYou.input.maxLength = "4181"

      it.whyThis = this.create("input/textarea", input)
      const whyThisPlaceholder = `Was kannst du besonders gut ?

- Nicht in Bullet Points schreiben
- Vollständige Sätze formulieren

z.b., mit der STAR Methode:

1. Situation
2. Task
3. Action
4. Result
      `
      it.whyThis.input.placeholder = whyThisPlaceholder
      it.whyThis.input.style.height = "144px"
      this.add("style/valid", it.whyThis.input)
      it.whyThis.input.style.fontSize = "13px"
      it.whyThis.input.setAttribute("accept", "text/length")
      it.whyThis.input.maxLength = "4181"

      it.whyYou = this.create("input/textarea", input)
      const whyYouPlaceholder = `Warum sollten wir dich wählen ?

- Stärken definieren

z.b., ich kann ... (deine Stärken), das heißt ... (Vorteil), das bedeutet für dich ... (Nutzen für den anderen).
      `
      it.whyYou.input.placeholder = whyYouPlaceholder
      it.whyYou.input.style.height = "144px"
      this.add("style/valid", it.whyYou.input)
      it.whyYou.input.style.fontSize = "13px"
      it.whyYou.input.setAttribute("accept", "text/length")
      it.whyYou.input.maxLength = "4181"

      it.strength = this.create("input/textarea", input)
      const strengthPlaceholder = `Was sind deine Stärken ?

- Stärken definieren

z.b., ich kann ... (deine Stärken), das heißt ... (Vorteil), das bedeutet für dich ... (Nutzen für den anderen).
      `
      it.strength.input.placeholder = strengthPlaceholder
      it.strength.input.style.height = "144px"
      this.add("style/valid", it.strength.input)
      it.strength.input.style.fontSize = "13px"
      it.strength.input.setAttribute("accept", "text/length")
      it.strength.input.maxLength = "6765"

      it.weakness = this.create("input/textarea", input)
      const weaknessPlaceholder = `Was sind deine Schwächen ?

- Schwächen definieren
- aber dann Lösung anbieten
- Schwächen die keine hohe Priorität haben am besten gar nicht erwähnen
- Schwächen nennen die ich wirklich verbessern möchte

z.b., ich bin ... (deine Schwäche), aber ich arbeite daran es zu verbessern mit ... (einem Beispiel oder zwei).
      `
      it.weakness.input.placeholder = weaknessPlaceholder
      it.weakness.input.style.height = "144px"
      this.add("style/valid", it.weakness.input)
      it.weakness.input.style.fontSize = "13px"
      it.weakness.input.setAttribute("accept", "text/length")
      it.weakness.input.maxLength = "6765"

      it.motivation = this.create("input/textarea", input)
      const motivationPlaceholder = `Wie motivierst du dich ?

z.b., ich möchte das Web, für ... (Adressat), scheller und einfacher machen, ..
      `
      it.motivation.input.placeholder = motivationPlaceholder
      it.motivation.input.style.height = "144px"
      this.add("style/valid", it.motivation.input)
      it.motivation.input.style.fontSize = "13px"
      it.motivation.input.setAttribute("accept", "text/length")
      it.motivation.input.maxLength = "4181"

      it.visibility = this.create("input/text", input)
      it.visibility.input.placeholder = "Sichtbarkeit (open/closed)"
      it.visibility.input.value = "closed"
      it.visibility.input.setAttribute("required", "true")
      it.visibility.input.oninput = () => this.verify("input/value", it.visibility.input)
      it.visibility.input.setAttribute("accept", "text/length")
      it.visibility.input.maxLength = "6"
      this.verify("input/value", it.visibility.input)

      it.submit = this.create("toolbox/action", input)
      it.submit.textContent = "Profil jetzt speichern"

      return it
    }

    if (event === "header/sticky-nav") {

      const header = document.createElement("header")
      header.style.display = "flex"
      header.style.flexDirection = "column"
      header.style.justifyContent = "space-between"

      const headerLogo = document.createElement("img")
      headerLogo.src = "/public/image-placeholder.svg"
      // headerLogo.alt = "SHS Express Logo"
      headerLogo.style.margin = "8px 34px"
      headerLogo.style.width = "144px"
      headerLogo.style.cursor = "pointer"
      // headerLogo.addEventListener("click", () => window.history.back())
      header.append(headerLogo)


      const navContainer = document.createElement("div")
      navContainer.style.display = "flex"
      navContainer.style.justifyContent = "space-evenly"
      navContainer.style.boxShadow = "0 3px 5px rgba(0, 0, 0, 0.13)"

      const button1 = document.createElement("div")
      button1.classList.add("button-1")
      button1.style.display = "flex"
      button1.style.flexDirection = "column"
      button1.style.alignItems = "center"
      button1.style.justifyContent = "center"
      button1.style.width = "89px"
      button1.style.margin = "13px"
      button1.style.cursor = "pointer"
      // button1.addEventListener("click", async() => await checkAndProceed("/felix/shs/abfrage-haus/"))

      const title1 = document.createElement("div")
      title1.textContent = "Haus"
      button1.append(title1)

      const index1 = document.createElement("div")
      index1.textContent = "1"
      index1.style.color = "white"

      const state1 = document.createElement("div")
      state1.style.display = "flex"
      state1.style.justifyContent = "center"
      state1.style.alignItems = "center"
      state1.style.width = "55px"
      state1.style.height = "34px"
      state1.style.margin = "13px 0"
      state1.style.backgroundColor = "#11841e"
      button1.append(state1)

      state1.append(index1)

      navContainer.append(button1)


      const button2 = document.createElement("div")
      button2.classList.add("button-1")
      button2.style.display = "flex"
      button2.style.flexDirection = "column"
      button2.style.justifyContent = "center"
      button2.style.alignItems = "center"
      button2.style.width = "89px"
      button2.style.margin = "13px"
      button2.style.cursor = "pointer"
      // button2.addEventListener("click", async() => await checkAndProceed("/felix/shs/abfrage-heizung/"))

      const title2 = document.createElement("div")
      title2.textContent = "Heizung"
      button2.append(title2)

      const index2 = document.createElement("div")
      index2.textContent = "2"
      index2.style.color = "white"

      const state2 = document.createElement("div")
      state2.style.display = "flex"
      state2.style.justifyContent = "center"
      state2.style.alignItems = "center"
      state2.style.width = "55px"
      state2.style.height = "34px"
      state2.style.margin = "13px 0"
      state2.style.backgroundColor = "#11841e"
      button2.append(state2)

      state2.append(index2)

      navContainer.append(button2)



      const button3 = document.createElement("div")
      button3.classList.add("button-1")
      button3.style.display = "flex"
      button3.style.flexDirection = "column"
      button3.style.justifyContent = "center"
      button3.style.alignItems = "center"
      button3.style.width = "89px"
      button3.style.margin = "13px"
      button3.style.cursor = "pointer"
      // button3.addEventListener("click", async() => await checkAndProceed("/felix/shs/abfrage-strom/"))

      const title3 = document.createElement("div")
      title3.textContent = "Strom"
      button3.append(title3)

      const index3 = document.createElement("div")
      index3.textContent = "3"
      index3.style.color = "white"

      const state3 = document.createElement("div")
      state3.style.display = "flex"
      state3.style.justifyContent = "center"
      state3.style.alignItems = "center"
      state3.style.width = "55px"
      state3.style.height = "34px"
      state3.style.margin = "13px 0"
      state3.style.backgroundColor = "#11841e"
      button3.append(state3)

      state3.append(index3)

      navContainer.append(button3)



      const button4 = document.createElement("div")
      button4.classList.add("button-1")
      button4.style.display = "flex"
      button4.style.flexDirection = "column"
      button4.style.justifyContent = "center"
      button4.style.alignItems = "center"
      button4.style.width = "89px"
      button4.style.margin = "13px"
      button4.style.cursor = "pointer"
      // button4.addEventListener("click", async() => await checkAndProceed("/felix/shs/abfrage-technisches/"))

      const title4 = document.createElement("div")
      title4.textContent = "Technisches"
      button4.append(title4)

      const index4 = document.createElement("div")
      index4.textContent = "4"
      index4.style.color = "white"

      const state4 = document.createElement("div")
      state4.style.display = "flex"
      state4.style.justifyContent = "center"
      state4.style.alignItems = "center"
      state4.style.width = "55px"
      state4.style.height = "34px"
      state4.style.margin = "13px 0"
      state4.style.backgroundColor = "#11841e"
      button4.append(state4)

      state4.append(index4)

      navContainer.append(button4)


      header.append(navContainer)

      let observer = new IntersectionObserver(entries => {
        entries.forEach(entry => {
          if (entry.isIntersecting === false) {
            navContainer.style.position = "fixed"
            navContainer.style.top = "0"
            navContainer.style.left = "0"
            navContainer.style.zIndex = "1"
            navContainer.style.backgroundColor = "white"
            navContainer.style.width = "100%"
          }

          if (entry.isIntersecting === true) {
            navContainer.style.position = "static"
          }

        })
      }, {threshold: 0})
      observer.observe(headerLogo)


      input?.append(header)
      return header

    }

    if (event === "header/info") {

      const header = document.createElement("div")
      header.style.fontFamily = "monospace"
      header.style.fontSize = "13px"
      header.style.position = "fixed"
      header.style.left = "0"
      header.style.bottom = "0"
      header.style.zIndex = "1"
      header.style.maxWidth = "100%"
      header.style.maxHeight = "21px"
      header.style.overflow = "auto"
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        header.style.boxShadow = this.colors.dark.boxShadow
        header.style.border = this.colors.dark.border
        header.style.backgroundColor = this.colors.dark.foreground
        header.style.color = this.colors.dark.text
      } else {
        header.style.boxShadow = this.colors.light.boxShadow
        header.style.border = this.colors.light.border
        header.style.backgroundColor = this.colors.light.foreground
        header.style.color = this.colors.light.text
      }
      input?.append(header)
      return header

    }

    if (event === "header/nav") {

      const header = document.createElement("div")
      header.style.display = "flex"
      header.style.justifyContent = "space-around"
      header.style.alignItems = "center"
      header.style.boxShadow = "0 3px 5px rgba(0, 0, 0, 0.13)"

      header.nav = document.createElement("div")
      header.nav.style.display = "flex"
      header.nav.style.flexDirection = "column"
      header.nav.style.alignItems = "center"
      header.nav.style.width = "89px"
      header.nav.style.cursor = "pointer"
      header.append(header.nav)

      header.nav.text = document.createElement("div")
      header.nav.text.textContent = "Mein Link"
      header.nav.append(header.nav.text)

      header.nav.state = document.createElement("div")
      header.nav.state.style.display = "flex"
      header.nav.state.style.justifyContent = "center"
      header.nav.state.style.alignItems = "center"
      header.nav.state.style.width = "55px"
      header.nav.state.style.height = "34px"
      header.nav.state.style.margin = "13px 0"
      header.nav.state.style.backgroundColor = "#cfd4e2"
      header.nav.append(header.nav.state)

      header.nav.state.index = document.createElement("div")
      header.nav.state.index.textContent = "1"
      header.nav.state.index.style.color = "white"
      header.nav.state.append(header.nav.state.index)

      if (input !== undefined) input.append(header)
      return header
    }

    if (event === "header/left-right") {

      const header = document.createElement("div")
      header.style.display = "flex"
      header.style.justifyContent = "space-between"
      header.style.alignItems = "center"
      // header.style.boxShadow = "0 3px 5px rgba(0, 0, 0, 0.13)"

      header.left = document.createElement("div")
      header.left.classList.add("left")
      header.left.style.margin = "21px 34px"
      header.left.style.width = "55px"
      header.append(header.left)

      header.left.image = document.createElement("img")
      header.left.image.src = "https://bafybeiefo3y5hr4yb7gad55si2x6ovvoqteqlbxaoqyvlc37bm2ktrruu4.ipfs.nftstorage.link"
      header.left.image.alt = "Mein Logo"
      header.left.image.style.width = "100%"
      header.left.append(header.left.image)

      header.right = document.createElement("div")
      header.right.classList.add("right")
      header.right.style.margin = "21px 34px"
      header.right.textContent = "Login"
      header.append(header.right)

      if (input !== undefined) input.append(header)
      return header
    }

    if (event === "header/right") {

      const header = document.createElement("div")
      header.classList.add("header")
      header.style.display = "flex"
      header.style.justifyContent = "flex-end"

      header.right = document.createElement("div")
      header.right.classList.add("right")
      header.right.style.margin = "21px 34px"
      header.right.textContent = "Login"
      header.append(header.right)

      if (input !== undefined) input.append(header)
      return header
    }

    if (event === "header/left") {

      const header = document.createElement("header")
      header.style.display = "flex"
      header.style.boxShadow = "0 3px 5px rgba(0, 0, 0, 0.13)"
      header.left = document.createElement("div")
      header.left.classList.add("left")
      header.left.style.margin = "21px 34px"
      header.left.style.width = "55px"
      header.append(header.left)
      header.left.image = document.createElement("img")
      header.left.image.classList.add("logo")
      header.left.image.src = "/public/image.svg"
      header.left.image.alt = "Mein Logo"
      header.left.image.style.width = "100%"
      header.left.append(header.left.image)
      input?.append(header)
      return header

    }

    if (event === "div/timer") {

      var timer = duration, minutes, seconds
      const timerDiv = document.createElement("div")
      const interval = setInterval(function () {
        minutes = parseInt(timer / 60, 10)
        seconds = parseInt(timer % 60, 10)

        minutes = minutes < 10 ? "0" + minutes : minutes
        seconds = seconds < 10 ? "0" + seconds : seconds

        timerDiv.textContent = minutes + ":" + seconds

        if (--timer < 0) {
          timerDiv.textContent = "pin abgelaufen"
          clearInterval(interval)
        }
      }, 1000)

      return interval
    }

    if (event === "div/item-template") {

      const item = document.createElement("div")
      item.classList.add("checklist-item")
      item.style.margin = "34px"

      const itemHeader = document.createElement("div")
      itemHeader.classList.add("item-header")
      itemHeader.style.display = "flex"
      itemHeader.style.borderTopRightRadius = "21px"
      itemHeader.style.borderTopLeftRadius = "21px"
      itemHeader.style.borderBottomLeftRadius = "21px"
      itemHeader.style.backgroundColor = "#d1d0d0"
      itemHeader.style.cursor = "pointer"

      const itemState = document.createElement("div")
      itemState.classList.add("item-state")
      itemState.style.display = "flex"
      itemState.style.justifyContent = "center"
      itemState.style.alignItems = "center"
      itemState.style.width = "89px"
      itemState.style.height = "89px"
      itemState.style.backgroundColor = "#c6c6c6"
      itemState.style.fontSize = "34px"

      itemState.style.borderTopLeftRadius = "21px"
      itemState.style.borderBottomLeftRadius = "21px"

      const itemIndex = document.createElement("div")
      itemIndex.classList.add("item-index")
      itemIndex.textContent = "client.reputation"
      itemIndex.style.fontSize = "21px"

      itemState.append(itemIndex)


      const itemTitle = document.createElement("div")
      itemTitle.classList.add("item-title")
      itemTitle.style.alignSelf = "center"
      itemTitle.style.marginLeft = "13px"
      itemTitle.textContent = "`${client.firstname} ${client.lastname}`"
      itemTitle.style.fontSize = "21px"

      itemHeader.append(itemState, itemTitle)
      item.append(itemHeader)


      const itemBody = document.createElement("div")
      itemBody.classList.add("item-body")
      itemBody.style.marginLeft = "8%"
      itemBody.style.backgroundColor = "#dbdbdb"
      itemBody.style.borderBottomRightRadius = "21px"
      itemBody.style.borderBottomLeftRadius = "21px"
      itemBody.style.padding = "21px"
      itemBody.style.display = "flex"
      itemBody.style.flexDirection = "column"
      itemBody.style.boxShadow = "0 3px 5px rgba(0, 0, 0, 0.13)"

      const buttons = document.createElement("div")
      buttons.style.display = "flex"
      buttons.style.alignItems = "center"

      {
        const button = document.createElement("img")
        button.src = "/public/phone-out.svg"
        button.alt = "Anrufen"
        button.style.width = "55px"
        button.style.padding = "13px"
        button.style.cursor = "pointer"
        buttons.append(button)
      }

      {
        const button = document.createElement("img")
        button.src = "/public/mailto.svg"
        button.alt = "E-Mail schreiben"
        button.style.width = "55px"
        button.style.padding = "13px"
        button.style.cursor = "pointer"
        buttons.append(button)
      }

      {
        const button = document.createElement("img")
        button.src = "/public/maps.svg"
        button.alt = "Navigieren"
        button.style.width = "55px"
        button.style.padding = "13px"
        button.style.cursor = "pointer"
        buttons.append(button)
      }

      itemBody.append(buttons)
      item.append(itemBody)

      input?.append(item)
      return item


    }

    if (event === "div/offer-template") {

      const div = this.create("div/scrollable")
      console.log(div);

      const offer = document.createElement("div")
      offer.style.backgroundColor = "white"
      offer.style.borderRadius = "13px"
      offer.style.margin = "34px"
      offer.style.padding = "34px"
      offer.style.boxShadow = "0 3px 6px rgba(0, 0, 0, 0.16)"

      const alignLogo = document.createElement("div")
      alignLogo.style.display = "flex"
      alignLogo.style.justifyContent = "flex-end"

      const logo = document.createElement("img")
      logo.src = "/public/image-placeholder.svg"
      logo.alt = "Bestprime Logo"
      logo.style.width = "55vw"
      logo.style.maxWidth = "377px"

      alignLogo.append(logo)

      offer.append(alignLogo)

      const company = document.createElement("div")
      company.textContent = "offers[i].producer.company"
      company.style.margin = "21px 0"
      company.style.fontSize = "21px"

      offer.append(company)

      const website = document.createElement("div")
      website.style.display = "flex"
      website.style.alignItems = "center"

      const websiteIcon = document.createElement("img")
      websiteIcon.src = "/felix/shs/public/website-icon.svg"
      websiteIcon.alt = "Website Icon"

      const websiteText = document.createElement("a")
      websiteText.textContent = "Website"
      websiteText.href = "offers[i].producer.website"
      websiteText.target = "_blank"
      websiteText.style.textDecoration = "underline"
      websiteText.style.margin = "8px"
      websiteText.style.cursor = "pointer"

      website.append(websiteIcon, websiteText)

      offer.append(website)


      const product = document.createElement("div")
      product.textContent = "offers[i].producer.product"
      product.style.marginTop = "34px"
      product.style.fontSize = "21px"


      offer.append(product)


      const description = document.createElement("div")
      description.textContent = "offers[i].producer.description"
      description.style.marginTop = "13px"

      offer.append(description)


      const alignContainer = document.createElement("div")
      alignContainer.style.display = "flex"
      alignContainer.style.justifyContent = "flex-end"

      const priceContainer = document.createElement("div")
      priceContainer.style.width = "300px"
      priceContainer.style.marginTop = "21px"

      const priceTitle = document.createElement("div")
      priceTitle.textContent = "Preisübersicht"
      priceTitle.style.fontSize = "21px"
      priceTitle.style.margin = "21px 0"


      priceContainer.append(priceTitle)

      const netContainer = document.createElement("div")
      netContainer.style.display = "flex"
      netContainer.style.justifyContent = "space-between"
      netContainer.style.margin = "13px 0"

      const priceNetTitle = document.createElement("div")
      priceNetTitle.textContent = "Nettobetrag"

      const priceNetAmount = document.createElement("div")
      priceNetAmount.textContent = "netto price"// `${offers[i].grossAmount.toFixed(2).replace(".", ",")} €`

      netContainer.append(priceNetTitle, priceNetAmount)

      priceContainer.append(netContainer)



      const vatContainer = document.createElement("div")
      vatContainer.style.display = "flex"
      vatContainer.style.justifyContent = "space-between"
      vatContainer.style.margin = "13px 0"


      const priceVatTitle = document.createElement("div")
      priceVatTitle.textContent = "vat price" // `USt. ${(offers[i].vat * 100).toFixed(2).replace(".", ",")} %`

      const priceVatAmount = document.createElement("div")
      priceVatAmount.textContent = "vat price amount" // `${(offers[i].grossAmount * 0.19).toFixed(2).replace(".", ",")} €`

      vatContainer.append(priceVatTitle, priceVatAmount)

      priceContainer.append(vatContainer)

      const line = document.createElement("hr")

      priceContainer.append(line)


      const grossContainer = document.createElement("div")
      grossContainer.style.display = "flex"
      grossContainer.style.justifyContent = "space-between"
      grossContainer.style.margin = "21px 0"

      const priceGrossTitle = document.createElement("div")
      priceGrossTitle.textContent = "Gesamt"

      const priceGrossAmount = document.createElement("div")
      priceGrossAmount.textContent = "gross amount" // `${(offers[i].grossAmount * 1.19).toFixed(2).replace(".", ",")} €`

      grossContainer.append(priceGrossTitle, priceGrossAmount)

      priceContainer.append(grossContainer)


      const button = document.createElement("div")
      button.textContent = "Weiter zum Angebot"
      button.style.marginTop = "34px"
      button.style.height = "55px"
      button.style.backgroundColor = "#f7aa20"
      button.style.borderRadius = "13px"
      button.style.display = "flex"
      button.style.justifyContent = "center"
      button.style.alignItems = "center"
      button.style.cursor = "pointer"
      button.addEventListener("mouseover", () => button.style.backgroundColor = "#f19d08")
      button.addEventListener("mouseout", () => button.style.backgroundColor = "#f7aa20")

      // button.addEventListener("click", () => {
      //
      //   for (let i = 0; i < offers.length; i++) {
      //     offers[i].selected = false
      //   }
      //
      //   offers[i].selected = true
      //   window.localStorage.setItem("offers", JSON.stringify(offers))
      //   window.location.assign("/felix/shs/abfrage-persoenliches/")
      // })

      priceContainer.append(button)
      alignContainer.append(priceContainer)
      offer.append(alignContainer)
      div.append(offer)

      input?.append(div)
      return div

    }

    if (event === "div/bottom-left") {

      const div = document.createElement("div")
      div.style.fontFamily = "monospace"
      div.style.fontSize = "13px"
      div.style.position = "fixed"
      div.style.left = "0"
      div.style.bottom = "0"
      div.style.zIndex = "1"
      div.style.maxWidth = "100%"
      div.style.maxHeight = "21px"
      div.style.overflow = "auto"

      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        div.style.boxShadow = this.colors.dark.boxShadow
        div.style.border = this.colors.dark.border
        div.style.backgroundColor = this.colors.dark.foreground
        div.style.color = this.colors.dark.text
      } else {
        div.style.boxShadow = this.colors.light.boxShadow
        div.style.border = this.colors.light.border
        div.style.backgroundColor = this.colors.light.foreground
        div.style.color = this.colors.light.text
      }

      if (input !== undefined) input.append(div)
      return div
    }

    if (event === "div/progress-bar") {

      const progress = document.createElement("div")
      progress.classList.add("progress-container")
      progress.style.display = "flex"
      progress.style.height = "21px"
      progress.style.margin = "21px"
      progress.style.position = "relative"
      input?.append(progress)

      progress.bar = document.createElement("div")
      progress.bar.classList.add("progress-bar")
      progress.bar.style.height = "21px"
      progress.bar.style.backgroundColor = "#4CAF50"
      progress.bar.style.width = "0%"
      progress.bar.style.position = "absolute"
      progress.bar.style.transition = "width 0.3s ease"
      progress.append(progress.bar)

      return progress

    }

    if (event === "div/top-bottom") {

      const field = document.createElement("div")
      field.style.position = "relative"
      field.style.borderRadius = "13px"
      field.style.display = "flex"
      field.style.flexDirection = "column"
      field.style.margin = "34px"
      field.style.justifyContent = "center"

      field.top = document.createElement("div")
      field.top.classList.add("top")
      field.top.style.display = "flex"
      field.top.style.alignItems = "center"
      field.top.style.margin = "21px 89px 0 34px"
      field.append(field.top)

      field.bottom = document.createElement("div")
      field.bottom.classList.add("bottom")
      field.bottom.type = "text"
      field.bottom.style.margin = "21px 89px 21px 34px"
      field.bottom.style.fontSize = "21px"
      field.append(field.bottom)

      field.style.backgroundColor = this.colors.light.foreground
      field.style.border = this.colors.light.border
      field.style.boxShadow = this.colors.light.boxShadow
      field.style.color = this.colors.light.text
      field.bottom.style.backgroundColor = this.colors.light.background
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        field.style.backgroundColor = this.colors.dark.foreground
        field.style.border = this.colors.dark.border
        field.style.boxShadow = this.colors.dark.boxShadow
        field.style.color = this.colors.dark.text
        field.bottom.style.backgroundColor = this.colors.dark.background
      }

      if (input !== undefined) input.append(field)
      return field
    }

    if (event === "div/match-maker-list") {

      return new Promise(async(resolve, reject) => {
        try {

          const sorted = input.list
          sorted.sort((a, b) => {
            return b.reputation - a.reputation // Descending order, for ascending use: a.reputation - b.reputation
          })

          const userList = this.create("div/scrollable")
          userList.setAttribute("id", `match-maker-list-${input.name}`)

          const matchMaker = document.querySelector(`[match-maker="${input.name}"]`)

          if (matchMaker !== null) {

            const tags = []
            matchMaker.querySelectorAll("*").forEach(element => {
              if (element.hasAttribute("user-data")) {
                tags.push(element.getAttribute("user-data"))
              }
            })

            const ids = []
            for (let i = 0; i < sorted.length; i++) {
              const map = sorted[i]

              const clone = document.createElement("div")
              clone.textContent = matchMaker.textContent
              clone.setAttribute("id", map.id)
              clone.setAttribute("style", this.convert("styles/text", matchMaker))

              ids.push(map.id)

              Object.entries(map.funnel).forEach(([key, value]) => {
                clone.querySelectorAll(`.${key}`).forEach(element => {

                  if (element.tagName === "IMG") {
                    element.src = value
                  } else {
                    element.textContent = value
                  }

                })

              })

              userList.append(clone)

            }

            const res = await this.request("/get/location/lists/", {tags, ids})
            if (res.status === 200) {
              const data = JSON.parse(res.response)

              for (let i = 0; i < userList.children.length; i++) {
                const child = userList.children[i]


                Object.entries(data).forEach(([key, value]) => {

                  if (child.id === key) {

                    Object.entries(value).forEach(([key, value]) => {

                      child.querySelectorAll("[user-data]").forEach(element => {
                        if (element.getAttribute("user-data") === key) {

                          if (element.tagName === "IMG") {
                            element.src = value
                          } else {
                            element.textContent = value
                          }

                        }
                      })

                    })

                  }

                })

              }

            }

            const userLists = document.querySelectorAll(`#match-maker-list-${input.name}`)

            if (userLists.length === 0) {
              matchMaker.before(userList)
              matchMaker.style.display = "none"
            }

            if (userList.children.length === 0) {
              this.convert("parent/info", userList)
              userList.textContent = "Keine Daten gefunden."
              throw new Error("list is empty")
            }

            resolve(userList)

          }

        } catch (error) {
          reject(error)
        }
      })


    }

    if (event === "div/key-value") {

      const div = document.createElement("div")
      div.classList.add("key-value")
      div.style.display = "flex"
      div.style.justifyContent = "space-between"
      div.style.width = "144px"
      div.key = document.createElement("div")
      div.key.classList.add("key")
      div.key.textContent = "Schlüssel:"
      div.key.style.fontFamily = "sans-serif"
      div.append(div.key)
      div.value = document.createElement("div")
      div.value.classList.add("value")
      div.value.textContent = "Wert"
      div.value.style.fontFamily = "sans-serif"
      div.value.style.fontWeight = "bold"
      div.append(div.value)
      input?.appendChild(div)
      return div

    }

    if (event === "div/image") {
      const div = document.createElement("div")
      div.className = "image"
      div.style.width = "144px"
      div.image = document.createElement("img")
      div.image.src = input
      div.image.style.width = "100%"
      div.appendChild(div.image)
      return div
    }

    if (event === "div/image-text") {
      const div = document.createElement("div")
      div.classList.add("image-text")
      div.style.display = "flex"
      div.style.flexDirection = "column"
      div.style.alignItems = "center"
      div.image = document.createElement("img")
      div.image.src = "/public/image.svg"
      div.image.style.width = "144px"
      div.appendChild(div.image)
      div.text = document.createElement("p")
      div.text.textContent = "Titel"
      div.text.style.fontFamily = "sans-serif"
      div.text.style.fontWeight = "bold"
      div.appendChild(div.text)
      input?.appendChild(div)
      return div
    }

    if (event === "div/flex") {

      const div = document.createElement("div")
      div.style.display = "flex"
      div.style.flexWrap = "wrap"
      div.style.margin = "21px 34px"
      input?.appendChild(div)
      return div
    }

    if (event === "div/flex-between") {

      const div = document.createElement("div")
      div.style.display = "flex"
      div.style.flexWrap = "wrap"
      div.style.justifyContent = "space-between"
      div.style.margin = "21px 34px"
      input?.appendChild(div)
      return div
    }

    if (event === "div/flex-row") {
      const div = document.createElement("div")
      div.style.display = "flex"
      div.style.justifyContent = "space-around"
      div.style.flexWrap = "wrap"
      div.style.margin = "21px 34px"

      if (input !== undefined) input.append(div)

      return div
    }

    if (event === "div/box-overview") {

      const offer = document.createElement("div")
      offer.classList.add("box")
      offer.style.backgroundColor = "white"
      offer.style.borderRadius = "13px"
      offer.style.margin = "34px"
      offer.style.padding = "34px"
      offer.style.boxShadow = "0 3px 6px rgba(0, 0, 0, 0.16)"

      const alignLogo = document.createElement("div")
      alignLogo.classList.add("image-container")
      alignLogo.style.display = "flex"
      alignLogo.style.justifyContent = "flex-end"

      const logo = document.createElement("img")
      logo.classList.add("image")
      logo.src = "meine-quell-url.de"
      logo.alt = "Mein Logo Image"
      logo.style.width = "55vw"
      logo.style.maxWidth = "377px"

      alignLogo.append(logo)

      offer.append(alignLogo)

      const company = document.createElement("div")
      company.classList.add("company")
      company.textContent = "Meine Firma"
      company.style.margin = "21px 0"
      company.style.fontSize = "21px"

      offer.append(company)

      const website = document.createElement("div")
      website.style.display = "flex"
      website.style.alignItems = "center"

      const websiteIcon = document.createElement("img")
      websiteIcon.src = "mein-icon-url.de"
      websiteIcon.alt = "Website Icon"

      const websiteText = document.createElement("a")
      websiteText.textContent = "Website"
      websiteText.href = "www.website.de"
      websiteText.target = "_blank"
      websiteText.style.textDecoration = "underline"
      websiteText.style.margin = "8px"
      websiteText.style.cursor = "pointer"

      website.append(websiteIcon, websiteText)

      offer.append(website)


      const product = document.createElement("div")
      product.textContent = "Produkt Titel"
      product.style.marginTop = "34px"
      product.style.fontSize = "21px"


      offer.append(product)


      const description = document.createElement("div")
      description.textContent = "Produktbeschreibung"
      description.style.marginTop = "13px"

      offer.append(description)


      const alignContainer = document.createElement("div")
      alignContainer.style.display = "flex"
      alignContainer.style.justifyContent = "flex-end"

      const priceContainer = document.createElement("div")
      priceContainer.style.width = "300px"
      priceContainer.style.marginTop = "21px"

      const priceTitle = document.createElement("div")
      priceTitle.textContent = "Preisübersicht"
      priceTitle.style.fontSize = "21px"
      priceTitle.style.margin = "21px 0"


      priceContainer.append(priceTitle)

      const netContainer = document.createElement("div")
      netContainer.style.display = "flex"
      netContainer.style.justifyContent = "space-between"
      netContainer.style.margin = "13px 0"

      const priceNetTitle = document.createElement("div")
      priceNetTitle.textContent = "Nettobetrag"

      const priceNetAmount = document.createElement("div")
      priceNetAmount.textContent = `100 €`

      netContainer.append(priceNetTitle, priceNetAmount)

      priceContainer.append(netContainer)



      const vatContainer = document.createElement("div")
      vatContainer.style.display = "flex"
      vatContainer.style.justifyContent = "space-between"
      vatContainer.style.margin = "13px 0"


      const priceVatTitle = document.createElement("div")
      priceVatTitle.textContent = `USt. 19 %`

      const priceVatAmount = document.createElement("div")
      priceVatAmount.textContent = `10 €`

      vatContainer.append(priceVatTitle, priceVatAmount)

      priceContainer.append(vatContainer)

      const line = document.createElement("hr")

      priceContainer.append(line)


      const grossContainer = document.createElement("div")
      grossContainer.style.display = "flex"
      grossContainer.style.justifyContent = "space-between"
      grossContainer.style.margin = "21px 0"

      const priceGrossTitle = document.createElement("div")
      priceGrossTitle.textContent = "Gesamt"

      const priceGrossAmount = document.createElement("div")
      priceGrossAmount.classList.add("price")
      priceGrossAmount.textContent = `10€`

      grossContainer.append(priceGrossTitle, priceGrossAmount)

      priceContainer.append(grossContainer)


      const button = document.createElement("div")
      button.classList.add("submit")
      button.textContent = "Weiter zum Angebot"
      button.style.marginTop = "34px"
      button.style.height = "55px"
      button.style.backgroundColor = "#f7aa20"
      button.style.borderRadius = "13px"
      button.style.display = "flex"
      button.style.justifyContent = "center"
      button.style.alignItems = "center"
      button.style.cursor = "pointer"
      button.addEventListener("mouseover", () => button.style.backgroundColor = "#f19d08")
      button.addEventListener("mouseout", () => button.style.backgroundColor = "#f7aa20")

      priceContainer.append(button)
      alignContainer.append(priceContainer)
      offer.append(alignContainer)
      //div.append(offer)

      if (input !== undefined) input.append(offer)

      return offer



    }

    if (event === "div/user-list") {

      return new Promise(async(resolve, reject) => {
        try {

          const userList = document.createElement("div")
          userList.classList.add("user-list")
          document.querySelectorAll(`[match-maker="${parent}"]`).forEach(matchMaker => {

            for (let i = 0; i < input.length; i++) {
              const mirror = input[i]

              const clone = document.createElement("div")
              clone.textContent = matchMaker.textContent
              clone.classList.add(`user-${i + 1}`)

              for (let i = 0; i < mirror.treeValues.length; i++) {
                const treeValuePair = mirror.treeValues[i]
                clone.querySelectorAll(`#${treeValuePair.tree}`).forEach(container => {
                  container.textContent = treeValuePair.value
                })
              }

              userList.append(clone.cloneNode())

            }

          })
          console.log("inside promise", userList);

          // resolve(userList)

        } catch (error) {
          reject(error)
        }
      })


    }

    if (event === "div/action") {
      const div = document.createElement("div")

      div.style.backgroundColor = this.colors.matte.sunflower
      div.style.color = this.colors.matte.black
      div.style.boxShadow = this.colors.light.boxShadow
      div.style.cursor = "pointer"
      div.style.fontSize = "21px"
      div.style.fontFamily = "sans-serif"
      div.style.borderRadius = "13px"
      div.style.margin = "21px 34px"
      div.style.display = "flex"
      div.style.justifyContent = "center"
      div.style.alignItems = "center"
      div.style.height = "55px"
      div.style.width = "89px"

      if (input !== undefined) input.append(div)
      return div
    }

    if (event === "div") {
      const div = document.createElement("div")
      input?.appendChild(div)
      return div
    }

    if (event === "div/green-flag") {

      const div = document.createElement("div")
      div.style.width = "34px"
      div.style.padding = "8px 34px"
      div.style.display = "flex"
      div.style.justifyContent = "center"
      div.style.alignItems = "center"
      div.style.borderRadius = "13px"
      div.style.background = "green"
      input?.appendChild(div)
      return div

    }

    if (event === "div/red-flag") {

      const div = document.createElement("div")
      div.style.width = "34px"
      div.style.padding = "8px 34px"
      div.style.display = "flex"
      div.style.justifyContent = "center"
      div.style.alignItems = "center"
      div.style.borderRadius = "13px"
      div.style.background = "red"
      input?.appendChild(div)
      return div

    }

    if (event === "div/overlay") {
      const div = document.createElement("div")
      div.classList.add("overlay")
      div.style.display = "flex"
      div.style.flexDirection = "column"
      div.style.height = "100%"
      div.style.width = "100%"
      div.style.zIndex = Number.MAX_SAFE_INTEGER.toString()
      div.style.overscrollBehavior = "none"
      div.style.position = "fixed"
      div.style.top = "0"
      div.style.left = "0"
      div.style.background = this.colors.light.background
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        div.style.background = this.colors.dark.background
      }
      input?.append(div)
      return div
    }

    if (event === "div/scrollable") {
      const div = document.createElement("div")
      div.style.overflowY = "auto"
      div.style.overscrollBehavior = "none"
      div.style.paddingBottom = "144px"

      if (input !== undefined) input.append(div)

      return div
    }

    if (event === "div/service-box") {

      const div = document.createElement("div")
      div.className = "service-box"
      div.style.display = "flex"
      div.style.flexWrap = "wrap"
      div.style.margin = "21px 34px"
      div.style.padding = "8px"
      div.style.borderRadius = "3px"
      div.style.boxShadow = "rgba(0, 0, 0, 0.16) 0px 1px 4px"

      const checkboxWrapper = document.createElement("div")
      checkboxWrapper.className = "checkbox-wrapper"
      checkboxWrapper.style.width = "89px"
      checkboxWrapper.style.display = "flex"
      checkboxWrapper.style.justifyContent = "center"
      checkboxWrapper.style.alignItems = "center"
      div.checkbox = document.createElement("input")
      div.checkbox.type = "checkbox"
      div.checkbox.style.transform = "scale(2)"
      checkboxWrapper.append(div.checkbox)
      div.append(checkboxWrapper)

      div.service = document.createElement("div")
      div.service.className = "service"
      div.service.style.minWidth = "233px"
      div.service.style.display = "flex"
      div.service.style.flexDirection = "column"
      div.service.style.margin = "21px 34px"
      div.service.style.fontSize = "21px"
      div.service.style.fontFamily = "sans-serif"
      div.service.style.flex = "1 1 0px"
      div.appendChild(div.service)

      div.quantity = document.createElement("div")
      div.quantity.className = "quantity"
      div.quantity.style.fontFamily = "sans-serif"
      div.quantity.style.fontSize = "34px"
      div.quantity.style.display = "flex"
      div.quantity.style.alignItems = "center"
      div.quantity.style.justifyContent = "flex-end"
      div.quantity.style.margin = "21px 34px"
      div.appendChild(div.quantity)

      div.singlePrice = document.createElement("div")
      div.singlePrice.className = "single-price"
      div.singlePrice.style.width = "233px"
      div.singlePrice.style.fontFamily = "sans-serif"
      div.singlePrice.style.fontSize = "34px"
      div.singlePrice.style.display = "flex"
      div.singlePrice.style.alignItems = "center"
      div.singlePrice.style.justifyContent = "flex-end"
      div.singlePrice.style.margin = "21px 34px"
      div.appendChild(div.singlePrice)

      div.totalPrice = document.createElement("div")
      div.totalPrice.className = "total-price"
      div.totalPrice.style.width = "233px"
      div.totalPrice.style.fontFamily = "sans-serif"
      div.totalPrice.style.fontSize = "34px"
      div.totalPrice.style.display = "flex"
      div.totalPrice.style.alignItems = "center"
      div.totalPrice.style.justifyContent = "flex-end"
      div.totalPrice.style.margin = "21px 34px"
      div.appendChild(div.totalPrice)

      input?.append(div)
      return div
    }

    if (event === "div/video") {

      const fragment = document.createDocumentFragment()
      const div = document.createElement("div")
      fragment.appendChild(div)
      div.style.display = "flex"
      div.video = document.createElement("video")
      div.appendChild(div.video)
      div.video.style.width = "100%"
      div.video.autoplay = true
      input?.appendChild(fragment)
      return div
    }

    if (event === "back-button") {

      const button = this.create("button/bottom-left")
      button.classList.add("back")
      this.render("icon/node/path", "/public/arrow-back.svg", button).then(icon => {
        this.convert("dark-light", button)
      })
      button.setAttribute("onclick", "window.goBack()")

      let exist = false
      document.querySelectorAll("*").forEach(node => {
        if (node.classList.contains("back") && node.classList.contains("button")) {
          exist = true
        }
      })
      if (exist === false) input?.appendChild(button)

      const backButton = document.querySelector("div.back.button")
      this.add("outline-hover", backButton)

      return button
    }

    if (event === "box") {

      const box = document.createElement("span")
      this.convert("parent/box", box)
      input?.appendChild(box)
      return box
    }

    if (event === "button/key-value-color") {

      const button = this.create("div")
      button.classList.add("color")
      button.style.display = "flex"
      button.style.flexDirection = "column"
      button.style.justifyContent = "space-between"
      button.style.fontFamily = "sans-serif"
      button.style.width = "89px"
      button.style.height = "55px"
      button.style.margin = "3px"
      button.style.overflow = "auto"
      button.style.padding = "5px"
      button.style.cursor = "pointer"
      button.style.borderRadius = "3px"
      button.style.backgroundColor = input.value

      button.key = this.create("div", button)
      button.key.classList.add("key")
      button.key.style.color = this.colors.light.text
      button.key.textContent = input.key

      button.value = this.create("div", button)
      button.value.classList.add("value")
      button.value.style.fontFamily = "monospace"
      button.value.style.color = this.colors.dark.text
      button.value.textContent = input.value

      return button
    }

    if (event === "button/thumb-down") {

      const button = document.createElement("div")
      button.textContent = "👎"
      button.style.display = "flex"
      button.style.justifyContent = "center"
      button.style.alignItems = "center"
      button.style.width = "89px"
      button.style.height = "55px"
      button.style.background = "rgb(204,50,50)"
      button.style.borderRadius = "8px"
      button.style.fontSize = "21px"

      input?.append(button)
      return button
    }

    if (event === "button/thumb-up") {

      const button = document.createElement("div")
      button.textContent = "👍"
      button.style.background = "rgb(45,201,55)"
      button.style.display = "flex"
      button.style.justifyContent = "center"
      button.style.alignItems = "center"
      button.style.height = "55px"
      button.style.width = "89px"
      button.style.color = "white"
      button.style.borderRadius = "8px"
      button.style.fontSize = "21px"

      input?.append(button)
      return button
    }

    if (event === "button/bottom-left") {

      const button = document.createElement("div")
      button.className = "button"
      button.style.position = "fixed"
      button.style.bottom = "0"
      button.style.left = "0"
      button.style.width = "34px"
      button.style.height = "34px"
      button.style.borderRadius = "50%"
      button.style.margin = "34px"
      button.style.padding = "21px"
      button.style.zIndex = "1"
      button.style.cursor = "pointer"
      // convert dark light reverse
      // this.convert("light")
      // this.convert("dark-light", button)
      input?.appendChild(button)
      return button
    }

    if (event === "button/bottom-right") {

      const button = document.createElement("div")
      button.className = "button"
      button.style.position = "fixed"
      button.style.bottom = "0"
      button.style.right = "0"
      button.style.width = "34px"
      button.style.height = "34px"
      button.style.borderRadius = "50%"
      button.style.margin = "34px"
      button.style.padding = "21px"
      button.style.zIndex = "1"
      button.style.cursor = "pointer"
      button.style.boxShadow = this.colors.light.boxShadow
      button.style.border = this.colors.light.border
      button.style.backgroundColor = this.colors.light.foreground
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        button.style.boxShadow = this.colors.dark.boxShadow
        button.style.border = this.colors.dark.border
        button.style.backgroundColor = this.colors.dark.foreground
      }
      input?.appendChild(button)
      return button

    }

    if (event === "button/icon") {

      const button = this.create("div")
      button.classList.add("button")
      button.style.display = "flex"
      button.style.justifyContent = "center"
      button.style.alignItems = "center"
      button.style.width = "55px"
      button.style.height = "55px"
      button.style.margin = "21px"
      button.style.padding = "13px"
      button.style.cursor = "pointer"
      button.style.borderRadius = "13px"
      button.style.boxShadow = this.colors.light.boxShadow
      button.style.border = this.colors.light.border
      button.style.backgroundColor = this.colors.light.foreground
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        button.style.boxShadow = this.colors.dark.boxShadow
        button.style.border = this.colors.dark.border
        button.style.backgroundColor = this.colors.dark.foreground
      }
      input?.appendChild(button)
      return button

    }

    if (event === "button/icon-text") {

      const button = document.createElement("div")
      button.style.display = "flex"
      button.style.flexDirection = "column"
      button.style.justifyContent = "center"
      button.style.alignItems = "center"
      button.style.cursor = "pointer"
      button.style.borderRadius = "50%"
      button.style.width = "144px"
      button.style.height = "144px"
      button.style.background = this.colors.light.foreground
      button.style.border = this.colors.light.border
      button.style.boxShadow = this.colors.light.boxShadow
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        button.style.background = this.colors.dark.foreground
        button.style.border = this.colors.dark.border
        button.style.boxShadow = this.colors.dark.boxShadow
      }
      button.icon = document.createElement("div")
      button.icon.classList.add("icon")
      button.icon.style.width = "55px"
      button.append(button.icon)
      button.text = document.createElement("div")
      button.text.classList.add("text")
      button.text.style.fontFamily = "sans-serif"
      button.text.style.fontSize = "21px"
      button.text.style.margin = "13px"
      button.text.style.color = this.colors.light.text
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        button.text.style.color = this.colors.dark.text
      }
      button.append(button.text)
      input?.append(button)
      return button

    }

    if (event === "button/image-text") {

      const button = this.create("button/top-bottom")
      button.image = document.createElement("img")
      button.image.style.width = "100%"
      button.image.className = "image"
      button.image.src = "/public/image.svg"
      button.top.appendChild(button.image)
      button.text = this.create("div", button.bottom)
      button.text.style.margin = "21px 34px"
      button.text.style.fontSize = "21px"
      button.text.style.fontFamily = "sans-serif"
      input?.appendChild(button)
      return button
    }

    if (event === "button/getyour") {

      const button = this.create("button/bottom-right")
      this.render("icon/node/path", "/public/logo-getyour-red.svg", button)
      input?.append(button)
      return button

    }

    if (event === "button/add") {

      const button = this.create("button/bottom-right")
      this.render("icon/node/path", "/public/add.svg", button)
      input?.appendChild(button)
      return button
    }

    if (event === "button/action") {
      const div = document.createElement("div")
      div.className = "button"
      div.style.backgroundColor = this.colors.matte.sunflower
      div.style.color = this.colors.matte.black
      div.style.boxShadow = this.colors.light.boxShadow
      div.style.cursor = "pointer"
      div.style.fontSize = "21px"
      div.style.fontFamily = "sans-serif"
      div.style.borderRadius = "13px"
      div.style.margin = "21px 34px"
      div.style.display = "flex"
      div.style.justifyContent = "center"
      div.style.alignItems = "center"
      div.style.height = "89px"
      input?.appendChild(div)
      return div
    }

    if (event === "button/top-bottom") {

      const button = document.createElement("div")
      button.className = "button"
      button.style.display = "flex"
      button.style.flexDirection = "column"
      button.style.margin = "21px 34px"
      button.style.borderRadius = "13px"
      button.style.overflow = "hidden"
      button.style.cursor = "pointer"
      button.top = document.createElement("div")
      button.top.classList.add("top")
      button.append(button.top)
      button.bottom = document.createElement("div")
      button.bottom.classList.add("bottom")
      button.append(button.bottom)
      button.style.backgroundColor = this.colors.gray[0]
      button.style.border = this.colors.light.border
      button.style.color = this.colors.light.text
      button.style.boxShadow = this.colors.light.boxShadow
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        button.style.backgroundColor = this.colors.matte.black
        button.style.border = this.colors.dark.border
        button.style.boxShadow = this.colors.dark.boxShadow
        button.style.color = this.colors.dark.text
      }
      input?.append(button)
      return button
    }

    if (event === "button/left-right") {

      const fragment = document.createDocumentFragment()
      const button = document.createElement("div")
      button.classList.add("button")
      button.left = document.createElement("div")
      button.left.classList.add("left")
      button.append(button.left)
      button.right = document.createElement("div")
      button.right.classList.add("right")
      button.append(button.right)
      this.convert("button/left-right", button)
      fragment.appendChild(button)
      input?.appendChild(fragment)
      return button
    }

    if (event === "counter") {
      input.counter = document.createElement("div")
      input.appendChild(input.counter)
      input.counter.classList.add("counter")
      input.counter.style.position = "absolute"
      input.counter.style.display = "flex"
      input.counter.style.justifyContent = "center"
      input.counter.style.alignItems = "center"
      input.counter.style.top = "-8px"
      input.counter.style.right = "-5px"
      input.counter.style.fontFamily = "monospace"
      input.counter.style.fontSize = "21px"
      input.counter.style.borderRadius = "50%"
      input.counter.style.padding = "3px 5px"
      input.counter.textContent = "0"
      this.convert("dark-light", input.counter)
      return input
    }

    if (event === "icon/branch") {

      return new Promise(async(resolve, reject) => {
        try {
          const icon = await this.convert("path/icon", "/public/branch.svg")
          icon.style.width = "55px"
          const svg = icon.firstChild
          if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            svg.children[0].setAttribute("fill", this.colors.dark.text)
            svg.children[1].setAttribute("fill", this.colors.light.text)
          } else {
            svg.children[0].setAttribute("fill", this.colors.light.text)
            svg.children[1].setAttribute("fill", this.colors.dark.text)
          }
          input?.appendChild(icon)
          resolve(icon)
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "button/html-feedback") {

      const button = document.createElement("div")
      input?.appendChild(button)
      button.classList.add("button")
      button.style.position = "fixed"
      button.style.bottom = "0"
      button.style.right = "0"
      button.style.display = "flex"
      button.style.justifyContent = "center"
      button.style.alignItems = "center"
      button.style.boxShadow = this.colors.light.boxShadow
      button.style.border = this.colors.light.border
      button.style.backgroundColor = this.colors.light.foreground
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        button.style.backgroundColor = this.colors.dark.foreground
        button.style.border = this.colors.dark.border
        button.style.boxShadow = this.colors.dark.boxShadow
      }
      button.style.borderRadius = "50%"
      button.style.margin = "34px"
      button.style.padding = "8px"
      button.style.zIndex = "1"
      button.style.cursor = "pointer"
      this.create("icon/branch", button)
      this.create("counter", button)
      return button
    }

    if (event === "button/remove-overlay") {

      const button = this.create("button/bottom-left")
      button.classList.add("back")
      return new Promise(async(resolve, reject) => {
        try {
          const icon = await this.convert("path/icon", "/public/arrow-back.svg")
          resolve((node) => {
            const clone = button.cloneNode(true)
            clone.appendChild(icon.cloneNode(true))
            this.add("outline-hover", clone)
            this.convert("back-button", clone)
            clone.onclick = () => node?.remove()
            node?.appendChild(clone)
            return clone
          })
        } catch (error) {
          reject(error)
        }
      })

    }

    if (event === "button/role-apps") {


      const button = document.createElement("div")
      button.classList.add("role-apps-button")
      button.style.position = "fixed"
      button.style.bottom = "0"
      button.style.right = "0"
      button.style.boxShadow = this.colors.light.boxShadow
      button.style.border = this.colors.light.border
      button.style.backgroundColor = this.colors.light.foreground
      button.style.width = "34px"
      button.style.height = "34px"
      button.style.borderRadius = "50%"
      button.style.margin = "34px"
      button.style.padding = "21px"
      button.style.cursor = "pointer"

      if (input !== undefined) {
        if (document.querySelector(".role-apps-button") === null) {
          input.append(button)
        }
      }

      return button
    }

    if (event === "field-funnel/login") {

      const funnel = this.create("div/scrollable")
      funnel.emailField = this.create("field/email", funnel)
      funnel.dsgvoField = this.create("field/dsgvo", funnel)
      funnel.submit = this.create("button/action", funnel)
      funnel.submit.style.fontSize = "34px"
      funnel.submit.classList.add("start-login-event")
      funnel.submit.textContent = "Jetzt anmelden"
      this.add("outline-hover", funnel.submit)
      input?.appendChild(funnel)
      return funnel

    }

    if (event === "pdf-preview") {

      return new Promise(async(resolve, reject) => {
        try {
          const pdfjs = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@4.6.82/+esm')
          pdfjs.GlobalWorkerOptions.workerSrc = "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.6.82/build/pdf.worker.min.mjs"
          const url = input
          const loadingTask = pdfjs.getDocument(url)
          const pdf = await loadingTask.promise
          const page = await pdf.getPage(1)
          const scale = 1.5
          const viewport = page.getViewport({ scale: scale })
          const canvas = document.createElement('canvas')
          const context = canvas.getContext('2d')
          canvas.height = viewport.height
          canvas.width = viewport.width
          canvas.style.width='100%'
          canvas.style.height='100%'
          const renderContext = {
            canvasContext: context,
            viewport: viewport
          }
          await page.render(renderContext).promise
          resolve(canvas)
        } catch (error) {
          reject(error)
        }
      })

    }

    if (event === "script/contact-location-expert") {

      const text = `
        <script id="contact-location-expert" type="module">
import {Helper} from "/js/Helper.js"
Helper.add("onclick/selector/contact-location-expert", ".contact-location-expert")
        </script>
      `
      const script = this.convert("text/first-child", text)
      const create = document.createElement("script")
      create.id = script.id
      create.type = script.type
      create.textContent = script.textContent
      input?.append(create)
      return create

    }

    if (event === "script/dark-light-body") {

      const text = `
        <script id="dark-light-body" type="module">
import {Helper} from "/js/Helper.js"
Helper.convert("dark-light", document.body)
        </script>
      `

      const script = this.convert("text/first-child", text)

      const create = document.createElement("script")
      create.id = script.id
      create.type = script.type
      create.textContent = script.textContent

      input?.append(create)
      return create

    }

    if (event === "script/soundbox") {

      const text = /*html*/`
        <script id="soundbox" type="module">
import {Helper} from "/js/Helper.js"

await Helper.add("event/soundbox")
        </script>
      `

      const script = this.convert("text/first-child", text)

      const create = document.createElement("script")
      create.id = script.id
      create.type = script.type
      create.textContent = script.textContent

      if (input !== undefined) input.append(create)
      return create

    }

    if (event === "script/empty-helper") {

      const text = /*html*/`
        <script id="${input.id}" type="module">
import {Helper} from "/js/Helper.js"

${input.js}

        </script>
      `

      const script = this.convert("text/first-child", text)

      const create = document.createElement("script")
      create.id = script.id
      create.type = script.type
      create.textContent = script.textContent

      return create
    }

    if (event === "script/match-maker-onload") {

      const conditionsString = JSON.stringify(input.conditions)

      const text = /*html*/`
        <script id="match-maker-onload-${input.name}" type="module">
          import {Helper} from "/js/Helper.js"

          const res = await Helper.request("/verify/match-maker/conditions/", ${conditionsString})

          if (res.status === 200) {

            ${input.js}

          }

        </script>
      `

      const script = this.convert("text/first-child", text)

      const create = document.createElement("script")
      create.id = script.id
      create.type = script.type
      create.textContent = script.textContent

      return create
    }

    if (event === "script/match-maker-onclick") {

      const conditionsString = JSON.stringify(input.conditions)

      const text = /*html*/`
        <script id="match-maker-onclick-${input.name}" type="module">
          import {Helper} from "/js/Helper.js"

          const elements = document.querySelectorAll("[match-maker='${input.name}']")

          if (elements.length === 0) throw new Error("no match maker elements found")

          const res = await Helper.request("/verify/match-maker/conditions/", ${conditionsString})

          if (res.status === 200) {

            elements.forEach(matchMaker => {
              matchMaker.onclick = async (event) => {
                ${input.js}
              }
            })

          }

        </script>
      `

      const script = this.convert("text/first-child", text)

      const create = document.createElement("script")
      create.id = script.id
      create.type = script.type
      create.textContent = script.textContent

      return create
    }

    if (event === "script/match-maker-show") {

      const conditionsString = JSON.stringify(input.conditions)

      const text = /*html*/`
        <script id="match-maker-show-${input.name}" type="module">
          import {Helper} from "/js/Helper.js"

          const elements = document.querySelectorAll("[match-maker='${input.name}']")

          if (elements.length === 0) throw new Error("no match maker elements found")

          elements.forEach(element => element.style.display = "none")

          const res = await Helper.request("/verify/match-maker/conditions/", ${conditionsString})

          if (res.status === 200) {

            elements.forEach(matchMaker => {
              matchMaker.style.display = null
            })

          }

        </script>
      `

      const script = this.convert("text/first-child", text)

      const create = document.createElement("script")
      create.id = script.id
      create.type = script.type
      create.textContent = script.textContent

      return create
    }

    if (event === "script/match-maker-get-list") {

      const conditionsString = JSON.stringify(input.conditions)

      const text = /*html*/`
        <script id="match-maker-get-list-${input.name}" type="module">
          import {Helper} from "/js/Helper.js"

          const elements = document.querySelectorAll("[match-maker='${input.name}']")

          if (elements.length === 0) throw new Error("no match maker elements found")

          const res = await Helper.request("/get/match-maker/list/", ${conditionsString}, "${input.tree}")

          if (res.status === 200) {
            const mirror = JSON.parse(res.response)
            await Helper.render("mirror/match-maker-get-list", mirror, "${input.name}")
          }

        </script>
      `

      const script = this.convert("text/first-child", text)

      const create = document.createElement("script")
      create.id = script.id
      create.type = script.type
      create.textContent = script.textContent

      return create
    }

    if (event === "script/match-maker-get-keys") {

      const conditionsString = JSON.stringify(input.conditions)
      const mirrorString = JSON.stringify(input.mirror)

      const text = /*html*/`
        <script id="match-maker-get-keys-${input.name}" type="module">
          import {Helper} from "/js/Helper.js"

          const elements = document.querySelectorAll("[match-maker='${input.name}']")

          if (elements.length === 0) throw new Error("no match maker elements found")

          const res = await Helper.request("/get/match-maker/keys/", ${conditionsString}, ${mirrorString})

          if (res.status === 200) {
            const mirror = JSON.parse(res.response)

            await Helper.render("mirror/match-maker-get-keys", mirror, "${input.name}")

          }

        </script>
      `

      const script = this.convert("text/first-child", text)

      const create = document.createElement("script")
      create.id = script.id
      create.type = script.type
      create.textContent = script.textContent

      return create
    }

    if (event === "script/match-maker-get-users") {

      const conditionsString = JSON.stringify(input.conditions)
      const mirrorString = JSON.stringify(input.mirror)

      const text = /*html*/`
        <script id="match-maker-get-users-${input.name}" type="module">
          import {Helper} from "/js/Helper.js"

          const elements = document.querySelectorAll("[match-maker='${input.name}']")

          if (elements.length === 0) throw new Error("no match maker elements found")

          const res = await Helper.request("/get/match-maker/mirror/", ${conditionsString}, ${mirrorString})
          if (res.status === 200) {
            const mirror = JSON.parse(res.response)
            await Helper.render("mirror/match-maker-get-users", mirror, "${input.name}")
          }

        </script>
      `

      const script = this.convert("text/first-child", text)

      const create = document.createElement("script")
      create.id = script.id
      create.type = script.type
      create.textContent = script.textContent

      return create
    }

    if (event === "script/match-maker-remove") {

      const conditionsString = JSON.stringify(input.conditions)

      const text = /*html*/`
        <script id="match-maker-remove-${input.name}" type="module">
          import {Helper} from "/js/Helper.js"

          const elements = document.querySelectorAll("[match-maker='${input.name}']")

          if (elements.length === 0) throw new Error("no match maker elements found")

          const res = await Helper.request("/verify/match-maker/conditions/", ${conditionsString})

          if (res.status === 200) {
            elements.forEach(element => element.remove())
          }

        </script>
      `

      const script = this.convert("text/first-child", text)

      const create = document.createElement("script")
      create.id = script.id
      create.type = script.type
      create.textContent = script.textContent

      return create
    }

    if (event === "script/click-funnel-event") {

      const text = `
        <script id="click-funnel-event" type="module">
import {Helper} from "/js/Helper.js"
await Helper.add("event/click-funnel")
        </script>
      `

      const script = this.convert("text/first-child", text)

      const create = document.createElement("script")
      create.id = script.id
      create.type = script.type
      create.textContent = script.textContent

      return create
    }

    if (event === "script") {

      const script = document.createElement("script")
      script.id = input.id
      script.type = "module"
      script.textContent = `import {Helper} from "/js/Helper.js"\nif (Helper.verifyIs("script-id/disabled", "${script.id}")) throw new Error("'script#${script.id}' disabled")\n`
      script.append(input.js)
      return script
    }

    if (event === "select/cam") {

      return new Promise(async(resolve, reject) => {
        try {
          const select = this.create("input/select")
          select.input.add(["-- Kamera auswählen"])
          const devices = await navigator.mediaDevices.enumerateDevices()
          const videoDevices = devices.filter(device => device.kind === "videoinput")
          this.add("style/not-valid", select.input)
          videoDevices.forEach((device, index) => {
            const option = document.createElement("option")
            option.value = device.deviceId
            option.textContent = device.label || `Kamera ${index + 1}`
            select.input.appendChild(option)
          })
          resolve(select)
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "toolbox/action") {

      const button = this.create("button/action")
      button.removeAttribute("class")
      this.add("outline-hover", button)
      input?.appendChild(button)
      return button
    }

    if (event === "toolbox/add") {

      const button = this.create("button/add")
      button.removeAttribute("class")
      this.add("outline-hover", button)
      this.convert("dark-light", button)
      input?.appendChild(button)
      return button
    }

    if (event === "toolbox/bottom-right") {

      const button = this.create("button/bottom-right")
      button.removeAttribute("class")
      this.add("outline-hover", button)
      this.convert("dark-light", button)
      input?.appendChild(button)
      return button
    }

    if (event === "toolbox/back") {

      const button = this.create("button/bottom-left")
      button.removeAttribute("class")
      this.render("icon/node/path", "/public/arrow-back.svg", button).then(icon => {
        this.convert("back-button", button)
        this.convert("icon/dark-light", icon)
      })
      button.setAttribute("onclick", "window.goBack()")
      this.add("outline-hover", button)
      input?.appendChild(button)
      return button
    }

    if (event === "toolbox/getyour") {

      const button = this.create("button/bottom-right")
      button.removeAttribute("class")
      this.render("icon/node/path", "/public/logo-getyour-red.svg", button)
      this.add("outline-hover", button)
      this.convert("dark-light", button)
      input?.appendChild(button)
      return button
    }

    if (event === "toolbox/icon") {

      const button = this.create("button/icon")
      button.removeAttribute("class")
      this.add("outline-hover", button)
      this.convert("dark-light", button)
      input?.appendChild(button)
      return button
    }

    if (event === "toolbox/left-right") {

      const button = this.create("button/left-right")
      button.removeAttribute("class")
      this.add("outline-hover", button)
      input?.appendChild(button)
      return button

    }

    if (event === "toolbox/register-html") {

      return new Promise(async(resolve, reject) => {
        try {
          const button = this.create("button/bottom-right")
          button.removeAttribute("class")
          const icon = await this.convert("path/icon", "/public/disk-floppy.svg")
          resolve((node) => {
            const clone = button.cloneNode(true)
            clone.appendChild(icon.cloneNode(true))
            this.convert("dark-light", clone)
            this.add("outline-hover", clone)
            clone.onclick = () => this.add("register-html")
            node?.appendChild(clone)
            return clone
          })
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "field/closed-contacts-email-select") {

      return new Promise(async(resolve, reject) => {
        try {
          const field = this.create("field/select", input)
          field.label.textContent = "Gebe einer Liste von E-Mails aus deinen Kontakten, Schreibrechte"
          const defaultOption = document.createElement("option")
          defaultOption.text = "Bitte warten.."
          field.input.appendChild(defaultOption)
          const res = await this.request("/get/user/tree-closed/", {tree: "contacts"})
          if (res.status === 200) {
            const contacts = JSON.parse(res.response)
            field.input.textContent = ""
            for (let i = 0; i < contacts.length; i++) {
              const contact = contacts[i]
              if (contact.email !== undefined) {
                const option = document.createElement("option")
                option.text = contact.email
                option.value = contact.email
                field.input.appendChild(option)
              }
            }
            resolve(field)
          }
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "field/open-expert-values-path-select") {

      return new Promise(async(resolve, reject) => {
        try {
          const field = this.create("field/select", input)
          field.label.textContent = "Wähle deinen passenden Funnel, aus Werteinheiten aller Experten"

          const defaultOption = document.createElement("option")
          defaultOption.text = "Bitte warten.."
          field.input.append(defaultOption)

          const res = await this.request("/get/user/trees-open/", {trees: ["getyour.expert.platforms"]})
          if (res.status === 200) {
            const users = JSON.parse(res.response)

            field.input.textContent = ""
            for (let i = 0; i < users.length; i++) {
              const user = users[i]
              if (user["getyour.expert.platforms"] !== undefined) {
                for (let i = 0; i < user["getyour.expert.platforms"].length; i++) {
                  const platform = user["getyour.expert.platforms"][i]
                  if (platform.values !== undefined) {
                    for (let i = 0; i < platform.values.length; i++) {
                      const value = platform.values[i]
                      const option = document.createElement("option")
                      option.text = this.convert("text/capital-first-letter", value.path)
                      option.value = value.path
                      field.input.append(option)
                    }
                  }
                }
              }
            }
            resolve(field)
          }

        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "field/select") {

      const field = document.createElement("div")
      field.classList.add("field")
      field.style.position = "relative"
      field.style.borderRadius = "13px"
      field.style.display = "flex"
      field.style.flexDirection = "column"
      field.style.margin = "34px"
      field.style.justifyContent = "center"
      field.labelContainer = document.createElement("div")
      field.labelContainer.classList.add("field-label-container")
      field.labelContainer.style.display = "flex"
      field.labelContainer.style.alignItems = "center"
      field.labelContainer.style.margin = "21px 89px 0 34px"
      field.appendChild(field.labelContainer)
      field.label = document.createElement("label")
      field.label.classList.add("field-label")
      field.label.style.fontFamily = "sans-serif"
      field.label.style.fontSize = "21px"
      field.labelContainer.appendChild(field.label)
      field.input = document.createElement("select")
      field.input.classList.add("field-input")
      field.input.add = (options) => {
        field.input.textContent = ""
        for (let i = 0; i < options.length; i++) {
          const option = document.createElement("option")
          option.classList.add("field-option")
          option.value = options[i]
          option.text = options[i]
          field.input.appendChild(option)
        }
      }
      field.input.select = (options) => {
        for (let i = 0; i < field.input.options.length; i++) {
          const option = field.input.options[i]
          option.selected = false
          for (let z = 0; z < options.length; z++) {
            if (options[z] === option.value) {
              option.selected = true
            }
          }
        }
      }
      field.input.style.margin = "21px 89px 21px 34px"
      field.input.style.fontSize = "21px"
      field.appendChild(field.input)
      field.style.backgroundColor = this.colors.light.foreground
      field.style.border = this.colors.light.border
      field.style.boxShadow = this.colors.light.boxShadow
      field.style.color = this.colors.light.text
      field.label.style.color = this.colors.light.text
      field.input.style.backgroundColor = this.colors.light.background
      field.input.style.color = this.colors.light.text
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        field.style.backgroundColor = this.colors.dark.foreground
        field.style.border = this.colors.dark.border
        field.style.boxShadow = this.colors.dark.boxShadow
        field.style.color = this.colors.dark.text
        field.label.style.color = this.colors.dark.text
        field.input.style.backgroundColor = this.colors.dark.background
        field.input.style.color = this.colors.dark.text
      }
      input?.appendChild(field)
      return field

    }

    if (event === "field/operator") {

      const field = this.create("field/text")

      field.label.textContent = "Operator"
      field.input.placeholder = ">="
      field.input.maxLength = "2"

      field.input.setAttribute("required", "true")
      field.input.setAttribute("accept", "text/operator")

      if (input !== undefined) input.append(field)
      return field
    }

    if (event === "field/name") {

      const field = this.create("field/text")

      field.label.textContent = "Name"

      field.input.setAttribute("required", "true")
      field.input.setAttribute("accept", "text/tag")

      if (input !== undefined) input.append(field)
      return field
    }

    if (event === "field/js") {

      const field = this.create("field/textarea")

      field.input.style.fontSize = "13px"
      field.input.style.height = "55px"
      field.input.placeholder = "document.querySelector..."

      field.input.setAttribute("required", "true")
      field.input.setAttribute("accept", "text/js")

      if (input !== undefined) input.append(field)
      return field
    }

    if (event === "field/script") {

      const field = this.create("field/textarea")

      field.label.textContent = "HTML Skript"
      field.input.style.fontSize = "13px"
      field.input.placeholder = "<script>..</script>"

      field.input.setAttribute("required", "true")
      field.input.setAttribute("accept", "text/script")

      if (input !== undefined) input.append(field)
      return field
    }

    if (event === "field/field-funnel") {

      const field = this.create("field/textarea")

      field.label.textContent = "Welche Daten soll dein Nutzer, in die Liste, speichern können (field-funnel)"
      field.input.style.fontSize = "13px"
      field.input.placeholder = `<div class="field-funnel">..</div>`

      field.input.setAttribute("accept", "text/field-funnel")
      field.input.setAttribute("required", "true")

      if (input !== undefined) input.append(field)
      return field
    }

    if (event === "field/textarea") {

      const field = document.createElement("div")
      field.classList.add("field")
      field.style.position = "relative"
      field.style.borderRadius = "13px"
      field.style.display = "flex"
      field.style.flexDirection = "column"
      field.style.margin = "34px"
      field.style.justifyContent = "center"

      field.labelContainer = document.createElement("div")
      field.labelContainer.classList.add("field-label-container")
      field.labelContainer.style.display = "flex"
      field.labelContainer.style.alignItems = "center"
      field.labelContainer.style.margin = "21px 89px 0 34px"
      field.label = document.createElement("label")
      field.label.classList.add("field-label")
      field.label.style.fontFamily = "sans-serif"
      field.label.style.fontSize = "21px"
      field.labelContainer.append(field.label)
      field.append(field.labelContainer)

      field.input = document.createElement("textarea")
      field.input.classList.add("field-input")
      field.input.style.margin = "21px 89px 21px 34px"
      field.input.style.fontSize = "21px"
      field.append(field.input)

      this.convert("dark-light", field)

      input?.append(field)
      return field
    }

    if (event === "field/url") {

      const field = document.createElement("div")
      field.classList.add("field")
      field.style.position = "relative"
      field.style.borderRadius = "13px"
      field.style.display = "flex"
      field.style.flexDirection = "column"
      field.style.margin = "34px"
      field.style.justifyContent = "center"

      field.labelContainer = document.createElement("div")
      field.labelContainer.classList.add("field-label-container")
      field.labelContainer.style.display = "flex"
      field.labelContainer.style.alignItems = "center"
      field.labelContainer.style.margin = "21px 89px 0 34px"
      field.label = document.createElement("label")
      field.label.classList.add("field-label")
      field.label.textContent = "Quell-URL"
      field.label.style.fontFamily = "sans-serif"
      field.label.style.fontSize = "21px"
      field.labelContainer.append(field.label)
      field.append(field.labelContainer)

      field.input = document.createElement("input")
      field.input.classList.add("field-input")
      field.input.type = "url"
      field.input.placeholder = "https://www.meine-quell-url.de/"
      field.input.style.margin = "21px 89px 21px 34px"
      field.input.style.fontSize = "21px"

      field.input.setAttribute("required", "true")
      field.input.setAttribute("accept", "text/url")

      field.append(field.input)

      field.style.backgroundColor = this.colors.light.foreground
      field.style.border = this.colors.light.border
      field.style.boxShadow = this.colors.light.boxShadow
      field.style.color = this.colors.light.text
      field.label.style.color = this.colors.light.text
      field.input.style.backgroundColor = this.colors.light.background
      field.input.style.color = this.colors.light.text
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        field.style.backgroundColor = this.colors.dark.foreground
        field.style.border = this.colors.dark.border
        field.style.boxShadow = this.colors.dark.boxShadow
        field.style.color = this.colors.dark.text
        field.label.style.color = this.colors.dark.text
        field.input.style.backgroundColor = this.colors.dark.background
        field.input.style.color = this.colors.dark.text
      }



      if (input !== undefined) input.append(field)
      return field
    }

    if (event === "field/checkbox") {

      const field = this.create("field")
      const checkboxInput = this.create("input/checkbox", field)
      field.input = checkboxInput.input
      field.input.classList.add("field-input")
      input?.appendChild(field)
      return field
    }

    if (event === "field/dsgvo") {

      const field = this.create("field/checkbox")
      field.input.classList.add("dsgvo-input")
      const label = this.createNode("div", field.label)
      this.createNode("span", label, "Ich habe die")
      const a1 = this.createNode("a", label, "Nutzervereinbarungen")
      a1.style.margin = "0 5px"
      a1.className = "button"
      a1.href = "/nutzervereinbarung/"
      this.createNode("span", label, "und die")
      const a2 = this.createNode("a", label, "Datenschutz Richtlinien")
      a2.style.margin = "0 5px"
      a2.className = "button"
      a2.href = "/datenschutz/"
      this.createNode("span", label, "gelesen und verstanden. Durch meine Anmeldung stimme ich ihnen zu.")
      field.image = document.createElement("div")
      field.image.classList.add("field-label-image")
      field.image.style.minWidth = "34px"
      field.image.style.maxWidth = "34px"
      field.image.style.marginRight = "21px"
      this.render("icon/node/path", "/public/info-circle.svg", field.image)
      field.label.before(field.image)
      field.input.setAttribute("required", "true")
      input?.appendChild(field)
      return field

    }

    if (event === "field/trees") {

      const field = this.create("field/textarea")
      field.input.setAttribute("required", "true")
      field.input.setAttribute("accept", "text/trees")
      input?.appendChild(field)
      return field
    }

    if (event === "field/tree") {

      const field = this.create("field/text")

      field.input.setAttribute("accept", "text/tree")
      field.input.setAttribute("required", "true")

      if (input !== undefined) input.append(field)
      return field
    }

    if (event === "field/path") {

      const field = this.create("field/text")

      field.input.setAttribute("accept", "text/path")
      field.input.setAttribute("required", "true")

      if (input !== undefined) input.append(field)
      return field
    }

    if (event === "field/hex") {

      const field = this.create("field/text")

      field.input.setAttribute("accept", "text/hex")
      field.input.setAttribute("required", "true")

      if (input !== undefined) input.append(field)
      return field
    }

    if (event === "field/tag") {

      const field = this.create("field/text")
      field.input.setAttribute("accept", "text/tag")
      field.input.setAttribute("required", "true")
      input?.appendChild(field)
      return field
    }

    if (event === "field/pdf-file") {

      const field = this.create("field/file")
      field.input.setAttribute("required", "true")
      field.input.setAttribute("accept", "application/pdf")

      input?.append(field)
      return field

    }

    if (event === "field/file") {

      const field = this.create("field")
      const fileInput = this.create("input/file", field)
      field.input = fileInput.input
      field.input.classList.add("field-input")
      input?.appendChild(field)
      return field
    }

    if (event === "field/tel") {

      const field = this.create("field")
      const telInput = this.create("input/tel", field)
      field.input = telInput.input
      field.input.classList.add("field-input")
      input?.appendChild(field)
      return field
    }

    if (event === "field/date") {

      const field = this.create("field")
      const dateInput = this.create("input/date", field)
      field.input = dateInput.input
      field.input.classList.add("field-input")
      input?.appendChild(field)
      return field
    }

    if (event === "field/number") {

      const field = this.create("field")
      const numberInput = this.create("input/number", field)
      field.input = numberInput.input
      field.input.classList.add("field-input")
      input?.appendChild(field)
      return field
    }

    if (event === "field/password") {

      const field = this.create("field")
      const passwordInput = this.create("input/password", field)
      field.input = passwordInput.input
      field.input.classList.add("field-input")
      input?.appendChild(field)
      return field
    }

    if (event === "field/range") {

      const field = this.create("field")
      const rangeInput = this.create("input/range", field)
      field.input = rangeInput.input
      field.input.classList.add("field-input")
      input?.appendChild(field)
      return field
    }

    if (event === "field/text") {

      const field = this.create("field")
      const textInput = this.create("input/text", field)
      field.input = textInput.input
      field.input.classList.add("field-input")
      input?.appendChild(field)
      return field
    }

    if (event === "field") {

      const field = document.createElement("div")
      field.classList.add("field")
      field.style.position = "relative"
      field.style.borderRadius = "13px"
      field.style.display = "flex"
      field.style.flexDirection = "column"
      field.style.margin = "34px"
      field.style.justifyContent = "center"
      field.labelContainer = document.createElement("div")
      field.labelContainer.classList.add("field-label-container")
      field.labelContainer.style.wordBreak = "break-word"
      field.labelContainer.style.display = "flex"
      field.labelContainer.style.alignItems = "center"
      field.labelContainer.style.margin = "21px 89px 0 34px"
      field.appendChild(field.labelContainer)
      field.label = document.createElement("label")
      field.label.classList.add("field-label")
      field.label.style.fontFamily = "sans-serif"
      field.label.style.fontSize = "21px"
      field.labelContainer.appendChild(field.label)
      this.convert("dark-light", field)
      input?.appendChild(field)
      return field
    }

    if (event === "field/emails") {

      const field = this.create("field/textarea")
      field.input.style.fontFamily = "monospace"
      field.input.style.fontSize = "13px"
      field.input.style.height = "89px"
      field.input.placeholder = `[\n  "meine-erste@email.de",\n  "meine-zweite@email.de"\n]`

      field.input.setAttribute("required", "true")
      field.input.setAttribute("accept", "email/array")

      input?.append(field)
      return field
    }

    if (event === "field/email") {

      const field = this.create("field")
      field.label.textContent = "E-Mail Adresse"
      const emailInput = this.create("input/email", field)
      field.input = emailInput.input
      field.input.classList.add("field-input")
      input?.appendChild(field)
      return field
    }

    if (event === "field/id") {

      const field = this.create("field/tag")
      field.label.textContent = "Identifikationsname (text/tag)"
      field.input.placeholder = "meine-id"
      this.verify("input/value", field.input)
      this.add("outline-hover", field.input)
      field.input.oninput = () => {
        this.verify("input/value", field.input)
        if (this.verifyIs("id/unique", field.input.value) && this.verifyIs("text/tag", field.input.value)) {
          this.add("style/valid", field.input)
        } else {
          this.add("style/not-valid", field.input)
        }
      }
      input?.appendChild(field)
      return field
    }

    if (event === "field/lang") {

      const langField = this.create("field/select")
      langField.label.textContent = "Sprache"
      const options = ["aa","ab","ae","af","ak","am","an","ar","as","av","ay","az","ba","be","bg","bh","bi","bm","bn","bo","br","bs","ca","ce","ch","co","cr","cs","cu","cv","cy","da","de","dv","dz","ee","el","en","eo","es","et","eu","fa","ff","fi","fj","fo","fr","fy","ga","gd","gl","gn","gu","gv","ha","he","hi","ho","hr","ht","hu","hy","hz","ia","id","ie","ig","ii","ik","io","is","it","iu","ja","jv","ka","kg","ki","kj","kk","kl","km","kn","ko","kr","ks","ku","kv","kw","ky","la","lb","lg","li","ln","lo","lt","lu","lv","mg","mh","mi","mk","ml","mn","mr","ms","mt","my","na","nb","nd","ne","ng","nl","nn","no","nr","nv","ny","oc","oj","om","or","os","pa","pi","pl","ps","pt","qu","rm","rn","ro","ru","rw","sa","sc","sd","se","sg","si","sk","sl","sm","sn","so","sq","sr","ss","st","su","sv","sw","ta","te","tg","th","ti","tk","tl","tn","to","tr","ts","tt","tw","ty","ug","uk","ur","uz","ve","vi","vo","wa","wo","xh","yi","yo","za","zh","zu"]
      for (let i = 0; i < options.length; i++) {
        const option = document.createElement("option")
        option.value = options[i]
        option.text = options[i]
        langField.input.append(option)
      }
      langField.input.value = "de"
      this.add("style/valid", langField.input)

      input?.append(langField)
      return langField

    }

    if (event === "field-funnel") {
      const fieldFunnel = this.create("div/scrollable")
      fieldFunnel.classList.add("field-funnel")

      fieldFunnel.submitButton = this.create("button/action", fieldFunnel)
      fieldFunnel.submitButton.classList.add("submit-field-funnel-button")
      fieldFunnel.submitButton.textContent = "Jetzt speichern"

      if (input !== undefined) input.append(fieldFunnel)

      return fieldFunnel
    }

    if (event === "field/audio") {

      const field = document.createElement("div")
      field.classList.add("field")
      field.style.position = "relative"
      field.style.borderRadius = "13px"
      field.style.display = "flex"
      field.style.flexDirection = "column"
      field.style.margin = "34px"
      field.style.justifyContent = "center"

      field.labelContainer = document.createElement("div")
      field.labelContainer.classList.add("field-label-container")
      field.labelContainer.style.display = "flex"
      field.labelContainer.style.alignItems = "center"
      field.labelContainer.style.margin = "21px 89px 21px 34px"
      field.labelContainer.style.overflow = "auto"
      field.append(field.labelContainer)

      field.label = document.createElement("label")
      field.label.classList.add("field-label")
      field.label.style.fontFamily = "sans-serif"
      field.label.style.fontSize = "13px"
      field.labelContainer.append(field.label)

      field.audio = document.createElement("audio")
      field.audio.classList.add("field-audio")
      field.audio.style.fontSize = "21px"
      field.audio.style.width = "100%"
      field.audio.style.borderRadius = "13px"
      field.audio.setAttribute("controls", "")
      field.append(field.audio)

      field.style.backgroundColor = this.colors.light.foreground
      field.style.border = this.colors.light.border
      field.style.boxShadow = this.colors.light.boxShadow
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        field.style.backgroundColor = this.colors.dark.foreground
        field.style.border = this.colors.dark.border
        field.style.boxShadow = this.colors.dark.boxShadow
      }

      input?.append(field)
      return field
    }

    if (event === "field-funnel/role") {

      const funnel = this.create("div/scrollable")
      funnel.nameField = this.create("field/tag", funnel)
      funnel.nameField.label.textContent = "Rolle"
      funnel.nameField.input.placeholder = "meine-neue-rolle"
      this.verify("input/value", funnel.nameField.input)
      funnel.nameField.input.addEventListener("input", () => this.verify("input/value", funnel.nameField.input))
      funnel.homeField = this.create("field/select", funnel)
      funnel.homeField.label.textContent = "Wohin soll diese Rolle, nach dem Login, weitergeleitet werden"
      funnel.appsField = this.create("field/textarea", funnel)
      funnel.appsField.label.textContent = "Schalte Apps für deine Rolle frei (mit einer Javascript String Liste)"
      funnel.appsField.input.style.height = "144px"
      funnel.appsField.input.placeholder = `["owner", "funnel", ..]`
      funnel.appsField.input.setAttribute("accept", `string/array`)
      funnel.appsField.input.setAttribute("required", "true")
      funnel.appsField.input.value = JSON.stringify([])
      this.verify("input/value", funnel.appsField.input)
      funnel.appsField.input.addEventListener("input", () => this.verify("input/value", funnel.appsField.input))
      funnel.submit = this.create("button/action", funnel)
      funnel.submit.textContent = "Rolle jetzt speichern"
      input?.appendChild(funnel)
      return funnel
    }

    if (event === "answer-box") {

      const answerBox = document.createElement("div")
      answerBox.classList.add("answer-box")

      answerBox.answer = document.createElement("div")
      answerBox.answer.classList.add("answer")
      answerBox.append(answerBox.answer)

      if (input !== undefined) input.append(answerBox)

      answerBox.style.cursor = "pointer"
      answerBox.style.display = "flex"
      answerBox.style.flexDirection = "column"
      answerBox.style.borderRadius = "13px"
      answerBox.style.margin = "8px 0"
      answerBox.style.overflow = "hidden"

      answerBox.style.border = `1px solid ${this.colors.light.text}`

      answerBox.answer.style.fontFamily = "sans-serif"
      answerBox.answer.style.overflow = "auto"
      answerBox.answer.style.margin = "21px 34px"
      answerBox.answer.style.maxHeight = "89px"
      answerBox.answer.style.textAlign = "center"

      return answerBox
    }

    if (event === "title") {
      const title = document.createElement("div")
      title.style.margin = "21px 34px"
      title.style.fontSize = "21px"
      title.style.fontFamily = "sans-serif"


      title.style.color = this.colors.light.text
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        title.style.color = this.colors.dark.text
      }

      if (input !== undefined) input.append(title)

      return title
    }

    if (event === "click-funnel") {
      const clickFunnel = this.create("div/scrollable")
      clickFunnel.classList.add("click-funnel")
      if (input !== undefined) input.append(clickFunnel)

      clickFunnel.style.display = "flex"
      clickFunnel.style.justifyContent = "center"
      clickFunnel.style.position = "relative"
      clickFunnel.style.margin = "21px 34px"

      {
        const button = this.create("button/icon-text", clickFunnel)
        button.classList.add("start-click-funnel-button")
        this.render("icon/node/path", "/public/touch-index-finger.svg", button.icon)
        button.text.textContent = "Start"
      }

      {
        const button = this.create("button/icon-text", clickFunnel)
        button.classList.add("end-click-funnel-button")
        button.style.display = "none"
        this.render("icon/node/path", "/public/touch-index-finger.svg", button.icon)
        button.text.textContent = "Speichern"
      }


      return clickFunnel
    }

    if (event === "image-left/text-right") {

      const box = document.createElement("div")
      box.style.display = "flex"
      box.style.borderRadius = "13px"
      box.style.margin = "8px 0"

      box.style.border = `1px solid ${this.colors.light.text}`
      // if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      //   box.style.border = `1px solid ${this.colors.dark.text}`
      // } else {
      // }

      box.image = document.createElement("div")
      box.image.classList.add("image")
      box.image.style.display = "flex"
      box.image.style.width = "144px"
      box.image.style.borderTopLeftRadius = "13px"
      box.image.style.borderBottomLeftRadius = "13px"
      box.image.style.overflow = "hidden"
      box.append(box.image)

      box.text = document.createElement("div")
      box.image.classList.add("text")
      box.text.style.fontFamily = "sans-serif"
      box.text.style.width = "100%"
      box.text.style.overflow = "auto"
      box.text.style.padding = "8px"
      box.append(box.text)

      if (input !== undefined) input.append(box)

      return box

    }

    if (event === "click-field") {

      const field = document.createElement("div")
      field.classList.add("click-field")

      field.question = document.createElement("label")
      field.question.classList.add("question")
      field.append(field.question)

      field.answers = document.createElement("div")
      field.answers.classList.add("answers")
      field.append(field.answers)

      if (input !== undefined) input.append(field)


      // flexible css

      field.style.borderRadius = "13px"
      field.style.flexDirection = "column"
      field.style.justifyContent = "center"
      field.style.width = "100%"

      field.style.display = "none"


      field.style.backgroundColor = this.colors.light.foreground
      field.style.border = this.colors.light.border
      field.style.boxShadow = this.colors.light.boxShadow
      field.style.color = this.colors.light.text
      // if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      //   field.style.backgroundColor = this.colors.dark.foreground
      //   field.style.border = this.colors.dark.border
      //   field.style.boxShadow = this.colors.dark.boxShadow
      //   field.style.color = this.colors.dark.text
      // } else {
      // }

      field.question.style.margin = "21px 34px"
      field.question.style.fontFamily = "sans-serif"
      field.question.style.fontSize = "21px"

      field.question.style.color = this.colors.light.text
      // if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      //   field.question.style.color = this.colors.dark.text
      // } else {
      // }

      field.answers.style.display = "flex"
      field.answers.style.flexDirection = "column"
      field.answers.style.margin = "21px 34px"

      return field
    }

    if (event === "click/field") {


      const field = document.createElement("div")
      field.classList.add("click-field")
      field.style.borderRadius = "13px"
      field.style.flexDirection = "column"
      field.style.justifyContent = "center"
      field.style.width = "100%"

      field.style.display = "none"

      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        field.style.backgroundColor = this.colors.dark.foreground
        field.style.border = this.colors.dark.border
        field.style.boxShadow = this.colors.dark.boxShadow
        field.style.color = this.colors.dark.text
      } else {
        field.style.backgroundColor = this.colors.light.foreground
        field.style.border = this.colors.light.border
        field.style.boxShadow = this.colors.light.boxShadow
        field.style.color = this.colors.light.text
      }

      field.question = document.createElement("label")
      field.question.classList.add("question")
      field.question.style.margin = "21px 34px"
      field.question.style.fontFamily = "sans-serif"
      field.question.style.fontSize = "21px"
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        field.question.style.color = this.colors.dark.text
      } else {
        field.question.style.color = this.colors.light.text
      }
      field.append(field.question)

      field.answers = document.createElement("div")
      field.answers.classList.add("answers")
      field.answers.style.display = "flex"
      field.answers.style.flexDirection = "column"
      field.answers.style.margin = "21px 34px"
      field.append(field.answers)

      if (input !== undefined) input.append(field)

      return field
    }

    if (event === "info/loading") {

      const header = document.createElement("div")
      this.convert("parent/loading", header)
      input?.appendChild(header)
      return header
    }

    if (event === "info/warning") {
      const element = document.createElement("div")
      element.style.fontSize = "13px"
      element.style.fontFamily = "sans-serif"
      element.style.margin = "21px 34px"
      element.style.padding = "21px 34px"
      element.style.borderRadius = "13px"

      element.style.color = this.colors.light.text
      element.style.backgroundColor = this.colors.light.error

      if (input !== undefined) input.append(element)

      return element
    }

    if (event === "info/success") {
      const element = document.createElement("div")
      element.style.fontSize = "13px"
      element.style.fontFamily = "sans-serif"
      element.style.margin = "21px 34px"
      element.style.padding = "21px 34px"
      element.style.borderRadius = "13px"

      element.style.color = this.colors.light.text
      element.style.backgroundColor = this.colors.light.success

      if (input !== undefined) input.append(element)

      return element
    }

    if (event === "start-button") {

      const button = this.create("button/left-right")
      button.left.textContent = ".start"
      button.right.textContent = "Beginne deine Reise in die digitale Freiheit"
      button.setAttribute("onclick", "window.open('/', '_blank')")
      input?.append(button)
      return button

    }

    if (event === "video") {

      const fragment = document.createDocumentFragment()
      const video = document.createElement("video")
      fragment.appendChild(video)
      video.style.width = "100%"
      video.autoplay = true
      input?.appendChild(fragment)
      return video
    }

    if (event === "visibility-button") {

      const fragment = document.createDocumentFragment()
      const button = Helper.create("toolbox/left-right", fragment)
      button.left.textContent = ".visibility"
      button.right.textContent = "Sichtbarkeit ändern"
      input?.appendChild(fragment)
      return button
    }

  }

  static colors = {
    white: "#FFF",
    matte: {
      green: '#00C853',
      lightGray: '#EAEAEA',
      orange: '#E8A435',
      sunflower: '#EFA514',
      apricot: '#FBCEB1',
      red: '#EE7A7A',
      mint: '#72E6CB',
      seaGreen: '#277E71',
      black: '#303030',
      charcoal: '#444444',
      slate: '#555555',
      deepBlue: '#003366',
      forest: '#09443C',
      maroon: '#801515',
      mustard: '#9A8700',
      plum: '#4F2D56',
      chocolate: '#3D1F0D',
      steel: '#555B6E',
      white: '#F0F0F0',
      snow: '#FAFAFA',
      ash: '#C0C0C0',
      skyBlue: '#A3C1D1',
      mintGreen: '#84B082',
      coral: '#D46A6A',
      lemon: '#FFEB99',
      lavender: '#D8C8EA',
      almond: '#E9D6AF',
      pearl: '#F2F2F2',
      chartreuse: '#B5E288',
      celadon: '#ACE1Af',
      royalBlue: '#4169E1',
      olive: '#808000',
      teal: '#008080',
      raspberry: '#B5014E',
      sand: '#CDB79E',
      navy: '#000080',
      emerald: '#50C878',
      tangerine: '#FFA500',
      lilac: '#C8A2C8',
      taupe: '#483C32',
      lime: '#9FCB8D',
      lightYellow: "#F7AA20"
    },
    gray: {
      0: "#EAEAEA",
      1: "#DCDCDC",
      2: "#CDCDCD",
      3: "#C6C6C6",
      4: "#ADADAD",
      5: "#939393",
    },
    dark: {
      foreground: '#303030',
      background: '#28282B',
      boxShadow: `0 1px 3px ${this.convert("hex/rgba", {hex: "#FFFFFF", alpha: "0.13"})}`,
      border: '0.3px solid #2E4369',
      primary: '#2E4369',
      secondary: '#4E6172',
      accent: '#6D8898',
      text: '#CDD9E5',
      error: '#9B3C38',
      success: '#285D34',
    },
    light: {
      foreground: '#FAFAFA',
      background: '#F0F0F0',
      border: '0.3px solid #A0A0A0',
      boxShadow: `0 1px 3px ${this.convert("hex/rgba", {hex: "#000000", alpha: "0.13"})}`,
      primary: '#A0A0A0',
      secondary: '#7C7C7C',
      accent: '#595959',
      text: '#333333',
      error: '#B03535',
      success: '#9FCB8D',
    },
    link: {
      color: "#4169E1",
      active: "#D46A6A"
    },
    key: "#2E95D3",
    value: "#CE9178",
  }

  static convert(event, input) {
    // event = input/to

    if (event === "query/css") {
      const match = input.match(/{([^{}]*)}/)

      if (match && match[1]) {
        return match[1].trim()
      }

    }

    if (event === "query/selector") {
      const match = input.match(/{(.*?){/)

      if (match && match[1]) {
        return match[1].trim()
      }

    }

    if (event === "api/sources") {
      return new Promise(async(resolve, reject) => {
        try {

          const response = await fetch(input)
          const data = await response.json()

          if (input.startsWith("https://www.googleapis.com/")) {
            // console.log("from googleapis.com")
            // console.log(data)
            if (data.items !== undefined) {
              const sources = []
              for (let i = 0; i < data.items.length; i++) {
                const source = data.items[i]

                const map = {}
                map.api = input
                map.keywords = []

                if (source.volumeInfo) {
                  if (source.volumeInfo.title) {
                    map.title = source.volumeInfo.title
                    const titleWords = map.title.split(" ")
                    for (let i = 0; i < titleWords.length; i++) {
                      map.keywords.push(titleWords[i])
                    }
                  }
                }

                if (source.volumeInfo) {
                  if (source.volumeInfo.authors) {
                    map.authors = source.volumeInfo.authors
                    for (let i = 0; i < map.authors.length; i++) {
                      map.keywords.push(map.authors[i])
                    }
                  }
                }

                if (source.volumeInfo) {
                  if (source.volumeInfo.subtitle) {
                    const subTitleWords = source.volumeInfo.subtitle.split(" ")
                    for (let i = 0; i < subTitleWords.length; i++) {
                      map.keywords.push(subTitleWords[i])
                    }
                  }
                }

                if (source.volumeInfo) {
                  if (source.volumeInfo.categories) {
                    for (let i = 0; i < source.volumeInfo.categories.length; i++) {
                      map.keywords.push(source.volumeInfo.categories[i])
                    }
                  }
                }

                if (source.volumeInfo) {
                  if (source.volumeInfo.printType) {
                    if (source.volumeInfo.printType.toLowerCase() === "book") {
                      map.type = "text/book"
                      map.keywords.push(map.type)
                    }
                  }
                }

                if (source.volumeInfo) {
                  if (source.volumeInfo.description) {
                    map.description = source.volumeInfo.description
                    const descriptionWords = source.volumeInfo.description.split(" ")
                    for (let i = 0; i < descriptionWords.length; i++) {
                      map.keywords.push(descriptionWords[i])
                    }
                  }
                }

                if (source.searchInfo) {
                  if (source.searchInfo.textSnippet) {
                    const searchInfoWords = source.searchInfo.textSnippet.split(" ")
                    for (let i = 0; i < searchInfoWords.length; i++) {
                      map.keywords.push(searchInfoWords[i])
                    }
                  }
                }

                if (source.volumeInfo) {
                  if (source.volumeInfo.language) {
                    map.language = []
                    map.language.push(source.volumeInfo.language.slice(0, 2))
                    map.keywords.push(map.language)
                  }
                }

                if (source.volumeInfo) {
                  if (source.volumeInfo.imageLinks) {
                    if (source.volumeInfo.imageLinks.thumbnail) {
                      map.image = source.volumeInfo.imageLinks.thumbnail
                    }
                  }
                }

                if (source.volumeInfo) {
                  if (source.volumeInfo.publishedDate) {
                    if (source.volumeInfo.publishedDate) {
                      map.published = new Date(source.volumeInfo.publishedDate).getTime()
                      map.keywords.push(this.convert("millis/yyyy", map.published))
                    }
                  }
                }

                if (source.volumeInfo) {
                  if (source.volumeInfo.publisher) {
                    map.publisher = []
                    map.publisher.push(source.volumeInfo.publisher)
                    map.keywords.push(source.volumeInfo.publisher)
                  }
                }

                if (source.volumeInfo) {
                  if (source.volumeInfo.industryIdentifiers) {
                    map.isbn = []
                    for (let i = 0; i < source.volumeInfo.industryIdentifiers.length; i++) {
                      const it = source.volumeInfo.industryIdentifiers[i]
                      map.isbn.push(it.identifier)
                    }
                  }
                }

                sources.push(map)
              }

              resolve(sources)
            }
          }

          if (input.startsWith("https://openlibrary.org/")) {
            // console.log("from openlibrary.org")
            // console.log(data)
            if (data.docs !== undefined) {
              const sources = []
              for (let i = 0; i < data.docs.length; i++) {
                const source = data.docs[i]

                const map = {}
                map.api = input
                map.keywords = []

                if (source.title) {
                  map.title = source.title
                  const titleWords = map.title.split(" ")
                  for (let i = 0; i < titleWords.length; i++) {
                    map.keywords.push(titleWords[i])
                  }
                }

                if (source.author_name) {
                  map.authors = source.author_name
                  for (let i = 0; i < map.authors.length; i++) {
                    map.keywords.push(map.authors[i])
                  }
                }

                if (source.seed) {
                  for (let i = 0; i < source.seed.length; i++) {
                    const seed = source.seed[i]
                    if (seed.includes("book")) {
                      map.type = "text/book"
                    }
                  }
                }

                if (source.publisher) {
                  map.publisher = source.publisher
                  for (let i = 0; i < source.publisher.length; i++) {
                    const publisher = source.publisher[i]
                    map.keywords.push(publisher)
                  }
                }

                if (source.contributer) {
                  for (let i = 0; i < source.contributer.length; i++) {
                    const contributer = source.contributer[i]
                    map.keywords.push(contributer)
                  }
                }

                if (source.subject) {
                  for (let i = 0; i < source.subject.length; i++) {
                    const subject = source.subject[i]
                    map.keywords.push(subject)
                  }
                }

                if (source.first_publish_year) {
                  if (source.first_publish_year) {
                    map.published = new Date(source.first_publish_year, 0, 1).getTime()
                    map.keywords.push(this.convert("millis/yyyy", map.published))
                  }
                }

                if (source.isbn) {
                  map.isbn = source.isbn
                }

                if (source.language) {
                  map.language = []
                  for (let i = 0; i < source.language.length; i++) {
                    const language = source.language[i]
                    map.language.push(language.slice(0, 2))
                  }
                }

                sources.push(map)
              }

              resolve(sources)
            }
          }

          if (input.startsWith("https://archive.org/")) {
            // console.log("from archive.org")
            // console.log(data)
            if (data.response !== undefined) {
              if (data.response.docs !== undefined) {
                const sources = []
                for (let i = 0; i < data.response.docs.length; i++) {
                  const source = data.response.docs[i]

                  const map = {}
                  map.api = input
                  map.keywords = []

                  if (source.title) {
                    map.title = source.title
                    const titleWords = map.title.split(" ")
                    for (let i = 0; i < titleWords.length; i++) {
                      map.keywords.push(titleWords[i])
                    }
                  }

                  if (source.subject) {
                    for (let i = 0; i < source.subject.length; i++) {
                      const subject = source.subject[i]
                      map.keywords.push(subject)
                    }
                  }

                  if (source.mediatype) {
                    if (source.mediatype === "texts") {
                      map.type = "text/book"
                      map.keywords.push(map.type)
                    }
                  }

                  if (source.publisher) {
                    map.publisher = []
                    map.publisher.push(source.publisher)
                    map.keywords.push(source.publisher)
                  }

                  if (source.date) {
                    map.published = new Date(source.date).getTime()
                    map.keywords.push(this.convert("millis/yyyy", map.published))
                  }

                  if (source.creator) {
                    map.authors = []
                    map.authors.push(source.creator)
                    map.keywords.push(source.creator)
                  }

                  if (source.description) {
                    if (this.verifyIs("text", source.description)) {
                      map.description = source.description
                      const descriptionWords = source.description.split(" ")
                      for (let i = 0; i < descriptionWords.length; i++) {
                        map.keywords.push(descriptionWords[i])
                      }
                    }

                    if (this.verifyIs("array", source.description)) {
                      map.description = ""
                      for (let i = 0; i < source.description.length; i++) {
                        const description = source.description[i]
                        map.keywords.push(description)
                        map.description += description
                      }
                    }
                  }

                  if (source.genre) {
                    map.keywords.push(source.genre)
                  }

                  sources.push(map)
                }

                resolve(sources)
              }
            }
          }

        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "array/reduce-selected-price") {
      return input.filter(it => it.selected === true).reduce((prev, curr) => prev + curr.price, 0)
    }

    if (event === "array/table") {

      const table = document.createElement('table')
      table.setAttribute('border', '1')
      const thead = document.createElement('thead')
      const headerRow = document.createElement('tr')
      Object.keys(input[0]).forEach(key => {
        const th = document.createElement('th')
        th.textContent = key
        headerRow.appendChild(th)
      })
      thead.appendChild(headerRow)
      table.appendChild(thead)
      const tbody = document.createElement('tbody')
      input.forEach(item => {
        const row = document.createElement('tr')
        Object.values(item).forEach(value => {
          const td = document.createElement('td')
          td.textContent = value
          row.appendChild(td)
        })
        tbody.appendChild(row)
      })
      table.appendChild(tbody)
      return table
    }

    if (event === "back-button") {

      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        input.style.boxShadow = this.colors.light.boxShadow
        input.style.border = this.colors.light.border
        input.style.backgroundColor = this.colors.light.foreground
      } else {
        input.style.boxShadow = this.colors.dark.boxShadow
        input.style.border = this.colors.dark.border
        input.style.backgroundColor = this.colors.dark.foreground
      }
      input.querySelectorAll("*").forEach((child, i) => {
        if (child.hasAttribute("stroke")) {
          if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            child.setAttribute("stroke", `${this.colors.light.text}`)
          } else {
            child.setAttribute("stroke", `${this.colors.dark.text}`)
          }
        }
      })
    }

    if (event === "border/dark-light") {

      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        input.style.border = this.colors.dark.border
      } else {
        input.style.border = this.colors.light.border
      }
    }

    if (event === "box/dark-light") {

      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        input.style.backgroundColor = this.colors.dark.background
        input.style.border = this.colors.dark.border
        input.style.boxShadow = this.colors.dark.boxShadow
        input.style.color = this.colors.dark.text
      } else {
        input.style.backgroundColor = this.colors.light.background
        input.style.border = this.colors.light.border
        input.style.boxShadow = this.colors.light.boxShadow
        input.style.color = this.colors.light.text
      }
    }

    if (event === "button/dark-light") {

      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        input.style.backgroundColor = this.colors.dark.foreground
        input.style.border = this.colors.dark.border
        input.style.boxShadow = this.colors.dark.boxShadow
        input.style.color = this.colors.dark.text
      } else {
        input.style.backgroundColor = this.colors.light.foreground
        input.style.border = this.colors.light.border
        input.style.color = this.colors.light.text
        input.style.boxShadow = this.colors.light.boxShadow
      }
    }

    if (event === "canvas/file") {
      return new Promise(async(resolve, reject) => {
        try {
          input.toBlob(blob => {
            resolve({
              created: Date.now(),
              type: blob.type,
              size: blob.size,
              dataURL: input.toDataURL()
            })
          })
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "canvas/image") {

      return new Promise((resolve, reject) => {
        try {
          input.toBlob(async blob => {
            const hash = await this.digest(blob)
            const fileName = `${hash}.jpg`
            const file = new File([blob], fileName, { type: 'image/jpeg' })
            resolve(file)
          })
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "dark-light") {

      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        input.style.color = this.colors.dark.text
        input.style.background = this.colors.dark.background
      } else {
        input.style.color = this.colors.light.text
        input.style.background = this.colors.light.background
      }

      if (input.classList.contains("icon")) {
        input.querySelectorAll("*").forEach((child, i) => {
          if (child.hasAttribute("stroke")) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
              child.setAttribute("stroke", `${this.colors.light.text}`)
            } else {
              child.setAttribute("stroke", `${this.colors.dark.text}`)
            }
          }
        })
      }

      if (input.tagName === "A") {
        this.convert("link/dark-light", input)
      }

      if (input.classList.contains("field")) {
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
          input.style.backgroundColor = this.colors.dark.foreground
          input.style.border = this.colors.dark.border
          input.style.boxShadow = this.colors.dark.boxShadow
          input.style.color = this.colors.dark.text
          for (let i = 0; i < input.querySelectorAll("*").length; i++) {
            const child = input.querySelectorAll("*")[i]
            if (child.hasAttribute("fill")) {
              child.setAttribute("fill", this.colors.dark.text)
            }
          }
        } else {
          input.style.backgroundColor = this.colors.light.foreground
          input.style.border = this.colors.light.border
          input.style.boxShadow = this.colors.light.boxShadow
          input.style.color = this.colors.light.text
          for (let i = 0; i < input.querySelectorAll("*").length; i++) {
            const child = input.querySelectorAll("*")[i]
            if (child.hasAttribute("fill")) {
              child.setAttribute("fill", this.colors.light.text)
            }
          }
        }
      }

      if (input.classList.contains("back") && input.classList.contains("button")) {
        this.convert("back-button", input)
      }

    }

    if (event === "doc/inline") {

      function mergeStyles(it, dummy) {
        const result = {}
        for (let i = 0; i < it.length; i++) {
          const key = it[i]
          const value1 = it.getPropertyValue(key)
          const value2 = dummy.getPropertyValue(key)
          if (value1 !== value2) {
            result[key] = value1
          }
        }
        return result
      }
      const elements = input.querySelectorAll('*')
      elements.forEach(element => {
        const dummy = document.createElement(element.tagName)
        document.body.appendChild(dummy)
        const dummyStyle = window.getComputedStyle(dummy)
        const elementStyle = window.getComputedStyle(element)
        const style = mergeStyles(elementStyle, dummyStyle)
        let newStyle = ''
        if (!this.verifyIs("object/empty", style)) {
          for (const key in style) {
            newStyle += `${key}: ${style[key]}; `
          }
        }
        if (!this.verifyIs("text/empty", newStyle)) {
          element.setAttribute('style', newStyle.trim())
        }
      })
      return input
    }

    if (event === "rgb/luminance") {
      const rgb = input.match(/\d+/g).map(Number)
      const luminance = (0.299 * rgb[0] + 0.587 * rgb[1] + 0.114 * rgb[2]) / 255
      return luminance
    }

    if (event === "hex/rgba") {
      const hex = input.hex.replace('#', '')

      var r = parseInt(hex.substring(0, 2), 16)
      var g = parseInt(hex.substring(2, 4), 16)
      var b = parseInt(hex.substring(4, 6), 16)

      if (input.alpha < 0 || input.alpha > 1) {
        throw new Error('The alpha value must be between 0 and 1.');
      }

      var rgba = 'rgba(' + r + ', ' + g + ', ' + b + ', ' + input.alpha + ')';

      return rgba
    }

    if (event === "markdown/html") {

      // Convert '#' at the beginning of a line to <h1> tag
      input = input.replace(/^# (.+)$/gm, '<h1>$1</h1>')

      // Convert '##' at the beginning of a line to <h2> tag
      input = input.replace(/^## (.+)$/gm, '<h2>$1</h2>')
      input = input.replace(/^### (.+)$/gm, '<h3>$1</h3>')

      // Convert '*' and '_' for emphasis to <em> tags
      input = input.replace(/(\*|_)(.+?)\1/g, '<em>$2</em>')

      // Convert '**' and '__' for strong emphasis to <strong> tags
      input = input.replace(/(\*\*|__)(.+?)\1/g, '<strong>$2</strong>')

      // Convert lists
      input = input.replace(/^\* (.+)$/gm, '<li>$1</li>')
      input = input.replace(/<li>(.+)<\/li>/g, '<ul>$&</ul>')

      // Convert paragraphs
      input = input.replace(/(.+)$/gm, '<p>$1</p>')

      // Convert fenced code blocks (```)
      input = input.replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>')

      // Convert blockquotes
      // input = input.replace(/>(.+)/gm, '<blockquote>$1</blockquote>')

      // Convert links ([text](url))
      input = input.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>')

      // Convert inline code (`code`)
      input = input.replace(/`([^`]+)`/g, '<code>$1</code>')

      // Convert images (![alt text](url))
      input = input.replace(/!\[([^\]]+)\]\(([^)]+)\)/g, '<img alt="$1" src="$2">')

      // Convert horizontal rules (--- or *** or ___)
      input = input.replace(/(\*\*\*|---|___)/g, '<hr>')

      // Convert tables
      input = input.replace(/^[|].*[|]$/gm, function(match) {
        // Extract table headers and rows
        const rows = match.split('\n').filter(Boolean)
        const headers = rows[0].split('|').filter(Boolean)

        // Create the table HTML
        let tableHTML = '<table><thead><tr>'
        headers.forEach(header => {
          tableHTML += `<th>${header.trim()}</th>`
        })
        tableHTML += '</tr></thead><tbody>'

        for (let i = 1; i < rows.length; i++) {
          const cells = rows[i].split('|').filter(Boolean)
          tableHTML += '<tr>'
          cells.forEach(cell => {
            tableHTML += `<td>${cell.trim()}</td>`
          })
          tableHTML += '</tr>'
        }

        tableHTML += '</tbody></table>'
        return tableHTML
      })

      // Convert strikethrough (~~text~~)
      input = input.replace(/~~(.+?)~~/g, '<del>$1</del>')

      // Convert task lists
      input = input.replace(/\[ \]/g, '<input type="checkbox" disabled>')
      input = input.replace(/\[x\]/g, '<input type="checkbox" checked disabled>')

      return input
    }

    if (event === "tag/capital-first-letter") {

      if (input.includes("-")) {
        const array = input.split("-")

        const results = []
        for (var i = 0; i < array.length; i++) {
          const item = array[i]

          const result = this.convert("text/capital-first-letter", item)
          results.push(result)

        }
        return results.join(" ")

      } else {
        return this.convert("text/capital-first-letter", input)
      }

    }

    if (event === "file/data-url") {
      return new Promise(async(resolve, reject) => {
        try {

          const reader = new FileReader()
          reader.addEventListener("loadend", () => {
            resolve(reader.result)
          })
          reader.readAsDataURL(input)

        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "file/image-size") {
      return new Promise(async(resolve, reject) => {
        try {

          const reader = new FileReader()
          reader.addEventListener("loadend", () => {
            const canvas = document.createElement("canvas")
            const ctx = canvas.getContext("2d")
            const image = document.createElement("img")
            image.src = reader.result
            image.onload = () => {
              const width = input.size
              const height = input.size * image.height / image.width
              canvas.width = width
              canvas.height = height
              ctx.drawImage(image, 0, 0, width, height)
              resolve(canvas.toDataURL(input.file.type))
            }
          })
          reader.readAsDataURL(input.file)

        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "file/pdf") {
      return new Promise(async(resolve, reject) => {
        try {
          const fileReader = new FileReader()
          fileReader.onload = async(event) => {

            const dataUrlSize = fileReader.result.length
            if (dataUrlSize > 5 * 1024 * 1024) {
              alert("PDF ist zu groß.")
              throw new Error("pdf too large")
            }

            const newFile = {}
            newFile.name = file.name
            newFile.type = file.type
            newFile.size = dataUrlSize
            newFile.modified = Date.now()
            newFile.dataUrl = fileReader.result

            resolve(newFile)
          }
          fileReader.readAsDataURL(input)
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "file/html") {
      return new Promise(async(resolve, reject) => {
        try {

          const fileReader = new FileReader()
          fileReader.onload = async () => {

            const newFile = {}
            newFile.name = input.name
            newFile.type = input.type
            newFile.size = input.size
            newFile.modified = Date.now()
            newFile.svg = fileReader.result

            resolve(newFile)
          }
          fileReader.readAsText(input)

        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "file/svg+xml") {
      return new Promise(async(resolve, reject) => {
        try {

          const fileReader = new FileReader()
          fileReader.onload = async () => {

            const newFile = {}
            newFile.name = input.name
            newFile.type = input.type
            newFile.size = input.size
            newFile.modified = Date.now()
            newFile.svg = fileReader.result

            resolve(newFile)
          }
          fileReader.readAsText(input)

        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "file/svg") {
      return new Promise(async(resolve, reject) => {
        try {
          const fileReader = new FileReader()
          fileReader.onload = async () => {
            const svg = await this.convert("text/first-child", fileReader.result)
            resolve(svg)
          }
          fileReader.readAsText(input)

        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "file/binary") {
      return new Promise(async(resolve, reject) => {
        try {

          const reader = new FileReader()
          reader.onloadend = () => resolve(reader.result)
          reader.readAsArrayBuffer(input)

        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "files/binaries") {
      return new Promise(async(resolve, reject) => {
        try {

          const promises = []
          for (var i = 0; i < input.length; i++) {
            const file = input[i]
            const promise = this.convert("file/binary", file)
            promises.push(promise)
          }

          const results = await Promise.all(promises)

          resolve(results)

        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "select/selected") {

      for (let i = 0; i < input.options.length; i++) {
        const option = input.options[i]
        if (option.selected === true) {
          return option.value
        }
      }

    }

    if (event === "icon/dark-light") {

      if (input.classList.contains("icon")) {
        input.querySelectorAll("*").forEach((child, i) => {
          if (child.hasAttribute("stroke")) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
              child.setAttribute("stroke", `${this.colors.light.text}`)
            } else {
              child.setAttribute("stroke", `${this.colors.dark.text}`)
            }
          }
        })
      }
    }

    if (event === "input/image") {

      return new Promise(async(resolve, reject) => {
        const file = input.files[0]

        const allowedMimeTypes = ["image/jpeg", "image/png"]
        const allowedExtensions = ["jpg", "jpeg", "png"]

        if (allowedMimeTypes !== undefined) {
          await this.verifyIs("file/types", {file, types: allowedMimeTypes})
          .catch(error => {
            alert(`Erlaubte Formate: ${allowedExtensions.join(", ")}`)
            this.add("style/not-valid", input)
            throw error
          })
        }

        if (allowedExtensions !== undefined) {
          await this.verifyIs("file/extensions", {file, extensions: allowedExtensions})
          .catch(error => {
            alert(`Erlaubte Formate: ${allowedExtensions.join(", ")}`)
            this.add("style/not-valid", input)
            throw error
          })
        }

        const dataUrl = await this.convert("file/image-size", {file, size: 2584})
        const dataUrlSize = this.convert("text/length", dataUrl)
        if (dataUrlSize > 1024 * 1024) {
          alert("Datei ist zu groß.")
          this.add("style/not-valid", input)
          throw new Error("image too large")
        }

        const image = {}
        image.name = file.name
        image.type = file.type
        image.size = dataUrlSize
        image.modified = Date.now()
        image.dataUrl = dataUrl
        this.add("style/valid", input)
        return resolve(image)

      })


    }

    if (event === "text/line") {

      let text = input
      text = text.replace(/\s+/g, " ").trim()
      text = text.slice(1, -1).trim()
      const textArray = text.split(",").map(text => text.trim())
      const filtered = textArray.filter(text => !this.verifyIs("text/empty", text))
      const singleLine = filtered.join(", ")
      return `{${singleLine}}`
    }

    if (event === "map/div") {

      return new Promise((resolve, reject) => {

        const div = this.create("info/loading", )
        div.classList.add("json")
        div.style.margin = "21px 34px"

        const buttons = document.createElement("div")
        buttons.classList.add("buttons")
        buttons.style.display = "flex"
        buttons.style.justifyContent = "space-between"
        buttons.style.alignItems = "center"
        div.append(buttons)

        const foldAllButton = this.create("div/action", buttons)
        foldAllButton.textContent = "fold"

        foldAllButton.addEventListener("click", function() {
          toggleAllValues("none");
        });

        const unfoldAllButton = this.create("div/action", buttons)
        unfoldAllButton.textContent = "unfold"
        unfoldAllButton.addEventListener("click", function() {
          toggleAllValues("block");
        });

        function toggleAllValues(displayValue) {
          const valueElements = div.querySelectorAll(".key-value");
          valueElements.forEach(element => {
            element.style.display = displayValue;
          });
        }

        function toggleValue(event) {
          const element = event.target.nextSibling
          if (element !== null) {
            element.style.display = element.style.display === "none" ? "block" : "none";
          }
        }

        function processObject(container, obj) {
          for (const key in obj) {
            const value = obj[key];

            const keyElement = Helper.convert("key/div", key)
            const valueElement = Helper.convert("value/div", value)


            if (Helper.verifyIs("string", value)) {
              valueElement.setAttribute("value-type", "string")
            }


            if (Helper.verifyIs("boolean", value)) {
              valueElement.setAttribute("value-type", "boolean")
            }

            const keyName = document.createElement("div")
            keyName.classList.add("key-name")
            keyName.textContent = key

            keyElement.appendChild(keyName)
            container.appendChild(keyElement);
            keyElement.appendChild(valueElement);

            keyElement.addEventListener("click", toggleValue);

            if (typeof value === "object") {
              processObject(valueElement, value);
              valueElement.addEventListener("click", toggleValue);

            } else {
              valueElement.textContent = JSON.stringify(value);
              // return resolve(div)
              // see render map/div
            }
          }
        }

        processObject(div, input)
      })


    }

    if (event === "map/form") {

      const form = document.createElement("form")
      form.setAttribute("role", "form")
      function createFormElements(it, node) {

        for (const key in it) {
          if (it.hasOwnProperty(key)) {
            const value = it[key]
            const div = document.createElement("div")
            const label = document.createElement("label")
            label.textContent = key
            label.setAttribute("for", key)
            if (Array.isArray(value)) {

              const select = Helper.create(`input/select`)
              select.input.add(value)
              select.input.name = key
              select.input.id = key
              select.input.setAttribute("aria-label", key)
              div.appendChild(label)
              div.appendChild(select)
            }
            else if (typeof value === "object") {

              createFormElements(value, div)
            }
            else {

              if (["checkbox", "date", "email", "file", "number", "password", "range", "tel", "text", "textarea"].includes(value)) {
                const it = Helper.create(`input/${value}`)
                if (value !== "textarea") it.input.type = value
                it.input.name = key
                it.input.id = key
                it.input.setAttribute("aria-label", key)
                div.appendChild(label)
                div.appendChild(it)
              }
            }
            node.appendChild(div)
          }
        }
      }
      createFormElements(input, form)
      return form
    }

    if (event === "html/blob") {
      return new Blob([input], { type: 'text/html' })
    }

    if (event === "key/div") {
      const div = document.createElement("div");
      div.classList.add("json-key")
      div.style.fontFamily = "monospace";
      div.style.cursor = "pointer";
      div.style.fontWeight = "bold";
      div.style.color = "#2e95d3";
      div.style.fontSize = "21px";

      return div
    }

    if (event === "value/div") {
      const div = document.createElement("div");
      div.classList.add("key-value")
      div.style.display = "none";
      div.style.marginLeft = "21px";
      div.style.whiteSpace = "pre-wrap";
      div.style.color = "#ce9178"
      div.style.fontFamily = "monospace"

      return div
    }

    if (event === "json/div") {

      const div = this.create("div/scrollable")
      div.classList.add("json")
      div.style.margin = "21px 34px"
      // div.style.height = "100%"

      const buttons = document.createElement("div")
      buttons.classList.add("buttons")
      buttons.style.display = "flex"
      buttons.style.justifyContent = "space-between"
      buttons.style.alignItems = "center"
      div.append(buttons)

      const foldAllButton = this.create("div/action", buttons)
      foldAllButton.textContent = "fold"

      foldAllButton.addEventListener("click", function() {
        toggleAllValues("none");
      });

      const unfoldAllButton = this.create("div/action", buttons)
      unfoldAllButton.textContent = "unfold"
      unfoldAllButton.addEventListener("click", function() {
        toggleAllValues("block");
      });

      function toggleAllValues(displayValue) {
        const valueElements = div.querySelectorAll(".key-value");
        valueElements.forEach(element => {
          element.style.display = displayValue;
        });
      }

      const jsonObject = JSON.parse(input);

      function toggleValue(event) {
        const element = event.target.nextSibling
        if (element !== null) {
          element.style.display = element.style.display === "none" ? "block" : "none";
        }
      }

      function processObject(container, obj) {
        for (const key in obj) {
          const value = obj[key];

          const keyElement = Helper.convert("key/div", key)
          const valueElement = Helper.convert("value/div", value)


          if (Helper.verifyIs("string", value)) {
            valueElement.setAttribute("value-type", "string")
          }


          if (Helper.verifyIs("boolean", value)) {
            valueElement.setAttribute("value-type", "boolean")
          }

          const keyName = document.createElement("div")
          keyName.classList.add("key-name")
          keyName.textContent = key

          keyElement.appendChild(keyName)
          container.appendChild(keyElement);
          keyElement.appendChild(valueElement);

          keyElement.addEventListener("click", toggleValue);

          if (typeof value === "object") {
            processObject(valueElement, value);
            valueElement.addEventListener("click", toggleValue);

          } else {
            valueElement.textContent = JSON.stringify(value);
          }
        }
      }

      processObject(div, jsonObject);

      return div

    }

    if (event === "map/json") {
      return JSON.stringify(input, null, 2)
    }

    if (event === "field/value") {
      return new Promise(async(resolve, reject) => {

        if (input.fieldInput.tagName === "INPUT") {

          if (input.fieldInput.type === "text") {
            const map = {}
            map[input.fieldId] = input.fieldInput.value
            return resolve(map)
          }

          if (input.fieldInput.type === "email") {
            const map = {}
            map[input.fieldId] = input.fieldInput.value
            return resolve(map)
          }

          if (input.fieldInput.type === "tel") {
            const map = {}
            map[input.fieldId] = input.fieldInput.value
            return resolve(map)
          }

          if (input.fieldInput.type === "range") {
            const map = {}
            map[input.fieldId] = input.fieldInput.value
            return resolve(map)
          }

          if (input.fieldInput.type === "password") {
            const map = {}
            map[input.fieldId] = input.fieldInput.value
            return resolve(map)
          }

          if (input.fieldInput.type === "number") {
            const map = {}
            map[input.fieldId] = input.fieldInput.value
            return resolve(map)
          }

          if (input.fieldInput.type === "file") {

            const promises = []
            for (let i = 0; i < input.fieldInput.files.length; i++) {
              const file = input.fieldInput.files[i]
              const promise = this.convert("file/type", file)

              promises.push(promise)
            }

            const results = await Promise.all(promises)

            const map = {}
            map[input.fieldId] = results
            return resolve(map)
          }

          if (input.fieldInput.type === "date") {
            const map = {}
            map[input.fieldId] = input.fieldInput.value
            return resolve(map)
          }

          if (input.fieldInput.type === "checkbox") {
            const map = {}
            map[input.fieldId] = input.fieldInput.checked
            return resolve(map)
          }

        }

        if (input.fieldInput.tagName === "TEXTAREA") {
          const map = {}
          map[input.fieldId] = input.fieldInput.value
          return resolve(map)
        }

        if (input.fieldInput.tagName === "SELECT") {
          const selected = []
          for (let i = 0; i < input.fieldInput.options.length; i++) {
            const option = input.fieldInput.options[i]
            if (option.selected === true) {
              selected.push(option.value)
            }
          }
          const map = {}
          map[input.fieldId] = selected
          return resolve(map)
        }

      })
    }

    if (event === "field/on-info-click") {

      const labelContainer = input.querySelector(".field-label-container")
      this.add("outline-hover", labelContainer)
      const label = input.querySelector(".field-label")
      if (input.querySelector(".field-image") === null) {
        const image = document.createElement("div")
        image.classList.add("field-image")
        image.style.width = "34px"
        image.style.marginRight = "21px"
        this.render("icon/node/path", "/public/info-circle.svg", image)
        label.before(image)
      }
      labelContainer.style.cursor = "pointer"
      labelContainer.childNodes.forEach(child => child.style.cursor = "pointer")
      labelContainer.onclick = () => {

        this.overlay("info", async overlay => {
          const content = this.create("div/scrollable", overlay)
          content.innerHTML = await Helper.convert("text/purified", input.getAttribute("on-info-click"))
        })
      }
    }

    if (event === "field-input/key-value") {
      return new Promise(async(resolve, reject) => {

        if (input.fieldInput.tagName === "INPUT") {

          if (input.fieldInput.type === "text") {
            const map = {}
            map[input.fieldId] = input.fieldInput.value
            return resolve(map)
          }

          if (input.fieldInput.type === "email") {
            const map = {}
            map[input.fieldId] = input.fieldInput.value
            return resolve(map)
          }

          if (input.fieldInput.type === "tel") {
            const map = {}
            map[input.fieldId] = input.fieldInput.value
            return resolve(map)
          }

          if (input.fieldInput.type === "range") {
            const map = {}
            map[input.fieldId] = input.fieldInput.value
            return resolve(map)
          }

          if (input.fieldInput.type === "password") {
            const map = {}
            map[input.fieldId] = input.fieldInput.value
            return resolve(map)
          }

          if (input.fieldInput.type === "number") {
            const map = {}
            map[input.fieldId] = input.fieldInput.value
            return resolve(map)
          }

          if (input.fieldInput.type === "file") {

            const promises = []
            for (let i = 0; i < input.fieldInput.files.length; i++) {
              const file = input.fieldInput.files[i]
              const promise = this.convert("file/type", file)

              promises.push(promise)
            }

            const results = await Promise.all(promises)

            const map = {}
            map[input.fieldId] = results
            return resolve(map)
          }

          if (input.fieldInput.type === "date") {
            const map = {}
            map[input.fieldId] = input.fieldInput.value
            return resolve(map)
          }

          if (input.fieldInput.type === "checkbox") {
            const map = {}
            map[input.fieldId] = input.fieldInput.checked
            return resolve(map)
          }

        }

        if (input.fieldInput.tagName === "TEXTAREA") {
          const map = {}
          map[input.fieldId] = input.fieldInput.value
          return resolve(map)
        }

        if (input.fieldInput.tagName === "SELECT") {
          const selected = []
          for (let i = 0; i < input.fieldInput.options.length; i++) {
            const option = input.fieldInput.options[i]
            if (option.selected === true) {
              selected.push(option.value)
            }
          }
          const map = {}
          map[input.fieldId] = selected
          return resolve(map)
        }

      })
    }

    if (event === "field-funnel/trees") {
      return new Promise(async(resolve, reject) => {

        try {

          if (this.verifyIs("tag/empty", input.id)) {
            window.alert("Field Funnel ist nicht gültig: id ist kein tag")
            throw new Error("field funnel id is empty")
          }

          const trees = []
          input.querySelectorAll(".field").forEach(field => {


            if (this.verifyIs("tag/empty", field.id)) {
              window.alert("Datenfeld ist nicht gültig: id ist kein tag")
              throw new Error("field id is empty")
            }

            trees.push(`${window.location.pathname.split("/")[2]}.${input.id}.${field.id}`)

          })

          resolve(trees)

        } catch (error) {
          return reject(error)
        }

      })
    }

    if (event === "field-funnel/map") {
      return new Promise(async(resolve, reject) => {

        try {

          const res = await this.verifyIs("field-funnel/valid", input)

          if (res === true) {

            const promises = []
            input.querySelectorAll(".field").forEach(field => {

              if (this.verifyIs("tag/empty", field.id)) {
                window.alert("Datenfeld ist nicht gültig: id ist kein tag")
                return reject(new Error("field tag is empty"))
              }

              field.querySelectorAll(".field-input").forEach(fieldInput => {

                const map = {}
                map.fieldId = field.id
                map.fieldInput = fieldInput

                const promise = this.convert("field-input/key-value", map)

                promises.push(promise)

              })

            })

            const results = await Promise.all(promises)

            const map = results.reduce((result, keyValue) => {
              return { ...result, ...keyValue }
            }, {})

            return resolve(map)

          } else {
            return reject(new Error("funnel invalid"))
          }

        } catch (error) {
          return reject(error)
        }

      })
    }

    if (event === "file/type") {

      if (input.type === "image/png") {
        return new Promise(async (resolve, reject) => {
          const allowedMimeTypes = ["image/png"]
          const allowedExtensions = ["png"]

          await this.verifyIs("file/types", {file: input, types: allowedMimeTypes})
          .catch(error => {
            alert(`Erlaubte Formate: ${allowedExtensions.join(", ")}`)
            return reject(error)
          })

          await this.verifyIs("file/extensions", {file: input, extensions: allowedExtensions})
          .catch(error => {
            alert(`Erlaubte Formate: ${allowedExtensions.join(", ")}`)
            return reject(error)
          })

          const fileReader = new FileReader()
          fileReader.onload = () => {

            const dataUrlSize = this.convert("text/length", fileReader.result)
            if (dataUrlSize > 5 * 1024 * 1024) {
              window.alert("Datei ist zu groß: max 5MB")
              return reject(new Error("file too large"))
            }

            const map = {}
            map.name = input.name
            map.type = input.type
            map.size = dataUrlSize
            map.modified = Date.now()
            map.dataUrl = fileReader.result

            return resolve(map)
          }
          fileReader.readAsDataURL(input)

        })
      }

      if (input.type === "image/jpeg") {
        return new Promise(async (resolve, reject) => {
          const allowedMimeTypes = ["image/jpeg"]
          const allowedExtensions = ["jpg", "jpeg"]

          await this.verifyIs("file/types", {file: input, types: allowedMimeTypes})
          .catch(error => {
            alert(`Erlaubte Formate: ${allowedExtensions.join(", ")}`)
            return reject(error)
          })

          await this.verifyIs("file/extensions", {file: input, extensions: allowedExtensions})
          .catch(error => {
            alert(`Erlaubte Formate: ${allowedExtensions.join(", ")}`)
            return reject(error)
          })

          const fileReader = new FileReader()
          fileReader.onload = () => {

            const dataUrlSize = this.convert("text/length", fileReader.result)
            if (dataUrlSize > 5 * 1024 * 1024) {
              window.alert("Datei ist zu groß: max 5MB")
              return reject(new Error("file too large"))
            }

            const map = {}
            map.name = input.name
            map.type = input.type
            map.size = dataUrlSize
            map.modified = Date.now()
            map.dataUrl = fileReader.result

            return resolve(map)
          }
          fileReader.readAsDataURL(input)

        })
      }

      if (input.type === "application/pdf") {
        return new Promise(async (resolve, reject) => {
          const allowedMimeTypes = ["application/pdf"]
          const allowedExtensions = ["pdf"]

          await this.verifyIs("file/types", {file: input, types: allowedMimeTypes})
          .catch(error => {
            alert(`Erlaubte Formate: ${allowedExtensions.join(", ")}`)
            return reject(error)
          })

          await this.verifyIs("file/extensions", {file: input, extensions: allowedExtensions})
          .catch(error => {
            alert(`Erlaubte Formate: ${allowedExtensions.join(", ")}`)
            return reject(error)
          })

          const fileReader = new FileReader()
          fileReader.onload = () => {

            const dataUrlSize = this.convert("text/length", fileReader.result)
            if (dataUrlSize > 5 * 1024 * 1024) {
              window.alert("Datei ist zu groß: max 5MB")
              return reject(new Error("file too large"))
            }

            const map = {}
            map.name = input.name
            map.type = input.type
            map.size = dataUrlSize
            map.modified = Date.now()
            map.dataUrl = fileReader.result

            return resolve(map)
          }
          fileReader.readAsDataURL(input)

        })
      }

      if (input.type === "text/html") {
        return new Promise(async (resolve, reject) => {
          const allowedMimeTypes = ["text/html"]
          const allowedExtensions = ["html"]

          await this.verifyIs("file/types", {file: input, types: allowedMimeTypes})
          .catch(error => {
            alert(`Erlaubte Formate: ${allowedExtensions.join(", ")}`)
            return reject(error)
          })

          await this.verifyIs("file/extensions", {file: input, extensions: allowedExtensions})
          .catch(error => {
            alert(`Erlaubte Formate: ${allowedExtensions.join(", ")}`)
            return reject(error)
          })

          const fileReader = new FileReader()
          fileReader.onload = () => {

            const map = {}
            map.name = input.name
            map.type = input.type
            map.size = input.size
            map.modified = Date.now()
            map.html = this.convert("text/sanitized-html", fileReader.result)

            return resolve(map)
          }
          fileReader.readAsText(input)

        })
      }

      if (input.type === "image/svg+xml") {
        return new Promise(async (resolve, reject) => {
          const allowedMimeTypes = ["image/svg+xml"]
          const allowedExtensions = ["svg"]

          await this.verifyIs("file/types", {file: input, types: allowedMimeTypes})
          .catch(error => {
            window.alert(`Erlaubte Formate: ${allowedExtensions.join(", ")}`)
            return reject(error)
          })

          await this.verifyIs("file/extensions", {file: input, extensions: allowedExtensions})
          .catch(error => {
            window.alert(`Erlaubte Formate: ${allowedExtensions.join(", ")}`)
            return reject(error)
          })

          const fileReader = new FileReader()
          fileReader.onload = () => {

            const map = {}
            map.name = input.name
            map.type = input.type
            map.size = input.size
            map.modified = Date.now()
            map.svg = this.convert("text/sanitized-html", fileReader.result)

            return resolve(map)
          }
          fileReader.readAsText(input)

        })
      }
    }

    if (event === "funnel/map") {

      if (input.id) {
        const map = {}
        map[input.id] = {}
        input.querySelectorAll("*").forEach(node => {
          if (this.verifyIs("tag/empty", node.id)) return
          map[input.id][node.id] = node.children[0].value
        })
        return map
      } else {
        window.alert("Funnel Id ist ungültig.")
      }
    }

    if (event === "doc/design-mode") {

      const currentMode = document.designMode
      document.designMode = currentMode === "on" ? "off" : "on"
      window.alert("Design Modus wurde erfolgreich umgeschaltet.")

    }

    if (event === "link/dark-light") {

      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        input.style.color = this.colors.link.active
      } else {
        input.style.color = this.colors.link.color
      }
    }

    if (event === "styles/text") {
      const styles = input.style
      const div = document.createElement("div")
      for (let i = 0; i < styles.length; i++) {
        const key = styles[i]
        const value = styles.getPropertyValue(key)
        div.append(`${key}: ${value};\n`)
      }
      return div.textContent

    }

    if (event === "clipboard/text") {
      return navigator.clipboard.readText()
    }

    if (event === "node-text/width") {
      const canvas = document.createElement("canvas")
      const context = canvas.getContext("2d")
      context.font = window.getComputedStyle(input.node).getPropertyValue("font")
      const metrics = context.measureText(input.text)
      return metrics.width
    }

    if (event === "node-text/slice-width") {

      let node = input.node
      let text = input.text
      let width = this.convert("node-text/width", {node, text})
      let greaterThanWidth = false

      while (width > input.width) {
        text = text.slice(0, -1)
        node.textContent = text
        width = this.convert("node-text/width", {node, text})
        greaterThanWidth = true
      }

      if (greaterThanWidth) {
        node.textContent = `${text} ..`
      } else {
        node.textContent = text
      }
      return text

    }

    if (event === "number/de") {

      const de = {
        1: "eins",
        2: "zwei",
        3: "drei",
        4: "vier",
        5: "fuenf",
        6: "sechs",
        7: "sieben",
        8: "acht",
        9: "neun",
      }
      return de[input] || undefined
    }

    if (event === "path/field-funnel") {
      return new Promise(async(resolve, reject) => {
        try {
          const text = await this.convert("path/text", input)
          const doc = this.convert("text/doc", text)
          const fieldFunnel = doc.querySelector(".field-funnel")
          if (fieldFunnel) {
            resolve(fieldFunnel)
          }

        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "path/icon") {

      return new Promise(async(resolve, reject) => {
        try {
          const text = await this.convert("path/text", input)
          const icon = this.create("div")
          icon.className = "icon"
          icon.style.display = "flex"
          icon.style.justifyContent = "center"
          icon.style.alignItems = "center"
          icon.style.width = "34px"
          const svg = await this.convert("text/first-child", text)
          svg.setAttribute("width", "100%")
          this.convert("svg/dark-light", svg)
          //
          // for (let i = 0; i < svg.querySelectorAll("*").length; i++) {
          //   const node = svg.querySelectorAll("*")[i]
          //   if (node.hasAttribute("fill")) {
          //     if (node.getAttribute("fill").includes("#000")) {
          //       if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
          //         node.setAttribute("fill", this.colors.dark.text)
          //       } else {
          //         node.setAttribute("fill", this.colors.light.text)
          //       }
          //     }
          //   }
          //   if (node.hasAttribute("stroke")) {
          //     if (node.getAttribute("stroke").includes("#000")) {
          //       if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
          //         node.setAttribute("stroke", this.colors.dark.text)
          //       } else {
          //         node.setAttribute("stroke", this.colors.light.text)
          //       }
          //     }
          //   }
          // }
          // if (svg.hasAttribute("fill")) {
          //   if (svg.getAttribute("fill").includes("#000")) {
          //     if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
          //       svg.setAttribute("fill", this.colors.dark.text)
          //     } else {
          //       svg.setAttribute("fill", this.colors.light.text)
          //     }
          //   }
          // }
          // if (svg.hasAttribute("stroke")) {
          //   if (svg.getAttribute("stroke").includes("#000")) {
          //     if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
          //       svg.setAttribute("stroke", this.colors.dark.text)
          //     } else {
          //       svg.setAttribute("stroke", this.colors.light.text)
          //     }
          //   }
          // }
          //
          //
          icon.append(svg)
          resolve(icon)
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "path/text") {
      return new Promise(async(resolve, reject) => {
        try {
          const response = await fetch(input)
          if (!response.ok) {
            throw new Error(`Failed to fetch: ${response.status} ${response.statusText}`)
          }
          const result = await response.text()
          resolve(result)
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "style/flex-row") {
      input.textContent = ""
      input.removeAttribute("style")
      this.style(input, {display: "flex", flexDirection: "row", flexWrap: "wrap"})
    }

    if (event === "tag/tree") {

      return input.replaceAll("-", ".")
    }

    if (event === "text/boolean") {

      if (input === "true" || input === "false") {
        return true
      } else {
        return false
      }
    }

    if (event === "text/clipboard") {
      return navigator.clipboard.writeText(input)
    }

    if (event === "text/dark-light") {

      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        input.style.color = this.colors.dark.text
      } else {
        input.style.color = this.colors.light.text
      }
    }

    if (event === "text/digest") {
      return new Promise(async(resolve, reject) => {
        try {
          const data = new TextEncoder().encode(input)
          const hashBuffer = await crypto.subtle.digest('SHA-256', data)
          const hashArray = Array.from(new Uint8Array(hashBuffer))
          const hashHex = hashArray.map((b) => b.toString(16).padStart(2, '0')).join('')
          resolve(hashHex)
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "text/js") {
      return new Promise((resolve, reject) => {
        try {
          eval(input)
          resolve()
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "text/marked") {

      const fragment = document.createDocumentFragment()
      input.text.split(new RegExp(`(${input.query})`, 'gi')).forEach(part => {
        const span = document.createElement('span')
        if (part.toLowerCase() === input.query.toLowerCase()) {
          span.style.background = this.colors.matte.orange
        }
        span.appendChild(document.createTextNode(part))
        fragment.appendChild(span)
      })
      if (input.parent) {
        input.parent.textContent = ""
        input.parent.appendChild(fragment)
      }
      return fragment
    }

    if (event === "text/number") {

      return Number(input)
    }

    if (event === "text/doc") {

      const parser = new DOMParser()
      const doc = parser.parseFromString(input, "text/html")
      return doc
    }

    if (event === "text/document") {
      return new Promise((resolve, reject) => {

        try {
          document.open()
          document.write(input)
          document.close()
          return resolve()
        } catch (error) {
          return reject(error)
        }

      })
    }

    if (event === "text/first-child") {

      return new Promise(async(resolve, reject) => {
        try {
          const parser = document.createElement("div")
          parser.innerHTML = await Helper.convert("text/purified", input)
          resolve(parser.children[0])
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "text/fragment") {
      const fragment = document.createDocumentFragment()
      const parser = document.createElement("div")
      parser.innerHTML = input
      fragment.appendChild(parser.firstChild)
      return fragment
    }

    if (event === "text/purified") {

      return new Promise(async(resolve, reject) => {
        try {
          await import("/js/purify.min.js")
          const purified = DOMPurify.sanitize(input)
          resolve(purified)
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "text/sanitized") {
      const parser = document.createElement("div")
      parser.textContent = input
      return parser.innerHTML
    }

    if (event === "text/script") {

      const fragment = this.convert("text/fragment", input)
      return fragment.querySelector("script")
    }

    if (event === "text/prompt") {

      const promptRegex = /prompt\(([^)]+)\)/g
      let match
      const matches = []
      while ((match = promptRegex.exec(input)) !== null) {
        matches.push(match)
      }
      matches.forEach(match => {
        const id = match[1]
        const userInput = window.prompt(`Ersetze den Text für die Id: "${id}"`)
        input = input.replace(`prompt(${id})`, userInput)
      })
      return input
    }

    if (event === "js/script") {

      const script = document.createElement("script")
      script.textContent = input
      return script

    }

    if (event === "uri/text") {

      input.replace(/%20/g, "-")
      input.replace(/u%CC%88/g, "ue")
      input.replace(/a%CC%88/g, "ae")
      input.replace(/o%CC%88/g, "oe")
      input.replace(/%2F/g, "-")
      input.replace(/%C3%A4/g, "ae")
      input.replace(/%C3%BC/g, "ue")
      input.replace(/\(/g, "")
      input.replace(/\)/g, "")
      input.replace(/%C3%B6/g, "oe")
      input.replace(/%C3%96/g, "Oe")
      input.replace(/\./g, "-")
      input.replace(/%C3%9F/g, "ss")
      input.replace(/%3F/g, "")
      input.replace(/-$/g, "")

      return input
    }

    if (event === "text/tag") {
      input = input.toLowerCase()
      input = input.replaceAll(" ", "-")
      input = input.replaceAll("ö", "oe")
      input = input.replaceAll("ä", "ae")
      input = input.replaceAll("ü", "ue")
      input = input.replace(/[^a-z-]/g, '')
      input = input.replace(/-+/g, '-')
      if (input.startsWith("-")) input = input.slice(1)
      if (input.endsWith("-")) input = input.slice(0, -1)
      return input
    }

    if (event === "text/uri") {
      return encodeURIComponent(input)
    }

    if (event === "text/sanitized-html") {
      // events
      input = input.replace(/on\w+="[^"]*"/gi, "")

      // chars
      input = input.replace(/{{(.*?)}}/g, "")
      input = input.replace(/\[\[(.*?)\]\]/g, "")

      // attributes
      input = input.replace(/src=["'`](.*?)["'`]/gi, "")
      input = input.replace(/href=["'`](.*?)["'`]/gi, "")

      // css
      input = input.replace(/expression\([^)]*\)/gi, "")
      input = input.replace(/url\((['"]?)(.*?)\1\)/gi, "")

      // js
      input = input.replace(/javascript:/gi, "")

      // tags
      input = input.replace(/<img\b[^>]*>/gi, "")
      input = input.replace(/<link\b[^>]*>/gi, "")
      input = input.replace(/<input\b[^>]*>/gi, "")
      input = input.replace(/<a\b[^>]*>/gi, "")
      input = input.replace(/<meta\b[^>]*>/gi, "")
      input = input.replace(/<datalist\b[^>]*>/gi, "")
      input = input.replace(/<source\b[^>]*>/gi, "")
      input = input.replace(/<progress\b[^>]*>/gi, "")
      input = input.replace(/<details\b[^>]*>/gi, "")
      input = input.replace(/<summary\b[^>]*>/gi, "")
      input = input.replace(/<script\b[^>]*>/gi, "")
      input = input.replace(/<iframe\b[^>]*>/gi, "")
      input = input.replace(/<object\b[^>]*>/gi, "")
      input = input.replace(/<embed\b[^>]*>/gi, "")
      input = input.replace(/<form\b[^>]*>/gi, "")
      input = input.replace(/<textarea\b[^>]*>/gi, "")
      input = input.replace(/<select\b[^>]*>/gi, "")
      input = input.replace(/<button\b[^>]*>/gi, "")
      input = input.replace(/<base\b[^>]*>/gi, "")
      input = input.replace(/<frame\b[^>]*>/gi, "")
      input = input.replace(/<frameset\b[^>]*>/gi, "")
      input = input.replace(/<applet\b[^>]*>/gi, "")
      input = input.replace(/<audio\b[^>]*>/gi, "")
      input = input.replace(/<video\b[^>]*>/gi, "")
      input = input.replace(/<source\b[^>]*>/gi, "")
      input = input.replace(/<track\b[^>]*>/gi, "")
      input = input.replace(/<canvas\b[^>]*>/gi, "")
      input = input.replace(/<svg\b[^>]*>/gi, "")
      input = input.replace(/<math\b[^>]*>/gi, "")
      input = input.replace(/<template\b[^>]*>/gi, "")
      input = input.replace(/<noscript\b[^>]*>/gi, "")
      input = input.replace(/<noembed\b[^>]*>/gi, "")
      input = input.replace(/<plaintext\b[^>]*>/gi, "")
      input = input.replace(/<marquee\b[^>]*>/gi, "")
      input = input.replace(/<blink\b[^>]*>/gi, "")
      input = input.replace(/<layer\b[^>]*>/gi, "")
      input = input.replace(/<ilayer\b[^>]*>/gi, "")
      input = input.replace(/<basefont\b[^>]*>/gi, "")
      input = input.replace(/<isindex\b[^>]*>/gi, "")
      input = input.replace(/<keygen\b[^>]*>/gi, "")
      input = input.replace(/<command\b[^>]*>/gi, "")

      return input
    }

    if (event === "text/length") {
      return input.length
    }

    if (event === "text/child-nodes") {

      const parser = new DOMParser()
      const doc = parser.parseFromString(input, "text/html")
      return Array.from(doc.body.childNodes)
    }

    if (event === "text/html") {

      const parser = new DOMParser()
      const doc = parser.parseFromString(input, "text/html")
      return doc.body.firstChild
    }

    if (event === "text/field") {

      if (input === "text") {
        return this.create("field/text")
      }

      if (input === "textarea") {
        return this.create("field/textarea")
      }

      if (input === "email") {
        return this.create("field/email")
      }

      if (input === "tel") {
        return this.create("field/tel")
      }

      if (input === "range") {
        return this.create("field/range")
      }

      if (input === "password") {
        return this.create("field/password")
      }

      if (input === "number") {
        return this.create("field/number")
      }

      if (input === "file") {
        return this.create("field/file")
      }

      if (input === "date") {
        return this.create("field/date")
      }

      if (input === "checkbox") {
        return this.create("field/checkbox")
      }

      if (input === "select") {
        return this.create("field/select")
      }

    }

    if (event === "text/h2") {

      const h2 = document.createElement("h2")
      h2.textContent = input
      h2.style.fontFamily = "sans-serif"

      h2.style.color = this.colors.light.text
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        h2.style.color = this.colors.dark.text
      }

      return h2
    }

    if (event === "text/img") {
      const img = document.createElement("img")
      img.src = input
      return img
    }

    if (event === "text/sources") {

      return new Promise(async(resolve, reject) => {
        try {
          let apis
          if (this.verifyIs("text/isbn", input)) {
            apis = [
              `https://openlibrary.org/isbn/${input}.json`,
              `https://www.googleapis.com/books/v1/volumes?q=isbn:${input}`,
            ]
          } else {
            apis = [
              `https://openlibrary.org/search.json?title=${encodeURIComponent(input)}`,
              `https://www.googleapis.com/books/v1/volumes?q=intitle:${encodeURIComponent(input)}`,
              `https://archive.org/advancedsearch.php?q=title:(${encodeURIComponent(input)})&output=json`,
            ]
          }
          const promises = []
          for (let i = 0; i < apis.length; i++) {
            const api = apis[i]
            try {
              const promise = this.convert("api/sources", api)
              promises.push(promise)
            } catch (error) {
              continue
            }

          }
          const results = await Promise.all(promises)
          const sources = [].concat(...results)
          resolve(sources)
        } catch (error) {
          reject(error)
        }
      })

    }

    if (event === "text/span") {
      const span = document.createElement("span")
      span.textContent = input

      return span
    }

    if (event === "text/capital-first-letter") {
      return input.charAt(0).toUpperCase() + input.slice(1)
    }

    if (event === "text/type") {

      if (this.verifyIs("text/boolean", input)) return "boolean"
      if (this.verifyIs("text/number", input)) return "number"
      if (!this.verifyIs("text/empty", input)) return "text"
    }

    if (event === "tree/class") {
      return input.replace(/\./g, "-")
    }

    if (event === "tree/key") {

      const keys = input.split(".")
      if (keys.length > 0) {
        return keys[keys.length - 1]
      } else {
        return input
      }
    }

    if (event === "user-tree") {

      let {user, tree} = input
      const pathArray = tree.split('.')
      for (let i = 0; i < pathArray.length; i++) {
        const key = pathArray[i]
        if (i + 1 === pathArray.length) {
          if (user[key] !== undefined) return user[key]
        }
        if (user[key] !== undefined) {
          user = user[key]
        }
      }
    }

    if (event === "parent/box") {

      input.style.padding = "13px"
      input.style.borderRadius = "13px"
      input.style.cursor = "pointer"
      this.convert("box/dark-light", input)
      this.add("outline-hover", input)
      return input
    }

    if (event === "parent/note") {

      if (input) {
        input.textContent = ""
        input.removeAttribute("style")
        input.className = "dark-light sans-serif center"
        return input
      }
    }

    if (event === "parent/space-around") {

      input.style.display = "flex"
      input.style.flexWrap = "wrap"
      input.style.justifyContent = "space-around"

      return input
    }

    if (event === "parent/space-between") {

      input.style.display = "flex"
      input.style.flexWrap = "wrap"
      input.style.justifyContent = "space-between"

      return input
    }

    if (event === "parent/flex-around") {

      this.convert("element/reset", input)
      input.style.display = "flex"
      input.style.flexWrap = "wrap"
      input.style.justifyContent = "space-around"
    }

    if (event === "parent/flex-shrink-height") {

      input.style.alignSelf = null

      return input
    }

    if (event === "parent/flex-shrink-width") {

      input.style.width = null

      return input
    }

    if (event === "parent/flex-grow-height") {

      input.style.alignSelf = "stretch"

      return input
    }

    if (event === "parent/flex-grow-width") {

      input.style.width = "100%"

      return input
    }

    if (event === "parent/flex-bottom") {

      input.style.display = "flex"
      input.style.alignItems = "flex-end"

      return input
    }

    if (event === "parent/flex-vertical") {

      input.style.display = "flex"
      input.style.alignItems = "center"

      return input
    }

    if (event === "parent/flex-top") {

      input.style.display = "flex"
      input.style.alignItems = "flex-start"

      return input
    }

    if (event === "parent/flex-right") {

      input.style.display = "flex"
      input.style.alignItems = "flex-end"
      input.style.flexWrap = "wrap"

      return input
    }

    if (event === "parent/flex-center") {

      input.style.display = "flex"
      input.style.alignItems = "center"
      input.style.flexWrap = "wrap"

      return input
    }

    if (event === "parent/flex-left") {

      input.style.display = "flex"
      input.style.alignItems = "flex-start"
      input.style.flexWrap = "wrap"

      return input
    }

    if (event === "parent/flex-column") {

      input.style.flexWrap = null

      input.style.display = "flex"
      input.style.flexDirection = "column"

      return input
    }

    if (event === "parent/flex-row") {

      this.convert("element/reset", input)
      input.style.display = "flex"
      input.style.flexWrap = "wrap"
      return input
    }

    if (event === "parent/dark") {

      input.style.color = this.colors.dark.text
      input.style.background = this.colors.dark.background
    }

    if (event === "button/left-right") {

      input.style.display = "flex"
      input.style.flexWrap = "wrap"
      input.style.justifyContent = "space-between"
      input.style.alignItems = "center"
      input.style.margin = "21px 34px"
      input.style.borderRadius = "13px"
      input.style.cursor = "pointer"
      input.left.style.margin = "21px 34px"
      input.left.style.fontSize = "21px"
      input.left.style.fontFamily = "sans-serif"
      input.left.style.overflow = "auto"
      input.right.style.margin = "21px 34px"
      input.right.style.fontSize = "13px"
      input.right.style.fontFamily = "sans-serif"
      this.convert("button/dark-light", input)
    }

    if (event === "parent/light") {

      input.style.color = this.colors.light.text
      input.style.background = this.colors.light.background
    }

    if (event === "parent/loading") {

      this.convert("element/reset", input)
      input.style.display = "flex"
      input.style.flexDirection = "column"
      input.style.justifyContent = "center"
      input.style.alignItems = "center"
      input.style.height = "100%"
      input.loading = this.create("div", input)
      this.render("icon/node/path", "/public/loading.svg", input.loading).then(icon => {
        const svg = icon.querySelector("svg")
        svg.style.fill = this.colors.light.error
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
          svg.style.fill = this.colors.dark.error
        }
      })
      input.loading.style.fill = this.colors.light.error
      input.loading.style.width = "55px"
      input.loading.style.margin = "8px"
      input.info = this.create("div", input)
      input.info.textContent = "Das kann einen Moment dauern .."
      input.info.style.color = this.colors.light.error
      input.info.style.fontSize = "13px"
      input.info.style.fontFamily = "sans-serif"
      return input

    }

    if (event === "parent/scrollable") {

      if (input) {
        this.convert("element/reset", input)
        input.style.overflowY = "auto"
        input.style.overscrollBehavior = "none"
        input.style.paddingBottom = "144px"
        return input
      }
    }

    if (event === "parent/info") {
      this.convert("element/reset", input)
      input.style.position = "absolute"
      input.style.top = "0"
      input.style.left = "0"
      input.style.height = "89vh"
      input.style.width = "100%"
      input.style.display = "flex"
      input.style.justifyContent = "center"
      input.style.alignItems = "center"
      input.style.zIndex = "-1"
      input.style.fontFamily = "sans-serif"
      input.style.textAlign = "center"

      input.style.color = "gray"

      return input
    }

    if (event === "script/disabled-aware") {

      if (this.verifyIs("text/empty", input.id)) {
        const confirm = window.confirm("Dein Skript hat keine Id. Möchtest du deinem Skript eine Id vergeben?")
        if (confirm) {
          const prompt = window.prompt("Gebe eine Id ein:")
          if (!this.verifyIs("text/empty", prompt)) {
            input.id = prompt
          }
        } else {
          window.alert("Dein Skript braucht eine Id um es schaltbar zu machen.")
          throw new Error("script id required")
        }
      }

      const first = `import {Helper} from "/js/Helper.js"`
      const second = `if (Helper.verifyIs("script-id/disabled", "${input.id}")) throw new Error("script#${input.id} disabled")`

      if (!input.textContent.includes(second)) {
        let text = input.textContent

        if (input.textContent.includes(first)) {
          const regex = new RegExp(`.*${first}.*\n`, "g")
          text = text.replace(regex, "")
        }

        text = first + "\n" + second + "\n" + text
        input.textContent = text
      }

      if (input.textContent.includes("Helper")) {
        input.type = "module"
      } else {
        input.type = "text/javascript"
      }

      return input
    }

    if (event === "script/disabled") {

      this.convert("script/disabled-aware", input)

      const scripts = JSON.parse(window.localStorage.getItem("scripts")) || []
      const map = {}
      map.id = input.id
      map.disabled = true
      scripts.unshift(map)
      window.localStorage.setItem("scripts", JSON.stringify(scripts))
      window.alert("Skript wurde ausgeschaltet.")
    }

    if (event === "script/enabled") {

      this.convert("script/disabled-aware", input)

      const scripts = JSON.parse(window.localStorage.getItem("scripts")) || []
      for (let i = 0; i < scripts.length; i++) {
        const script = scripts[i]
        if (script.id === input.id) {
          scripts.splice(i, 1)
          window.localStorage.setItem("scripts", JSON.stringify(scripts))
          window.alert("Skript wurde eingeschaltet.")
        }
      }

    }

    if (event === "selector/dark-light") {
      const node = document.querySelector(input)
      if (node) {
        this.convert("dark-light", node)
      }
    }

    if (event === "style/flex-row") {

      input.removeAttribute("style")
      input.style.display = "flex"
      input.style.flexWrap = "wrap"
      return input
    }

    if (event === "style/info") {

      input.removeAttribute("style")
      input.textContent = ""
      input.style.margin = "21px 34px"
      input.style.display = "flex"
      input.style.justifyContent = "center"
      input.style.alignItems = "center"
      input.style.fontFamily = "sans-serif"
      input.style.fontSize = "21px"
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        input.style.color = this.colors.dark.text
      } else {
        input.style.color = this.colors.light.text
      }
      return input
    }

    if (event === "style/scrollable") {
      input.removeAttribute("style")
      input.style.overflow = "auto"
      input.style.overscrollBehavior = "none"
      input.style.paddingBottom = "144px"
      return input
    }

    if (event === "element/button-right") {
      this.convert("element/reset", input)
      input.style.margin = "21px 34px"
      input.style.fontSize = "13px"
      input.style.fontFamily = "sans-serif"

      input.style.color = this.colors.light.text
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        input.style.color = this.colors.dark.text
      }

      return input
    }

    if (event === "element/checked") {
      this.convert("element/reset", input)
      input.textContent = "✓"
      input.style.margin = "21px 34px"
      input.style.color = "#00c853"
      input.style.fontSize = "34px"
      input.style.fontFamily = "sans-serif"
      return input
    }

    if (event === "element/scrollable") {
      this.convert("element/reset", input)
      input.style.overflowY = "auto"
      input.style.overscrollBehavior = "none"
      input.style.paddingBottom = "144px"
      return input
    }

    if (event === "millis/since") {

      function formatTimeSince(milliseconds) {
        const now = Date.now();
        const elapsed = now - milliseconds;

        const msInMinute = 60 * 1000;
        const msInHour = 60 * msInMinute;
        const msInDay = 24 * msInHour;
        const msInMonth = 30 * msInDay;
        const msInYear = 12 * msInMonth;

        if (elapsed >= msInYear) {
          const years = Math.floor(elapsed / msInYear);
          return `${years} Jahr${years !== 1 ? 'en' : ''}`;
        } else if (elapsed >= msInMonth) {
          const months = Math.floor(elapsed / msInMonth);
          return `${months} Monat${months !== 1 ? 'en' : ''}`;
        } else if (elapsed >= msInDay) {
          const days = Math.floor(elapsed / msInDay);
          return `${days} Tag${days !== 1 ? 'en' : ''}`;
        } else {
          const hours = Math.floor(elapsed / msInHour);
          const minutes = Math.floor((elapsed % msInHour) / msInMinute);
          return `${hours} Stunde${hours !== 1 ? 'n' : ''} ${minutes} Minute${minutes !== 1 ? 'n' : ''}`;
        }
      }

      return formatTimeSince(input)
    }

    if (event === "millis/dd.mm.yyyy hh:mm") {
      const date = new Date(input)

      const day = date.getDate().toString().padStart(2, "0")
      const month = (date.getMonth() + 1).toString().padStart(2, "0")
      const year = date.getFullYear().toString()
      const hours = date.getHours().toString().padStart(2, "0")
      const minutes = date.getMinutes().toString().padStart(2, "0")

      return `${day}.${month}.${year} ${hours}:${minutes}`
    }

    if (event === "millis/dd.mm.yyyy") {
      const date = new Date(input)
      const day = date.getDate().toString().padStart(2, '0')
      const month = (date.getMonth() + 1).toString().padStart(2, '0')
      const year = date.getFullYear().toString()
      return `${day}.${month}.${year}`
    }

    if (event === "millis/yyyy") {
      const date = new Date(input)
      return date.getFullYear()
    }

    if (event === "millis/yyyy-mm-dd") {
      const date = new Date(input)
      const day = date.getDate().toString().padStart(2, '0')
      const month = (date.getMonth() + 1).toString().padStart(2, '0')
      const year = date.getFullYear().toString()
      return `${year}-${month}-${day}`
    }

    if (event === "element/center") {
      this.convert("element/reset", input)
      input.style.position = "absolute"
      input.style.top = "0"
      input.style.left = "0"
      input.style.height = "89vh"
      input.style.width = "100%"
      input.style.display = "flex"
      input.style.justifyContent = "center"
      input.style.alignItems = "center"

      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        input.style.color = this.colors.dark.text
      } else {
        input.style.color = this.colors.light.text
      }

      return input
    }

    if (event === "selector/class") {

      const classMatches = input.match(/\.([a-zA-Z0-9-_]+)/g)
      const className = classMatches ? classMatches.map(cls => cls.slice(1)).join(' ') : undefined
      return className
    }

    if (event === "selector/id") {

      const idMatch = input.match(/#([a-zA-Z0-9-_]+)/)
      return idMatch ? idMatch[1] : undefined
    }

    if (event === "selector/tag") {

      const tagMatch = input.match(/^[a-zA-Z0-9]+/)
      return tagMatch ? tagMatch[0] : undefined
    }

    if (event === "element/zero-z-index-child") {
      return new Promise(async(resolve, reject) => {
        try {

          const nodes = Array.from(input.querySelectorAll("*"))
          // const minZIndex = Math.min(...nodes.map(item => parseInt(item.style.zIndex) || 0))

          for (var i = 0; i < nodes.length; i++) {
            const item = nodes[i]

            const itemZIndex = parseInt(item.style.zIndex)

            if (itemZIndex === 0) {
              resolve(item)
            }

          }

        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "element/min-z-index-child") {
      return new Promise(async(resolve, reject) => {
        try {

          const nodes = Array.from(input.querySelectorAll("*"))
          const minZIndex = Math.min(...nodes.map(item => parseInt(item.style.zIndex) || 0))

          for (var i = 0; i < nodes.length; i++) {
            const item = nodes[i]

            const itemZIndex = parseInt(item.style.zIndex) || 0

            if (itemZIndex === minZIndex) {
              resolve(item)
            }

          }



        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "element/max-z-index-child") {
      return new Promise(async(resolve, reject) => {
        try {

          const nodes = Array.from(input.querySelectorAll("*"))
          const maxZIndex = Math.max(...nodes.map(item => parseInt(item.style.zIndex) || 0))

          for (var i = 0; i < nodes.length; i++) {
            const item = nodes[i]

            const itemZIndex = parseInt(item.style.zIndex) || 0

            if (itemZIndex === maxZIndex) {
              resolve(item)
            }

          }



        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "element/selector") {
      return new Promise(async(resolve, reject) => {
        try {

          if (!(input instanceof Element)) throw new Error("not an input")

          const tagName = input.tagName.toLowerCase()

          const id = input.id ? `#${input.id}` : ''

          const classes = input.className
            ? `.${input.className.split(' ').join('.')}`
            : ''

          const selector = `${tagName}${id}${classes}`

          resolve(selector)

        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "element/alias") {

      const output = document.createElement("div")
      output.style.fontFamily = "monospace"
      output.style.fontSize = "13px"
      output.style.overflow = "auto"
      output.style.display = "inline"
      output.textContent = `<${input.tagName.toLowerCase()}`

      if (input.id !== "") {
        const id = document.createElement("span")
        id.style.fontSize = "21px"
        id.textContent = `#${input.id}`
        output.append(id)
      }

      if (input.id === "") {
        if (input.getAttribute("data-id") !== null) {
          const id = document.createElement("span")
          id.style.fontSize = "21px"
          id.textContent = `#${input.getAttribute("data-id")}`
          output.append(id)
        }
      }

      if (input.classList.length > 0) {

        for (let i = 0; i < input.classList.length; i++) {
          const className = input.classList[i]
          const span = document.createElement("span")
          span.style.fontSize = "21px"
          span.textContent = `.${className}`
          output.append(span)
        }

      }

      return output
    }

    if (event === "element/reset") {
      if (input) {
        input.removeAttribute("style")
        input.innerHTML = ""
      }
    }

    if (event === "element/textarea") {

      const create = document.createElement("textarea")

      if (input.hasAttribute("id")) {
        create.setAttribute("id", input.getAttribute("id"))
      }

      if (input.hasAttribute("class")) {
        create.setAttribute("class", input.getAttribute("class"))
      }

      if (input.hasAttribute("style")) {
        create.setAttribute("style", input.getAttribute("style"))
      }

      if (input.hasAttribute("required")) {
        create.setAttribute("required", input.getAttribute("required"))
      }

      if (input.hasAttribute("on-info-click")) {
        create.setAttribute("on-info-click", input.getAttribute("on-info-click"))
      }

      input.before(create)
      input.remove()
    }

    if (event === "element/select") {

      const create = document.createElement("select")

      if (input.hasAttribute("id")) {
        create.setAttribute("id", input.getAttribute("id"))
      }

      if (input.hasAttribute("class")) {
        create.setAttribute("class", input.getAttribute("class"))
      }

      if (input.hasAttribute("style")) {
        create.setAttribute("style", input.getAttribute("style"))
      }

      if (input.hasAttribute("on-info-click")) {
        create.setAttribute("on-info-click", input.getAttribute("on-info-click"))
      }

      input.before(create)
      input.remove()
    }

    if (event === "svg/dark-light") {

      for (let i = 0; i < input.querySelectorAll("*").length; i++) {
        const node = input.querySelectorAll("*")[i]
        if (node.hasAttribute("fill")) {
          if (node.getAttribute("fill").includes("#000")) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
              node.setAttribute("fill", this.colors.dark.text)
            } else {
              node.setAttribute("fill", this.colors.light.text)
            }
          }
        }
        if (node.hasAttribute("stroke")) {
          if (node.getAttribute("stroke").includes("#000")) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
              node.setAttribute("stroke", this.colors.dark.text)
            } else {
              node.setAttribute("stroke", this.colors.light.text)
            }
          }
        }
      }
      if (input.hasAttribute("fill")) {
        if (input.getAttribute("fill").includes("#000")) {
          if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            input.setAttribute("fill", this.colors.dark.text)
          } else {
            input.setAttribute("fill", this.colors.light.text)
          }
        }
      }
      if (input.hasAttribute("stroke")) {
        if (input.getAttribute("stroke").includes("#000")) {
          if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            input.setAttribute("stroke", this.colors.dark.text)
          } else {
            input.setAttribute("stroke", this.colors.light.text)
          }
        }
      }
      return input
    }

    if (event === "link-colors") {
      input.style.color = this.colors.link.color
      input.addEventListener("click", () => input.style.color = this.colors.link.active)
    }

    if (event === "node/dark-light-toggle") {

      function getLuminance(rgb) {
        const [r, g, b] = rgb.map(value => {
          const channel = value / 255;
          return channel <= 0.03928 ? channel / 12.92 : Math.pow((channel + 0.055) / 1.055, 2.4);
        })
        return 0.2126 * r + 0.7152 * g + 0.0722 * b;
      }

      function hexToRgb(hex) {
        let r = 0, g = 0, b = 0;
        if (hex.length === 7) {
          r = parseInt(hex.slice(1, 3), 16);
          g = parseInt(hex.slice(3, 5), 16);
          b = parseInt(hex.slice(5, 7), 16);
        }
        return [r, g, b];
      }

      function colorToRgbArray(color) {
        if (color.startsWith("rgb")) {
          return color.match(/\d+/g).map(Number);
        } else if (color.startsWith("#")) {
          return hexToRgb(color);
        }
        return [0, 0, 0]
      }

      const style = getComputedStyle(input)
      const textColor = colorToRgbArray(style.color);
      const backgroundColor = colorToRgbArray(style.backgroundColor);
      const textLuminance = getLuminance(textColor);
      const backgroundLuminance = getLuminance(backgroundColor);

      if (textLuminance > backgroundLuminance) {
        this.add("style/light", input)
      } else {
        this.add("style/dark", input)
      }

    }

    if (event === "node/index") {
      return Array.from(input.parentElement.children).indexOf(input)
    }

    if (event === "node/marked") {

      const fragment = document.createDocumentFragment()
      if (input.node) {
        input.node.textContent.split(new RegExp(`(${input.query})`, 'gi')).forEach(part => {
          const span = document.createElement('span')
          if (part.toLowerCase() === input.query.toLowerCase()) {
            span.style.background = this.colors.matte.orange
          }
          span.appendChild(document.createTextNode(part))
          fragment.appendChild(span)
        })
        input.node.textContent = ""
        input.node.appendChild(fragment)
      }
      return fragment
    }

    if (event === "node/max-z-index") {

      let maxZIndex = 0
      for (let i = 0; i < input.children.length; i++) {
        const child = input.children[i]
        const zIndex = getComputedStyle(child).zIndex
        if (zIndex !== 'auto') {
          const zIndexValue = parseInt(zIndex)
          if (!isNaN(zIndexValue)) {
            maxZIndex = Math.max(maxZIndex, zIndexValue)
          }
        }
      }
      return maxZIndex

    }

    if (event === "node/min-z-index") {

      let minZIndex = 0
      for (let i = 0; i < input.children.length; i++) {
        const child = input.children[i]
        const zIndex = getComputedStyle(child).zIndex
        if (zIndex !== 'auto') {
          const zIndexValue = parseInt(zIndex)
          if (!isNaN(zIndexValue)) {
            minZIndex = Math.min(minZIndex, zIndexValue)
          }
        }
      }
      return minZIndex

    }

    if (event === "node/selected") {
      input = document.querySelector("[selected-node='true']")
    }

    if (event === "node/selector") {

      if (!(input instanceof Element)) throw new Error("not an element")
      const tagName = input.tagName.toLowerCase()
      const id = input.getAttribute("id") ? `#${input.id}` : ''
      const classes = input.getAttribute("class")
      ? `.${input.getAttribute("class").split(' ').join('.')}`
      : ''
      return `${tagName}${id}${classes}`
    }

    if (event === "node/sort-children-by-z-index") {
      Array.from(input.children)
      .sort((a, b) => {
        const zIndexA = parseInt(a.style.zIndex) || 0
        const zIndexB = parseInt(b.style.zIndex) || 0
        return zIndexB - zIndexA
      })
      .forEach(child => input.appendChild(child))
    }

    if (event === "node/text-color") {

      return input.style.color
    }

    if (event === "number/k-M") {
      if (input < 1000) return input.toString()
      if (input >= 1000000) return (input / 1000000).toFixed(1) + 'M'
      return (input / 1000).toFixed(1) + 'T'
    }

    if (event === "type/extension") {

      const mimeMapping = {
        "audio/mpeg": "mp3",
        "audio/ogg": "ogg",
        "audio/wav": "wav",
        "video/mp4": "mp4",
        "video/ogg": "ogv",
        "image/jpeg": "jpg",
        "image/png": "png",
        "image/gif": "gif",
        "image/svg+xml": "svg",
        "text/html": "html",
        "text/plain": "txt",
        "application/pdf": "pdf",
        "application/zip": "zip",
      }

      return mimeMapping[input]
    }

    if (event === "video/canvas") {

      const canvas = document.createElement("canvas")
      canvas.width = input.videoWidth
      canvas.height = input.videoHeight
      canvas.getContext('2d').drawImage(input, 0, 0, canvas.width, canvas.height)
      return canvas
    }

  }

  static async digest(blob) {

    const arrayBuffer = await blob.arrayBuffer()
    const hashBuffer = await crypto.subtle.digest('SHA-256', arrayBuffer)
    const hashArray = Array.from(new Uint8Array(hashBuffer))
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('')
    return hashHex
  }

  static async downloadFile(content, contentType) {

    const a = document.createElement("a")
    const file = new Blob([content], { type: contentType })
    const hash = await this.digest(file)
    a.href = URL.createObjectURL(file)
    a.download = `${hash}.${this.convert("type/extension", contentType)}`
    a.click()
  }

  static async dynamicImport(url, callback) {
    const scriptLoaded = new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.onload = resolve
      script.onerror = reject
      document.head.appendChild(script)
    })
    try {
      await scriptLoaded
      if (typeof callback === "function") await callback()
      const scriptToRemove = document.querySelector(`script[src="${url}"]`)
      if (scriptToRemove) document.head.removeChild(scriptToRemove)
    } catch (error) {
      window.alert(`Fehler beim Laden oder Ausführen des Skripts:\n\n${error}`)
    }
  }

  static fn(event, input) {

    if (event === "addLargeStyle") {

      return (node) => {
        const query = "(min-width: 1025px)"
        const prompt = window.prompt("Gebe die CSS Eigenschaft, nur für Bildschirme größer als 1025px, ein: (z.B., color: red;)")
        if (!this.verifyIs("text/empty", prompt)) {
          let largeStyle = document.querySelector("style[id='large-device']")
          if (largeStyle === null) {
            const style = document.createElement("style")
            style.type = "text/css"
            style.id = "large-device"
            document.head.appendChild(style)
          }
          largeStyle = document.querySelector("style[id='large-device']")
          const selector = this.convert("node/selector", node)
          largeStyle.append(`\n@media only screen and ${query} {${selector}{${prompt} !important;}}`)
        }
      }
    }

    if (event === "addLocationAssign") {

      return (node) => {
        const prompt = window.prompt("Gebe die Quell-Url deiner Weiterleitung ein:")
        if (!this.verifyIs("text/empty", prompt)) {
          node.style.cursor = "pointer"
          node.setAttribute("onmouseover", "this.style.outline='3px solid #888'")
          node.setAttribute("onmouseout", "this.style.outline=null")
          node.setAttribute("onclick", `window.location.assign("${prompt}")`)
        }
      }
    }

    if (event === "addGridColumn") {

      return (node) => {
        node.style.gridTemplateColumns = `${node.style.gridTemplateColumns} 1fr`
        if (node.lastElementChild) {
          node.appendChild(node.lastElementChild.cloneNode(true))
        }
      }
    }

    if (event === "addGridRow") {

      return (node) => {
        node.style.gridTemplateRows = `${node.style.gridTemplateRows} 1fr`
        if (node.lastElementChild) {
          node.appendChild(node.lastElementChild.cloneNode(true))
        }
      }
    }

    if (event === "addLayerAbove") {

      return (node) => {
        node.style.position = "relative"
        const layer = document.createElement("div")
        layer.classList.add("layer")
        layer.style.position = "absolute"
        layer.style.top = "0"
        layer.style.left = "0"
        layer.style.borderRadius = node.style.borderRadius
        layer.style.backgroundColor = node.style.backgroundColor
        layer.style.width = `${node.offsetWidth}px`
        layer.style.height = `${node.offsetHeight}px`
        let maxZIndex = this.convert("node/max-z-index", node)
        maxZIndex++
        layer.style.zIndex = maxZIndex
        node.appendChild(layer)
        this.convert("node/sort-children-by-z-index", node)
        window.alert("Layer erfolgreich angehängt.")
      }
    }

    if (event === "addLayerBelow") {

      return (node) => {
        node.style.position = "relative"
        const layer = document.createElement("div")
        layer.classList.add("layer")
        layer.style.position = "absolute"
        layer.style.top = "0"
        layer.style.left = "0"
        layer.style.borderRadius = node.style.borderRadius
        layer.style.backgroundColor = node.style.backgroundColor
        layer.style.width = `${node.offsetWidth}px`
        layer.style.height = `${node.offsetHeight}px`
        let minZIndex = this.convert("node/min-z-index", node)
        minZIndex--
        layer.style.zIndex = minZIndex
        node.appendChild(layer)
        this.convert("node/sort-children-by-z-index", node)
        window.alert("Layer erfolgreich angehängt.")
      }
    }

    if (event === "addLayerPrompt") {

      return (node) => {
        const prompt = window.prompt("Gebe die exakte Ebene für deinen Layer ein: (z.B., 3, -1)")
        if (this.verifyIs("text/int", prompt)) {
          node.style.position = "relative"
          const layer = document.createElement("div")
          layer.classList.add("layer")
          layer.removeAttribute("id")
          layer.style.position = "absolute"
          layer.style.top = "0"
          layer.style.left = "0"
          layer.style.borderRadius = node.style.borderRadius
          layer.style.backgroundColor = node.style.backgroundColor
          layer.style.width = `${node.offsetWidth}px`
          layer.style.height = `${node.offsetHeight}px`
          layer.style.zIndex = prompt
          node.appendChild(layer)
          this.convert("node/sort-children-by-z-index", node)
          window.alert("Layer erfolgreich angehängt.")
        }
      }
    }

    if (event === "addOpacityWithPrompt") {

      return (node) => {
        const prompt = window.prompt("Gebe die Sichtbarkeit in Prozent ein: (z.B., 50)")
        const opacity = parseInt(prompt)
        if (opacity >= 0 && opacity <= 100) {
          node.style.opacity = `${prompt / 100}`
        }
      }
    }

    if (event === "addMiddleStyle") {

      return (node) => {
        const query = "(min-width: 601px) and (max-width: 1024px)"
        const prompt = window.prompt("Gebe die CSS Eigenschaft, nur für Bildschirme zwischen 601px und 1024px, ein: (z.B., color: red;)")
        if (!this.verifyIs("text/empty", prompt)) {
          let middleStyle = document.querySelector("style[id='middle-device']")
          if (middleStyle === null) {
            const style = document.createElement("style")
            style.type = "text/css"
            style.id = "middle-device"
            document.head.appendChild(style)
          }
          middleStyle = document.querySelector("style[id='middle-device']")
          const selector = this.convert("node/selector", node)
          middleStyle.append(`\n@media only screen and ${query} {${selector}{${prompt} !important;}}`)
        }
      }
    }

    if (event === "addOuterHtmlToClipboard") {

      return (node) => {
        this.convert("text/clipboard", node.outerHTML).then(() => {
          window.alert("Element wurde erfolgreich in deine Zwischenablage gespeichert.")
        })
      }
    }

    if (event === "addStyleToClipboard") {

      return (node) => {
        if (node.hasAttribute("style")) {
          this.convert("text/clipboard", node.getAttribute("style")).then(() => {
            window.alert("Style wurde erfolgreich in deine Zwischenablage gespeichert.")
          })
        }
      }
    }

    if (event === "addClipboardToStyle") {

      return (node) => {
        this.convert("clipboard/text").then(text => {
          node.setAttribute("style", text)
        })
      }
    }

    if (event === "addPrinterStyle") {

      return (node) => {
        const query = "(max-width: 600px)"
        const prompt = window.prompt("Gebe die CSS Eigenschaft, nur für Drucker, ein: (z.B., color: red;)")
        if (!this.verifyIs("text/empty", prompt)) {
          let printerStyle = document.querySelector("style[id='printer-device']")
          if (printerStyle === null) {
            const style = document.createElement("style")
            style.type = "text/css"
            style.id = "printer-device"
            document.head.appendChild(style)
          }
          printerStyle = document.querySelector("style[id='printer-device']")
          const selector = this.convert("node/selector", node)
          printerStyle.append(`\n@media print {${selector}{${prompt} !important;}}`)
        }
      }
    }

    if (event === "addSmallStyle") {

      return (node) => {
        const query = "(max-width: 600px)"
        const prompt = window.prompt("Gebe die CSS Eigenschaft, nur für Bildschirme kleiner als 600px, ein: (z.B., color: red;)")
        if (!this.verifyIs("text/empty", prompt)) {
          let smallStyle = document.querySelector("style[id='small-device']")
          if (smallStyle === null) {
            const style = document.createElement("style")
            style.type = "text/css"
            style.id = "small-device"
            document.head.appendChild(style)
          }
          smallStyle = document.querySelector("style[id='small-device']")
          const selector = this.convert("node/selector", node)
          smallStyle.append(`\n@media only screen and ${query} {${selector}{${prompt} !important;}}`)
        }
      }
    }

    if (event === "addWindowOpenBlank") {

      return (node) => {
        const prompt = window.prompt("Gebe die Quell-Url deines neuen Tabs ein:")
        if (!this.verifyIs("text/empty", prompt)) {
          node.style.cursor = "pointer"
          node.setAttribute("onmouseover", "this.style.outline='3px solid #888'")
          node.setAttribute("onmouseout", "this.style.outline=null")
          node.setAttribute("onclick", `window.open("${prompt}", "_blank")`)
        }
      }
    }

    if (event === "appendAllSvgIcons") {

      async function appendSvgIconsFragment(node, callback, start = 0, end = 8) {
        const fragment = document.createDocumentFragment()
        const res = await Helper.request("/get/svg/list-open/")
        if (res.status === 200) {
          const list = JSON.parse(res.response)
          for (let i = start; i < Math.min(start + end, list.length); i++) {
            const svgName = list[i]
            const button = Helper.create("toolbox/icon")
            const icon = await Helper.convert("path/icon", `/public/${svgName}`)
            button.dataset.src = `/public/${svgName}`
            button.appendChild(icon)
            fragment.appendChild(button)
          }
          node.appendChild(fragment.cloneNode(true))
          const observer = new IntersectionObserver(async (entries) => {
            entries.forEach(async (entry) => {
              const isLast = (start + end - 1) > list.length
              if (isLast) {
                observer.disconnect()
                return
              }
              if (entry.isIntersecting) {
                await appendSvgIconsFragment(node, callback, end, end + end)
                onButtonClick(node, callback)
                observer.unobserve(entry.target)
              }
            })
          })
          const lastIcon = node.lastElementChild
          if (lastIcon) {
            observer.observe(lastIcon)
          }
          onButtonClick(node, callback)
          return fragment
        }
      }

      function onButtonClick(node, callback) {
        for (let i = 0; i < node.children.length; i++) {
          const button = node.children[i]
          Helper.add("outline-hover", button)
          button.onclick = () => callback(button)
        }
      }

      return {appendSvgIconsFragment}
    }

    if (event === "appendClipboardToNode") {

      return (node) => {
        this.convert("clipboard/text").then(text => {
          const html = this.convert("text/first-child", text)
          node.appendChild(html)
        })
      }
    }

    if (event === "appendDiv") {

      return (node) => {
        const div = document.createElement("div")
        div.style.margin = "21px 34px"
        div.textContent = "DIV"
        const fragment = document.createDocumentFragment()
        fragment.appendChild(div)
        node.appendChild(fragment)
      }
    }

    if (event === "appendImage") {

      return (node) => {
        const url = window.prompt("Gebe die Quelle des Bildes ein: (text/url)")
        if (this.verifyIs("text/url", url)) {
          const fragment = document.createDocumentFragment()
          const div = document.createElement("div")
          fragment.appendChild(div)
          div.className = "image"
          const img = document.createElement("img")
          div.appendChild(img)
          img.src = url
          img.style.width = "100%"
          fragment.appendChild(div)
          node.appendChild(fragment)
        } else {
          window.alert("Keine gültige URL.")
        }
      }
    }

    if (event === "appendOrderedListItem") {

      let inner
      return (node) => {

        const ul = document.createElement("ol")
        const li = document.createElement("li")
        ul.appendChild(li)

        if (node.firstChild.tagName === "OL") {
          li.textContent = inner
          node.firstChild.appendChild(li)
        } else {
          inner = node.textContent
          li.textContent = inner
          node.textContent = ""
          node.appendChild(ul)
        }

      }

    }

    if (event === "appendStyleWithPrompt") {

      return (node) => {
        const prompt = window.prompt("Füge deinem Element einen individuellen CSS Befehl hinzu: (z.B., color: red;)")
        if (!this.verifyIs("text/empty", prompt)) {
          if (node.hasAttribute("style")) {
            const result = node.getAttribute("style") + prompt
            node.setAttribute("style", result)
          } else {
            node.setAttribute("style", prompt)
          }
        }
      }
    }

    if (event === "appendUnorderedListItem") {

      let inner
      return (node) => {
        const ul = document.createElement("ul")
        const li = document.createElement("li")
        ul.appendChild(li)
        if (node.firstChild.tagName === "UL") {
          li.textContent = inner
          node.firstChild.appendChild(li)
        } else {
          inner = node.textContent
          li.textContent = inner
          node.textContent = ""
          node.appendChild(ul)
        }
      }
    }

    if (event === "openUrl") {

      return (node) => {
        const url = window.prompt("Gebe die URL ein:")
        if (this.verifyIs("text/url", url)) {
          node.setAttribute("onclick", `window.open('${url}', '_blank')`)
        } else {
          window.alert("Keine gültige URL.")
        }
      }
    }

    if (event === "creator-buttons") {

      const {type} = input
      const it = {}
      function toggleDisplayFlexNone(node) {
        if (node.style.display === "none") {
          node.style.display = "flex"
          return
        }
        if (node.style.display === "flex") {
          node.style.display = "none"
          return
        }
      }
      it.toggleStyle = this.fn("toggleStyle")
      it.toggleStyles = this.fn("toggleStyles")
      it.toggleNodeAndChildrenStyles = this.fn("toggleNodeAndChildrenStyles")
      it.setStyleWithPrompt = this.fn("setStyleWithPrompt")
      it.incrementStyle = this.fn("incrementStyle")
      it.decrementStyle = this.fn("decrementStyle")
      it.fixedGridPrompt = this.fn("fixedGridPrompt")
      it.rotateNode = this.fn("rotateNode")
      it.appendUnorderedListItem = this.fn("appendUnorderedListItem")
      it.appendOrderedListItem = this.fn("appendOrderedListItem")
      it.toggleAttribute = this.fn("toggleAttribute")
      it.toggleInnerHtml = this.fn("toggleInnerHtml")
      it.toggleTextContent = this.fn("toggleTextContent")
      it.toggleNode = this.fn("toggleNode")
      it.setChildrenStyleWithPrompt = this.fn("setChildrenStyleWithPrompt")

      it.optionsContainer = this.create("div/scrollable", input.parent)
      it.optionsContainer.style.marginTop = "21px"
      it.optionsContainer.style.height = `${window.innerHeight * 0.4}px`

      it.quickContentTitle = this.render("text/hr", "Anwendungen für schnellen Inhalt", it.optionsContainer)
      this.add("outline-hover", it.quickContentTitle)
      it.quickContentOptions = this.create("div/flex-row", it.optionsContainer)
      it.quickContentTitle.onclick = () => toggleDisplayFlexNone(it.quickContentOptions)
      it.quickContentOptions.style.display = "none"

      it.openFunnelOverlayButton = this.render("text/link", "Meine Funnel", it.quickContentOptions)
      it.openFunnelOverlay = this.fn("openFunnelOverlay")

      it.sourcesButton = this.render("text/link", "Meine Quellen", it.quickContentOptions)
      it.openSourcesOverlay = this.fn("openSourcesOverlay")
      if (type === "expert") {
        it.openScriptsOverlayButton = this.render("text/link", "Meine Skripte", it.quickContentOptions)
        it.openScriptsOverlay = this.fn("openScriptsOverlay")
      }
      it.templatesButton = this.render("text/link", "Meine Templates", it.quickContentOptions)
      it.openTemplatesOverlay = this.fn("openTemplatesOverlay")
      it.openPdfOverlayButton = this.render("text/link", "Meine PDFs", it.quickContentOptions)
      it.openPdfOverlay = this.fn("openPdfOverlay")
      it.openImagesOverlayButton = this.render("text/link", "Meine Bilder", it.quickContentOptions)
      it.openImagesOverlay = this.fn("openImagesOverlay")
      it.openAudiosOverlayButton = this.render("text/link", "Meine Audios", it.quickContentOptions)
      it.openAudiosOverlay = this.fn("openAudiosOverlay")
      it.openVideosOverlayButton = this.render("text/link", "Meine Videos", it.quickContentOptions)
      it.openVideosOverlay = this.fn("openVideosOverlay")

      it.templatesTitle = this.render("text/hr", "Anwendungen für einfache Vorlagen", it.optionsContainer)
      this.add("outline-hover", it.templatesTitle)
      it.templatesTitle.onclick = () => toggleDisplayFlexNone(it.templateOptions)
      it.templateOptions = this.create("div/flex-row", it.optionsContainer)
      it.templateOptions.style.display = "none"

      it.myValueUnitsButton = this.render("text/link", "Meine Werteinheiten", it.templateOptions)
      it.createMyValueUnitsBox = this.fn("createMyValueUnitsBox")

      it.profileSurveysButton = this.render("text/link", "Profile Umfragen", it.templateOptions)
      it.createProfileSurveysBox = this.fn("createProfileSurveysBox")

      it.imageTextAndActionButton = this.render("text/link", "Bild-Text-Action Box", it.templateOptions)
      it.createImageTextAndActionBox = this.fn("createImageTextAndActionBox")
      it.backgroundImageWithTitlesButton = this.render("text/link", "Hintergrund Bild mit Titel", it.templateOptions)
      it.createBackgroundImageWithTitles = this.fn("createBackgroundImageWithTitles")
      it.createFlexButton = this.render("text/link", "Flex Elemente erstellen", it.templateOptions)
      it.createFlexWidthWithPrompt = this.fn("createFlexWidthWithPrompt")
      it.createGridButton = this.render("text/link", "Grid Matrix erstellen", it.templateOptions)
      it.createGridMatrixWithPrompt = this.fn("createGridMatrixWithPrompt")
      it.appendDivButton = this.render("text/link", "Div anhängen", it.templateOptions)
      it.appendDiv = this.fn("appendDiv")
      it.rowContainerButton = this.render("text/link", "Div als Flex Zeile", it.templateOptions)
      it.createFlexRow = this.fn("createFlexRow")
      it.columnContainerButton = this.render("text/link", "Div als Flex Spalte", it.templateOptions)
      it.createFlexColumn = this.fn("createFlexColumn")
      it.appendImageButton = this.render("text/link", "Bild anhängen", it.templateOptions)
      it.appendImage = this.fn("appendImage")

      it.imageTextButton = this.render("text/link", "Bild mit Unterschrift", it.templateOptions)
      it.createImageText = this.fn("createImageText")
      it.keyValueButton = this.render("text/link", "Schlüsselpaar erstellen", it.templateOptions)
      it.createKeyValue = this.fn("createKeyValue")
      it.actionBtnButton = this.render("text/link", "Action Button erstellen", it.templateOptions)
      it.createActionButton = this.fn("createActionButton")


      it.styleBackgroundImageButton = this.render("text/link", "Hintergrundbild anhängen", it.templateOptions)
      it.styleBackgroundImage = this.fn("styleBackgroundImage")

      it.horizontalHrButton = this.render("text/link", "Horizontale Trennlinie", it.templateOptions)
      it.createHr = this.fn("createHr")



      it.simpleHeaderButton = this.render("text/link", "Kopfzeile mit Bild Links", it.templateOptions)
      it.createLeftImageHeader = this.fn("createLeftImageHeader")
      it.h1Button = this.render("text/link", "Überschrift 1", it.templateOptions)
      it.createH1withPrompt = this.fn("createH1withPrompt")
      it.h2Button = this.render("text/link", "Überschrift 2", it.templateOptions)
      it.createH2withPrompt = this.fn("createH2withPrompt")
      it.h3Button = this.render("text/link", "Überschrift 3", it.templateOptions)
      it.createH3withPrompt = this.fn("createH3withPrompt")
      it.pButton = this.render("text/link", "Paragraph erstellen", it.templateOptions)
      it.createPwithPrompt = this.fn("createPwithPrompt")
      it.imageButton = this.render("text/link", "Bild erstellen", it.templateOptions)
      it.createImagePlaceholder = this.fn("createImagePlaceholder")
      it.tableHeaderButton = this.render("text/link", "Tabellen Überschriften erstellen", it.templateOptions)
      it.createTableWithMatrixPrompt = this.fn("createTableWithMatrixPrompt")
      it.pdfLinkButton = this.render("text/link", "PDF Link erstellen", it.templateOptions)
      it.createPdfLinkWithPrompt = this.fn("createPdfLinkWithPrompt")
      it.aLinkButton = this.render("text/link", "Link erstellen", it.templateOptions)
      it.createAnchorWithPrompt = this.fn("createAnchorWithPrompt")
      it.wrapLinkButton = this.render("text/link", "Als Link einpacken", it.templateOptions)
      it.wrapAnchorWithPrompt = this.fn("wrapAnchorWithPrompt")
      it.locationAssignButton = this.render("text/link", "Weiterleitung einfügen", it.templateOptions)
      it.addLocationAssign = this.fn("addLocationAssign")
      it.windowOpenBlankButton = this.render("text/link", "Weiterleitung mit neuem Tab", it.templateOptions)
      it.addWindowOpenBlank = this.fn("addWindowOpenBlank")
      it.spanButton = this.render("text/link", "Text Inhalt als Span", it.templateOptions)
      it.createSpanWithTextContent = this.fn("createSpanWithTextContent")
      it.changeSiButton = this.render("text/link", "SI Einheit als Span", it.templateOptions)
      it.createSpanWithSiPrompt = this.fn("createSpanWithSiPrompt")
      it.addSpaceButton = this.render("text/link", "Abstand erstellen", it.templateOptions)
      it.createSpaceWithHeightPrompt = this.fn("createSpaceWithHeightPrompt")
      it.arrowRightButton = this.render("text/link", "Pfeil nach Rechts mit Farbe", it.templateOptions)
      it.createArrowRightWithColorPrompt = this.fn("createArrowRightWithColorPrompt")
      it.divScrollableButton = this.render("text/link", "Div Scrollbar in Y Richtung", it.templateOptions)
      it.createScrollableY = this.fn("createScrollableY")
      it.packDivButton = this.render("text/link", "Inhalt als Div einpacken", it.templateOptions)
      it.createDivPackOuter = this.fn("createDivPackOuter")

      it.eventTitle = this.render("text/hr", "Anwendungen für Events", it.optionsContainer)
      this.add("outline-hover", it.eventTitle)
      it.eventTitle.onclick = () => toggleDisplayFlexNone(it.eventOptions)
      it.eventOptions = this.create("div/flex-row", it.optionsContainer)
      it.eventOptions.style.display = "none"

      it.pointerButton = this.render("text/link", "Pointer-Event hinzufügen", it.eventOptions)
      it.pointer = this.fn("pointer")
      it.openUrlButton = this.render("text/link", "URL-Klick-Weiterleitung hinzufügen", it.eventOptions)
      it.openUrl = this.fn("openUrl")


      it.converterTitle = this.render("text/hr", "Anwendungen für Konverter", it.optionsContainer)
      this.add("outline-hover", it.converterTitle)
      it.converterTitle.onclick = () => toggleDisplayFlexNone(it.converterOptions)
      it.converterOptions = this.create("div/flex-row", it.optionsContainer)
      it.converterOptions.style.display = "none"

      it.textConverterButton = this.render("text/link", "Text konvertieren", it.converterOptions)
      it.textConverterButton.onclick = () => this.fn("overlay-text-converter")
      it.duckDuckGoButton = this.render("text/link", "DuckDuckGo Link erstellen", it.converterOptions)
      it.convertTextContentToDuckDuckGoLink = this.fn("convertTextContentToDuckDuckGoLink")
      it.convertTextContentToH1Button = this.render("text/link", "Textinhalt als Überschrift 1", it.converterOptions)
      it.convertTextContentToH1 = this.fn("convertTextContentToH1")
      it.convertTextContentToH2Button = this.render("text/link", "Textinhalt als Überschrift 2", it.converterOptions)
      it.convertTextContentToH2 = this.fn("convertTextContentToH2")
      it.convertTextContentToH3Button = this.render("text/link", "Textinhalt als Überschrift 3", it.converterOptions)
      it.convertTextContentToH3 = this.fn("convertTextContentToH3")
      it.convertToInlineCiteButton = this.render("text/link", "Als Inline-Zitat markieren", it.converterOptions)
      it.convertToInlineCite = this.fn("convertToInlineCite")
      it.convertToFullCiteButton = this.render("text/link", "Als Voll-Zitat markieren", it.converterOptions)
      it.convertToFullCite = this.fn("convertToFullCite")
      it.trimLinesButton = this.render("text/link", "Zeile trimmen", it.converterOptions)
      it.trimLines = this.fn("trimLines")
      it.removeCiteMarksButton = this.render("text/link", "Zitatmarkierung entfernen", it.converterOptions)
      it.removeCiteMarks = this.fn("removeCiteMarks")


      it.inputTitle = this.render("text/hr", "Anwendungen für Eingabe Felder einsetzen", it.optionsContainer)
      this.add("outline-hover", it.inputTitle)
      it.inputTitle.onclick = () => toggleDisplayFlexNone(it.inputOptions)
      it.inputOptions = this.create("div/flex-row", it.optionsContainer)
      it.inputOptions.style.display = "none"

      it.textInputButton = this.render("text/link", "Texteingabe erstellen", it.inputOptions)
      it.createTextInput = this.fn("createTextInput")
      it.numberInputButton = this.render("text/link", "Nummereingabe erstellen", it.inputOptions)
      it.createTelInput = this.fn("createTelInput")
      it.checkboxInputButton = this.render("text/link", "Checkbox erstellen", it.inputOptions)
      it.createCheckboxInput = this.fn("createCheckboxInput")
      it.passwordInputButton = this.render("text/link", "Passworteingabe erstellen", it.inputOptions)
      it.createPasswordInput = this.fn("createPasswordInput")
      it.selectInputButton = this.render("text/link", "Auswahleingabe erstellen", it.inputOptions)
      it.createSelectInput = this.fn("createSelectInput")
      it.createDateInputButton = this.render("text/link", "Datumeingabe erstellen", it.inputOptions)
      it.createDateInput = this.fn("createDateInput")

      it.widthTitle = this.render("text/hr", "Anwendungen für die Breite", it.optionsContainer)
      this.add("outline-hover", it.widthTitle)
      it.widthTitle.onclick = () => toggleDisplayFlexNone(it.widthOptions)
      it.widthOptions = this.create("div/flex-row", it.optionsContainer)
      it.widthOptions.style.display = "none"

      it.growWidthButton = this.render("text/link", "100% Breite umschalten", it.widthOptions)
      it.maxWidthButton = this.render("text/link", "Maximale Breite", it.widthOptions)
      it.minWidthButton = this.render("text/link", "Minimale Breite", it.widthOptions)
      it.exactWidthButton = this.render("text/link", "Exakte Breite", it.widthOptions)
      it.increaseWidthButton = this.render("text/link", "Breite +1", it.widthOptions)
      it.decreaseWidthButton = this.render("text/link", "Breite -1", it.widthOptions)

      it.heightTitle = this.render("text/hr", "Anwendungen für die Höhe", it.optionsContainer)
      this.add("outline-hover", it.heightTitle)
      it.heightTitle.onclick = () => toggleDisplayFlexNone(it.heightOptions)
      it.heightOptions = this.create("div/flex-row", it.optionsContainer)
      it.heightOptions.style.display = "none"

      it.growHeightButton = this.render("text/link", "100% Höhe umschalten", it.heightOptions)
      it.maxHeightButton = this.render("text/link", "Maximale Höhe", it.heightOptions)
      it.minHeightButton = this.render("text/link", "Minimale Höhe", it.heightOptions)
      it.exactHeightButton = this.render("text/link", "Exakte Höhe", it.heightOptions)
      it.increaseHeightButton = this.render("text/link", "Höhe +1", it.heightOptions)
      it.decreaseHeightButton = this.render("text/link", "Höhe -1", it.heightOptions)

      it.displayTitle = this.render("text/hr", "Anwendungen für Display Elemente", it.optionsContainer)
      this.add("outline-hover", it.displayTitle)
      it.displayTitle.onclick = () => toggleDisplayFlexNone(it.displayOptions)
      it.displayOptions = this.create("div/flex-row", it.optionsContainer)
      it.displayOptions.style.display = "none"

      it.exactDisplayButton = this.render("text/link", "Display Prompt", it.displayOptions)
      it.displayBlockButton = this.render("text/link", "Display Block umschalten", it.displayOptions)
      it.displayInlineButton = this.render("text/link", "Display Inline umschalten", it.displayOptions)
      it.toggleDisplayGridButton = this.render("text/link", "Display Grid umschalten", it.displayOptions)
      it.toggleDisplayFlexButton = this.render("text/link", "Display Flex umschalten", it.displayOptions)
      it.toggleDisplayTableButton = this.render("text/link", "Display Table umschalten", it.displayOptions)

      it.gridTitle = this.render("text/hr", "Anwendungen für Grid Elemente", it.optionsContainer)
      this.add("outline-hover", it.gridTitle)
      it.gridTitle.onclick = () => toggleDisplayFlexNone(it.gridOptions)
      it.gridOptions = this.create("div/flex-row", it.optionsContainer)
      it.gridOptions.style.display = "none"

      it.gridMobileButton = this.render("text/link", "Grid für Mobile Geräte", it.gridOptions)
      it.gridFullDisplayButton = this.render("text/link", "Grid Volle Breite", it.gridOptions)
      it.gridTwoColumnsButton = this.render("text/link", "Grid mit 2 Spalten", it.gridOptions)
      it.gridThreeColumnsButton = this.render("text/link", "Grid mit 3 Spalten", it.gridOptions)
      it.gridFixedButton = this.render("text/link", "Grid Dimension", it.gridOptions)
      it.gridListRowsButton = this.render("text/link", "Grid Liste", it.gridOptions)
      it.gridSpanColumnButton = this.render("text/link", "Grid Element in Spalten Richtung spannen", it.gridOptions)
      it.spanColumnWithPrompt = this.fn("spanColumnWithPrompt")
      it.gridSpanRowButton = this.render("text/link", "Grid Element in Zeilen Richtung spannen", it.gridOptions)
      it.spanRowWithPrompt = this.fn("spanRowWithPrompt")
      it.exactGridGapButton = this.render("text/link", "Exakter Grid Abstand", it.gridOptions)
      it.gridAddColumnButton = this.render("text/link", "Spalte hinzufügen", it.gridOptions)
      it.addGridColumn = this.fn("addGridColumn")
      it.gridRemoveColumnButton = this.render("text/link", "Spalte entfernen", it.gridOptions)
      it.removeGridColumn = this.fn("removeGridColumn")
      it.gridAddRowButton = this.render("text/link", "Zeile hinzufügen", it.gridOptions)
      it.addGridRow = this.fn("addGridRow")
      it.gridRemoveRowButton = this.render("text/link", "Zeile entfernen", it.gridOptions)
      it.removeGridRow = this.fn("removeGridRow")

      it.flexTitle = this.render("text/hr", "Anwendungen für Flex Elemente", it.optionsContainer)
      this.add("outline-hover", it.flexTitle)
      it.flexTitle.onclick = () => toggleDisplayFlexNone(it.flexOptions)
      it.flexOptions = this.create("div/flex-row", it.optionsContainer)
      it.flexOptions.style.display = "none"

      it.alignColumnButton = this.render("text/link", "Flex Spalte", it.flexOptions)
      it.alignLeftButton = this.render("text/link", "Links anordnen ", it.flexOptions)
      it.alignCenterButton = this.render("text/link", "Zentriert anordnen", it.flexOptions)
      it.alignRightButton = this.render("text/link", "Rechts anordnen", it.flexOptions)
      it.alignRowButton = this.render("text/link", "Flex Zeile", it.flexOptions)
      it.alignTopButton = this.render("text/link", "Oben anordnen", it.flexOptions)
      it.alignVerticalButton = this.render("text/link", "Mittig anordnen", it.flexOptions)
      it.alignBottomButton = this.render("text/link", "Unten anordnen", it.flexOptions)
      it.flexButton = this.render("text/link", "Flex Element erstellen", it.flexOptions)
      it.spaceBetweenButton = this.render("text/link", "Flex Abstand Zwischen", it.flexOptions)
      it.spaceAroundButton = this.render("text/link", "Flex Abstand Herum", it.flexOptions)
      it.toggleWrapButton = this.render("text/link", "Flex Wrap umschalten", it.flexOptions)

      it.layerTitle = this.render("text/hr", "Anwendungen für die Layer Elemente", it.optionsContainer)
      this.add("outline-hover", it.layerTitle)
      it.layerTitle.onclick = () => toggleDisplayFlexNone(it.layerOptions)
      it.layerOptions = this.create("div/flex-row", it.optionsContainer)
      it.layerOptions.style.display = "none"

      it.layerButton = this.render("text/link", "Layer Verwaltung öffnen", it.layerOptions)
      it.openLayerOverlay = this.fn("openLayerOverlay")
      it.positiveLayerButton = this.render("text/link", "Layer darüber hinzufügen", it.layerOptions)
      it.addLayerAbove = this.fn("addLayerAbove")
      it.negativeLayerButton = this.render("text/link", "Layer darunter hinzufügen", it.layerOptions)
      it.addLayerBelow = this.fn("addLayerBelow")
      it.exactLayerButton = this.render("text/link", "Layer mit exaktem Index", it.layerOptions)
      it.addLayerPrompt = this.fn("addLayerPrompt")
      it.removeLayerButton = this.render("text/link", "Alle Layer entfernen", it.layerOptions)
      it.removeAllLayer = this.fn("removeAllLayer")
      it.positionAbsoluteButton = this.render("text/link", "Position Absolut umschalten", it.layerOptions)
      it.positionTopButton = this.render("text/link", "Position Oben", it.layerOptions)
      it.positionRightButton = this.render("text/link", "Position Rechts", it.layerOptions)
      it.positionBottomButton = this.render("text/link", "Position Unten", it.layerOptions)
      it.positionLeftButton = this.render("text/link", "Position Links", it.layerOptions)

      it.transformationTitle = this.render("text/hr", "Anwendungen für die Transformation", it.optionsContainer)
      this.add("outline-hover", it.transformationTitle)
      it.transformationTitle.onclick = () => toggleDisplayFlexNone(it.transformationOptions)
      it.transformationOptions = this.create("div/flex-row", it.optionsContainer)
      it.transformationOptions.style.display = "none"

      it.transformTranslateButton = this.render("text/link", "Exakt versetzen", it.transformationOptions)
      it.translateWithPrompt = this.fn("translateWithPrompt")
      it.transformTranslateXButton = this.render("text/link", "Nach X versetzen", it.transformationOptions)
      it.translateXWithPrompt = this.fn("translateXWithPrompt")
      it.transformTranslateYButton = this.render("text/link", "Nach Y versetzen", it.transformationOptions)
      it.translateYWithPrompt = this.fn("translateYWithPrompt")
      it.zIndexButton = this.render("text/link", "Z-Index anpassen", it.transformationOptions)
      it.scaleButton = this.render("text/link", "", it.transformationOptions)
      it.scaleWithPrompt = this.fn("scaleWithPrompt")
      it.rotateRightButton = this.render("text/link", "90° nach Rechts drehen", it.transformationOptions)
      it.rotateNodeRightWithPrompt = this.fn("rotateNodeRightWithPrompt")
      it.exactRotateRightButton = this.render("text/link", "Exakt nach Rechts drehen", it.transformationOptions)
      it.rotateLeftButton = this.render("text/link", "90° nach Links drehen", it.transformationOptions)
      it.rotateNodeLeftWithPrompt = this.fn("rotateNodeLeftWithPrompt")
      it.exactRotateLeftButton = this.render("text/link", "Exakt nach Links drehen", it.transformationOptions)

      it.editTextTitle = this.render("text/hr", "Anwendungen für die Textverarbeitung", it.optionsContainer)
      this.add("outline-hover", it.editTextTitle)
      it.editTextTitle.onclick = () => toggleDisplayFlexNone(it.textManipulationOptions)
      it.textManipulationOptions = this.create("div/flex-row", it.optionsContainer)
      it.textManipulationOptions.style.display = "none"

      it.whiteSpaceNoWrapButton = this.render("text/link", "Leerzeichen nicht umbrechen", it.textManipulationOptions)
      it.fontFamilyButton = this.render("text/link", "Schriftart", it.textManipulationOptions)
      it.fontWeightNormalButton = this.render("text/link", "Schriftbreite Normal umschalten", it.textManipulationOptions)
      it.fontWeightButton = this.render("text/link", "Exakte Schriftbreite", it.textManipulationOptions)
      it.fontStyleButton = this.render("text/link", "Schriftstil", it.textManipulationOptions)
      it.textDecorationButton = this.render("text/link", "Textdekoration", it.textManipulationOptions)
      it.fontSizeButton = this.render("text/link", "Schriftgröße", it.textManipulationOptions)
      it.fontColorButton = this.render("text/link", "Schriftfarbe", it.textManipulationOptions)
      it.backgroundColorButton = this.render("text/link", "Hintergrundfarbe", it.textManipulationOptions)
      it.unorderedListButton = this.render("text/link", "Ungeordnete Liste erstellen", it.textManipulationOptions)
      it.orderedListButton = this.render("text/link", "Geordnete Liste erstellen", it.textManipulationOptions)
      it.lineHeightButton = this.render("text/link", "Zeilenhöhe", it.textManipulationOptions)

      it.visibilityTitle = this.render("text/hr", "Anwendungen für die Sichtbarkeit", it.optionsContainer)
      this.add("outline-hover", it.visibilityTitle)
      it.visibilityTitle.onclick = () => toggleDisplayFlexNone(it.visibilityOptions)
      it.visibilityOptions = this.create("div/flex-row", it.optionsContainer)
      it.visibilityOptions.style.display = "none"

      it.overflowYButton = this.render("text/link", "Überlauf Y", it.visibilityOptions)
      it.overflowXButton = this.render("text/link", "Überlauf X", it.visibilityOptions)
      it.toggleDisplayNoneButton = this.render("text/link", "Display None umschalten", it.visibilityOptions)
      it.toggleVisibilityHiddenButton = this.render("text/link", "Sichtbarkeit umschalten", it.visibilityOptions)
      it.exactOpacityButton = this.render("text/link", "Deckkraft in Prozent definieren", it.visibilityOptions)
      it.addOpacityWithPrompt = this.fn("addOpacityWithPrompt")

      it.spacingTitle = this.render("text/hr", "Anwendungen für die Abstände", it.optionsContainer)
      this.add("outline-hover", it.spacingTitle)
      it.spacingTitle.onclick = () => toggleDisplayFlexNone(it.spacingOptions)
      it.spacingOptions = this.create("div/flex-row", it.optionsContainer)
      it.spacingOptions.style.display = "none"

      it.toggleMarginButton = this.render("text/link", "Außenabstand umschalten", it.spacingOptions)
      it.toggleMarginTopButton = this.render("text/link", "Außenabstand Oben umschalten", it.spacingOptions)
      it.toggleMarginRightButton = this.render("text/link", "Außenabstand Rechts umschalten", it.spacingOptions)
      it.toggleMarginBottomButton = this.render("text/link", "Außenabstand Unten umschalten", it.spacingOptions)
      it.toggleMarginLeftButton = this.render("text/link", "Außenabstand Links umschalten", it.spacingOptions)
      it.exactMarginButton = this.render("text/link", "Exakter Außenabstand", it.spacingOptions)
      it.exactMarginTopButton = this.render("text/link", "Exakter Außenabstand Oben", it.spacingOptions)
      it.exactMarginRightButton = this.render("text/link", "Exakter Außenabstand Rechts", it.spacingOptions)
      it.exactMarginBottomButton = this.render("text/link", "Exakter Außenabstand Unten", it.spacingOptions)
      it.exactMarginLeftButton = this.render("text/link", "Exakter Außenabstand Links", it.spacingOptions)
      it.togglePaddingButton = this.render("text/link", "Innenabstand umschalten", it.spacingOptions)
      it.togglePaddingTopButton = this.render("text/link", "Innenabstand umschalten Oben", it.spacingOptions)
      it.togglePaddingRightButton = this.render("text/link", "Innenabstand umschalten Rechts", it.spacingOptions)
      it.togglePaddingBottomButton = this.render("text/link", "Innenabstand umschalten Unten", it.spacingOptions)
      it.togglePaddingLeftButton = this.render("text/link", "Innenabstand umschalten Links", it.spacingOptions)
      it.exactPaddingButton = this.render("text/link", "Exakter Innenabstand", it.spacingOptions)
      it.exactPaddingTopButton = this.render("text/link", "Exakter Innenabstand Oben", it.spacingOptions)
      it.exactPaddingRightButton = this.render("text/link", "Exakter Innenabstand Rechts", it.spacingOptions)
      it.exactPaddingBottomButton = this.render("text/link", "Exakter Innenabstand Unten", it.spacingOptions)
      it.exactPaddingLeftButton = this.render("text/link", "Exakter Innenabstand Links", it.spacingOptions)

      it.borderTitle = this.render("text/hr", "Anwendungen für die Grenzlinien", it.optionsContainer)
      this.add("outline-hover", it.borderTitle)
      it.borderTitle.onclick = () => toggleDisplayFlexNone(it.borderOptions)
      it.borderOptions = this.create("div/flex-row", it.optionsContainer)
      it.borderOptions.style.display = "none"

      it.toggleBorderButton = this.render("text/link", "Grenzlinien umschalten", it.borderOptions)
      it.toggleBorderTopButton = this.render("text/link", "Grenzlinie Oben umschalten", it.borderOptions)
      it.toggleBorderRightButton = this.render("text/link", "Grenzlinie Rechts umschalten", it.borderOptions)
      it.toggleBorderBottomButton = this.render("text/link", "Grenzlinie Unten umschalten", it.borderOptions)
      it.toggleBorderLeftButton = this.render("text/link", "Grenzlinie Links umschalten", it.borderOptions)
      it.exactBorderButton = this.render("text/link", "Exakte Grenzlinien", it.borderOptions)
      it.exactBorderTopButton = this.render("text/link", "Exakte Grenzlinien Oben", it.borderOptions)
      it.exactBorderRightButton = this.render("text/link", "Exakte Grenzlinien Rechts", it.borderOptions)
      it.exactBorderBottomButton = this.render("text/link", "Exakte Grenzlinien Unten", it.borderOptions)
      it.exactBorderLeftButton = this.render("text/link", "Exakte Grenzlinien Links", it.borderOptions)
      it.toggleBorderRadiusButton = this.render("text/link", "Grenzradius umschalten", it.borderOptions)
      it.toggleBorderTopLeftRadiusButton = this.render("text/link", "Grenzradius Oben-Links umschalten", it.borderOptions)
      it.toggleBorderTopRightRadiusButton = this.render("text/link", "Grenzradius Oben-Rechts umschalten", it.borderOptions)
      it.toggleBorderBottomRightRadiusButton = this.render("text/link", "Grenzradius Unten-Rechts umschalten", it.borderOptions)
      it.toggleBorderBottomLeftRadiusButton = this.render("text/link", "Grenzradius Unten-Links umschalten", it.borderOptions)
      it.exactBorderRadiusButton = this.render("text/link", "Exakter Grenzradius", it.borderOptions)
      it.exactBorderTopLeftRadiusButton = this.render("text/link", "Exakter Grenzradius Oben-Links", it.borderOptions)
      it.exactBorderTopRightRadiusButton = this.render("text/link", "Exakter Grenzradius Oben-Rechts", it.borderOptions)
      it.exactBorderBottomRightRadiusButton = this.render("text/link", "Exakter Grenzradius Unten-Rechts", it.borderOptions)
      it.exactBorderBottomLeftRadiusButton = this.render("text/link", "Exakter Grenzradius Unten-Links", it.borderOptions)
      it.toggleBorderNoneButton = this.render("text/link", "Grenzradius None umschalten", it.borderOptions)
      it.boxButton = this.render("text/link", "Box umschalten", it.borderOptions)
      it.exactBoxShadowButton = this.render("text/link", "Exakter Box Schatten", it.borderOptions)

      it.mediaQueriesTitle = this.render("text/hr", "Anwendungen für Media Queries", it.optionsContainer)
      this.add("outline-hover", it.mediaQueriesTitle)
      it.mediaQueriesTitle.onclick = () => toggleDisplayFlexNone(it.mediaQueriesOptions)
      it.mediaQueriesOptions = this.create("div/flex-row", it.optionsContainer)
      it.mediaQueriesOptions.style.display = "none"

      it.mediaQueriesOverviewButton = this.render("text/link", "Medien Abfragen öffnen", it.mediaQueriesOptions)
      it.openMediaQueriesOverlay = this.fn("openMediaQueriesOverlay")
      it.largeDeviceButton = this.render("text/link", "Style für große Geräte", it.mediaQueriesOptions)
      it.addLargeStyle = this.fn("addLargeStyle")
      it.middleDeviceButton = this.render("text/link", "Style für mittlere Geräte", it.mediaQueriesOptions)
      it.addMiddleStyle = this.fn("addMiddleStyle")
      it.smallDeviceButton = this.render("text/link", "Style für kleine Geräte", it.mediaQueriesOptions)
      it.addSmallStyle = this.fn("addSmallStyle")
      it.printerDeviceButton = this.render("text/link", "Style für Druck Geräte", it.mediaQueriesOptions)
      it.addPrinterStyle = this.fn("addPrinterStyle")

      it.optimizeWorkTitle = this.render("text/hr", "Anwendungen für schnelle Korrekturen", it.optionsContainer)
      this.add("outline-hover", it.optimizeWorkTitle)
      it.optimizeWorkTitle.onclick = () => toggleDisplayFlexNone(it.optimizeWorkOptions)
      it.optimizeWorkOptions = this.create("div/flex-row", it.optionsContainer)
      it.optimizeWorkOptions.style.display = "none"

      it.insertAfterButton = this.render("text/link", "Danach einfügen", it.optimizeWorkOptions)
      it.insertAfter = this.fn("insertAfter")
      it.insertBeforeButton = this.render("text/link", "Davor einfügen", it.optimizeWorkOptions)
      it.insertBefore = this.fn("insertBefore")
      it.insertLeftButton = this.render("text/link", "Links einfügen", it.optimizeWorkOptions)
      it.insertLeft = this.fn("insertLeft")
      it.insertRightButton = this.render("text/link", "Rechts einfügen", it.optimizeWorkOptions)
      it.insertRight = this.fn("insertRight")
      it.cutOuterHtmlButton = this.render("text/link", "HTML ausschneiden", it.optimizeWorkOptions)
      it.addOuterHtmlToClipboard = this.fn("addOuterHtmlToClipboard")
      it.copyOuterHtmlButton = this.render("text/link", "HTML kopieren", it.optimizeWorkOptions)
      it.appendClipboardToNode = this.fn("appendClipboardToNode")
      it.pasteOuterHtmlButton = this.render("text/link", "HTML einfügen", it.optimizeWorkOptions)
      it.appendStyleButton = this.render("text/link", "Style anhängen", it.optimizeWorkOptions)
      it.appendStyleWithPrompt = this.fn("appendStyleWithPrompt")
      it.copyStyleButton = this.render("text/link", "Style kopieren", it.optimizeWorkOptions)
      it.addStyleToClipboard = this.fn("addStyleToClipboard")
      it.pasteStyleButton = this.render("text/link", "Style einfügen", it.optimizeWorkOptions)
      it.addClipboardToStyle = this.fn("addClipboardToStyle")
      it.removeStyleButton = this.render("text/link", "Style entfernen", it.optimizeWorkOptions)
      it.removeInnerButton = this.render("text/link", "Inhalt entfernen", it.optimizeWorkOptions)
      it.replaceInnerHtmlWithPrompt = this.fn("replaceInnerHtmlWithPrompt")
      it.removeInnerWithTextButton = this.render("text/link", "Inhalt ersetzen", it.optimizeWorkOptions)
      it.replaceTextContentWithPrompt = this.fn("replaceTextContentWithPrompt")
      it.removeNodeButton = this.render("text/link", "Element entfernen", it.optimizeWorkOptions)
      it.idButton = this.render("text/link", "Id definieren", it.optimizeWorkOptions)
      it.setIdWithPrompt = this.fn("setIdWithPrompt")
      it.addClassButton = this.render("text/link", "Klasse definieren", it.optimizeWorkOptions)
      it.setClassWithPrompt = this.fn("setClassWithPrompt")
      it.setAttributeButton = this.render("text/link", "Attribut setzen", it.optimizeWorkOptions)
      it.setAttributeWithPrompt = this.fn("setAttributeWithPrompt")


      it.contentCheckerTitle = this.render("text/hr", "Anwendungen für Inhalte prüfen", it.optionsContainer)
      this.add("outline-hover", it.contentCheckerTitle)
      it.contentCheckerTitle.onclick = () => toggleDisplayFlexNone(it.contentCheckerOptions)
      it.contentCheckerOptions = this.create("div/flex-row", it.optionsContainer)
      it.contentCheckerOptions.style.display = "none"

      it.some = this.render("text/link", "Als Zitat markieren", it.contentCheckerOptions)
      // do some crazy shit with content

      it.forEachChildTitle = this.render("text/hr", "Anwendungen für jedes Kind Element", it.optionsContainer)
      this.add("outline-hover", it.forEachChildTitle)
      it.forEachChildTitle.onclick = () => toggleDisplayFlexNone(it.forEachChildrenOptions)
      it.forEachChildrenOptions = this.create("div/flex-row", it.optionsContainer)
      it.forEachChildrenOptions.style.display = "none"

      it.fontSizeForEachChildButton = this.render("text/link", "Schriftgröße definieren", it.forEachChildrenOptions)

      it.pickColorTitle = this.render("text/hr", "Anwendungen für Code und Farben wählen", it.optionsContainer)
      this.add("outline-hover", it.pickColorTitle)
      it.pickColorTitle.onclick = () => toggleDisplayFlexNone(it.colorPickerOptions)
      it.colorPickerOptions = this.create("div/flex-row", it.optionsContainer)
      it.colorPickerOptions.style.display = "none"
      this.style(it.colorPickerOptions, {height: "377px", overflow: "auto"})
      this.fn("renderColors")(it.colorPickerOptions, (value) => {
        this.convert("text/clipboard", value).then(() => {
          window.alert("Der Hex-Code deiner Farbe wurde erfolgreich in die Zwischenablage gespeichert.")
        })
      })

      it.pickSvgTitle = this.render("text/hr", "Anwendungen für SVG einsetzen", it.optionsContainer)
      this.add("outline-hover", it.pickSvgTitle)
      it.pickSvgTitle.onclick = () => toggleDisplayFlexNone(it.svgPickerOptions)
      it.svgPickerOptions = this.create("div/flex-row", it.optionsContainer)
      it.svgPickerOptions.style.display = "none"
      it.svgPickerOptions.style.paddingBottom = "144px"
      it.svgIcons = this.fn("appendAllSvgIcons")

      return it
    }

    if (event === "createAnchorWithPrompt") {

      return (node) => {
        const prompt = window.prompt("Gebe die Quell-Url deines Links ein:")
        if (!this.verifyIs("text/empty", prompt)) {
          const a = document.createElement("a")
          a.textContent = "(z.B., Startseite)"
          a.style.margin = "21px 34px"
          a.style.cursor = "pointer"
          a.href = prompt
          node.appendChild(a)
        }
      }
    }

    if (event === "createPdfLinkWithPrompt") {

      return async (node) => {
        const prompt = window.prompt("Gebe die Quell-Url deiner PDF ein:")
        if (!this.verifyIs("text/empty", prompt)) {
          const a = document.createElement("a")
          input.node.appendChild(a)
          a.classList.add("pdf-link")
          a.href = prompt
          a.style.margin = "21px 34px"
          a.style.display = "flex"
          a.style.alignItems = "center"
          a.style.cursor = "pointer"
          const icon = await this.render("icon/node/path", "/public/pdf-doc.svg", a)
          icon.firstChild.style.fill = this.colors.light.error
          icon.style.width = "34px"
          const text = this.create("p", a)
          text.textContent = "(z.B., produkt.pdf)"
        }
      }
    }

    if (event === "createActionButton") {

      return (node) => {
        const button = this.create("button/action", node)
        button.classList.add("button")
        button.textContent = "(z.B., Daten jetzt speichern)"
      }
    }

    if (event === "createArrowRightWithColorPrompt") {

      return (node) => {
        const prompt = window.prompt("Gebe die Farbe deines Pfeils ein:")
        if (!this.verifyIs("text/empty", prompt)) {
          const arrow = document.createElement("div")
          arrow.style.display = "flex"
          arrow.style.justifyContent = "center"
          arrow.style.alignItems = "center"
          arrow.style.width = "100%"
          arrow.style.height = "34px"
          node.appendChild(arrow)
          const line = document.createElement("div")
          line.style.height = "3px"
          line.style.backgroundColor = prompt
          line.style.width = "100%"
          arrow.appendChild(line)
          const symbol = document.createElement("span")
          symbol.style.display = "flex"
          symbol.style.justifyContent = "center"
          symbol.style.alignItems = "center"
          symbol.style.fontSize = "21px"
          symbol.style.color = prompt
          symbol.textContent = "➤"
          arrow.appendChild(symbol)
        }
      }
    }

    if (event === "createBackgroundImageWithTitles") {

      return (node) => {
        const prompt = window.prompt("Gebe die URL deines Hintergrund Bildes ein:")
        if (!this.verifyIs("text/empty", prompt)) {
          const backgroundDiv = document.createElement("div")
          node.appendChild(backgroundDiv)
          this.style(backgroundDiv, {marginBottom: "55px", height: "100vh", width: "100%", backgroundImage: `url(${prompt})`, backgroundSize: "cover", backgroundPosition: "center", backgroundRepeat: "no-repeat", display: "flex", justifyContent: "center", alignItems: "center"})
          const titleContainer = document.createElement("div")
          backgroundDiv.appendChild(titleContainer)
          this.style(titleContainer, {wordBreak: "break-word", display: "flex", justifyContent: "center", alignItems: "center", flexDirection: "column", padding: "21px", lineHeight: "1.5"})
          const h1 = document.createElement("h1")
          titleContainer.appendChild(h1)
          this.style(h1, {textTransform: "uppercase", fontSize: "34px", color: "white", fontFamily: "sans-serif", margin: "0 0 21px 0", letterSpacing: "3px"})
          const h2 = document.createElement("h2")
          titleContainer.appendChild(h2)
          this.style(h2, {textAlign: "center", fontSize: "89px", color: "white", fontFamily: "sans-serif", margin: "0 0 21px 0"})
          h1.textContent = "HAUPTTITEL"
          h2.textContent = "UNTERTITEL"
        }
      }
    }

    if (event === "createImageTextAndActionBox") {

      return (node) => {
        const prompt = window.prompt("Gebe die URL deines Bildes ein:")
        const container = document.createElement("div")
        node.appendChild(container)
        this.style(container, {padding: "8px", minHeight: "100vh", display: "flex", justifyContent: "center", alignItems: "center", flexWrap: "wrap"})
        const image = document.createElement("div")
        container.appendChild(image)
        this.style(image, {width: "100%", maxWidth: "610px", display: "flex", justifyContent: "center", alignItems: "center"})
        const img = document.createElement("img")
        if (!this.verifyIs("text/empty", prompt)) {
          img.src = prompt
        } else {
          img.src = "/public/image.svg"
        }
        img.style.width = "100%"
        image.appendChild(img)
        const text = document.createElement("div")
        container.appendChild(text)
        this.style(text, {wordBreak: "break-word", width: "100%", display: "flex", flexDirection: "column", fontFamily: "sans-serif", margin: "21px 13px", maxWidth: "610px"})
        const h4 = document.createElement("h4")
        text.appendChild(h4)
        this.style(h4, {fontSize: "21px", color: "#0EA35B", textTransform: "uppercase", margin: "0 0 21px 0"})
        h4.textContent = "Content Titel"
        const h3 = document.createElement("h3")
        text.appendChild(h3)
        this.style(h3, {fontSize: "55px", color: "#22395D", margin: "0 0 21px 0"})
        h3.textContent = "Content Beschreibung"
        const content = document.createElement("div")
        text.appendChild(content)
        this.style(content, {fontSize: "21px", color: "#818491", lineHeight: "1.5"})
        content.textContent = this.lorem(144)
        const action = document.createElement("div")
        text.appendChild(action)
        action.textContent = "Action Button"
        this.style(action, {cursor: "pointer", alignSelf: "center", width: "233px", margin: "55px 34px", padding: "13px 21px", color: "white", fontSize: "21px", backgroundColor: "#006F3A", borderRadius: "13px", textAlign: "center"})
        node.appendChild(container)
      }
    }

    if (event === "createProfileSurveysBox") {

      return (node) => {
        const box = this.create("div")
        this.style(box, {borderRadius: "5px", margin: "21px 13px", fontFamily: "sans-serif", boxShadow: "rgba(0, 0, 0, 0.13) 0px 1px 3px"})
        node.appendChild(box)
        const title = this.create("h2")
        title.textContent = "Umfragen"
        box.appendChild(title)
        this.style(title, {margin: "0", padding: "13px"})
        const valueUnits = this.create("div")
        valueUnits.classList.add("profile-surveys")
        this.style(valueUnits, {padding: "13px"})
        box.appendChild(valueUnits)
        const script = this.create("script", {id: "profile-surveys", js: 'await Helper.add("profile-surveys")'})
        this.add("script-onbody", script)
        window.alert("Vorlage wurde erfolgreich angehängt.")
      }
    }

    if (event === "createMyValueUnitsBox") {

      return (node) => {
        const box = this.create("div")
        this.style(box, {borderRadius: "5px", margin: "21px 13px", fontFamily: "sans-serif", boxShadow: "rgba(0, 0, 0, 0.13) 0px 1px 3px"})
        node.appendChild(box)
        const title = this.create("h2")
        title.textContent = "Meine Werteinheiten"
        box.appendChild(title)
        this.style(title, {margin: "0", padding: "13px"})
        const valueUnits = this.create("div")
        valueUnits.classList.add("my-value-units")
        this.style(valueUnits, {padding: "13px"})
        box.appendChild(valueUnits)
        const script = this.create("script", {id: "my-value-units", js: 'await Helper.add("my-value-units")'})
        this.add("script-onbody", script)
        window.alert("Vorlage wurde erfolgreich angehängt.")
      }
    }

    if (event === "createFlexRow") {

      return (node) => {
        node.style.display = "flex"
        node.style.flexDirection = null
        node.style.flexWrap = "wrap"
        const div = document.createElement("div")
        div.style.margin = "21px 34px"
        div.textContent = "div"
        node.appendChild(div)
      }

    }

    if (event === "createFlexColumn") {

      return (node) => {
        node.style.display = "flex"
        node.style.flexDirection = "column"
        node.style.flexWrap = null
        const div = document.createElement("div")
        div.style.margin = "21px 34px"
        div.textContent = "div"
        node.appendChild(div)
      }

    }

    if (event === "create/div/flex-matrix-prompt/node") {

      const prompt = window.prompt("Gebe deine Zeilenmatrix ein: (z.B, 1 2 2)")
      const regex = /^([1-9] )*[1-9]$/
      if (regex.test(prompt)) {
        const rows = prompt.split(" ")
        const wrapContainer = document.createElement("div")
        wrapContainer.classList.add("flex-container")
        wrapContainer.style.display = "flex"
        wrapContainer.style.flexWrap = "wrap"
        wrapContainer.style.margin = "21px 34px"
        for (var i = 0; i < rows.length; i++) {
          const row = rows[i]
          const rowNumber = parseInt(row)
          if (rowNumber >= 1 && rowNumber <= 9) {
            const rowDiv = document.createElement("div")
            rowDiv.classList.add(`row-${i + 1}`)
            rowDiv.style.width = "300px"
            rowDiv.style.display = "flex"
            rowDiv.style.flexWrap = "wrap"
            wrapContainer.append(rowDiv)
            for (let i = 0; i < rowNumber; i++) {
              const rowPart = document.createElement("div")
              rowPart.classList.add("row-part")
              rowPart.textContent = `(z.B., flex-item-${i + 1})`
              rowPart.style.width = `${100 / rowNumber}%`
              rowDiv.append(rowPart)
            }
          }
        }
        input.node.appendChild(wrapContainer)
        if (wrapContainer.children.length === 0) {
          wrapContainer.remove()
        }
      }

    }

    if (event === "createFlexWidthWithPrompt") {

      return (node) => {
        const prompt = window.prompt("Gebe die Breite deiner Flex Elemente ein: (z.B., 20% 300px 20vw)")
        if (!this.verifyIs("text/empty", prompt)) {
          const widths = prompt.split(" ")
          const flexContainer = document.createElement("div")
          flexContainer.classList.add("flex-container")
          flexContainer.style.display = "flex"
          flexContainer.style.margin = "21px 34px"
          flexContainer.style.flexWrap = "wrap"
          for (var i = 0; i < widths.length; i++) {
            const width = widths[i]
            const flexItem = document.createElement("div")
            flexItem.classList.add("flex-item")
            flexItem.textContent = `(z.B., flex-item-${i + 1})`
            flexItem.style.flex = `1 1 ${width}`
            flexContainer.appendChild(flexItem)
          }
          node.appendChild(flexContainer)
        }
      }

    }

    if (event === "createGridMatrixWithPrompt") {

      return (node) => {
        const prompt = window.prompt("Gebe die Matrix deiner Grid Elemente ein: (z.B., 2 3 3)")
        if (!this.verifyIs("text/empty", prompt)) {
          const columnsPerRow = prompt.split(" ").map(Number)
          const gridContainer = document.createElement("div")
          gridContainer.classList.add("grid-container")
          gridContainer.style.display = "grid"
          gridContainer.style.margin = "21px 34px"
          columnsPerRow.forEach(columns => {
            const gridRow = document.createElement("div")
            gridRow.classList.add("grid-row")
            gridRow.style.display = "grid"
            gridRow.style.gridTemplateColumns = `repeat(${columns}, minmax(0, 1fr))`
            for (let i = 0; i < columns; i++) {
              const gridItem = document.createElement("div")
              gridItem.classList.add("grid-item")
              gridItem.textContent = `(z.B., grid-item-${i + 1})`
              gridRow.appendChild(gridItem)
            }
            gridContainer.appendChild(gridRow)
          })
          node.appendChild(gridContainer)
        }
      }

    }

    if (event === "createHr") {

      return (node) => {
        const div = document.createElement("div")
        div.classList.add("hr")
        div.style.border = "0.5px solid black"
        node.appendChild(div)
      }
    }

    if (event === "createImageText") {

      return (node) => this.create("div/image-text", node)
    }

    if (event === "createKeyValue") {

      return (node) => this.create("div/key-value", node)
    }

    if (event === "createSafeDivPackOuter") {

      return (node) => {
        const div = this.create("div")
        div.setAttribute("style", node.getAttribute("style"))
        div.textContent = node.textContent
        node.parentElement.insertBefore(div, node)
        node.remove()
      }
    }

    if (event === "createDateInput") {

      return node => this.create("input/date", node)
    }

    if (event === "createDivPackOuter") {

      return async (node) => {
        const div = this.create("div")
        div.innerHTML = await this.convert("text/purified", node.outerHTML)
        node.replaceWith(div)
        return div
      }
    }

    if (event === "createScrollableY") {

      return node => this.create("div/scrollable", node)
    }

    if (event === "createSpaceWithHeightPrompt") {

      return (node) => {
        const prompt = window.prompt("Gebe den Abstand deines Leerraums, in px, ein: (z.B., 350)")
        if (!this.verifyIs("text/empty", prompt)) {
          const space = document.createElement("div")
          space.classList.add("space")
          space.style.width = "100%"
          space.style.height = `${prompt}px`
          node.appendChild(space)
        }
      }
    }

    if (event === "createH1withPrompt") {

      return (node) => {
        const prompt = window.prompt("Gebe den HTML Inhalt deiner Überschrift ein:")
        if (!this.verifyIs("text/empty", prompt)) {
          const h1 = this.create("h1")
          h1.textContent = prompt
          node.appendChild(h1)
        }
      }
    }

    if (event === "createH2withPrompt") {

      return (node) => {
        const prompt = window.prompt("Gebe den HTML Inhalt deiner Überschrift ein:")
        if (!this.verifyIs("text/empty", prompt)) {
          const h2 = this.create("h2")
          h2.textContent = prompt
          node.appendChild(h2)
        }
      }
    }

    if (event === "createH3withPrompt") {

      return (node) => {
        const prompt = window.prompt("Gebe den HTML Inhalt deiner Überschrift ein:")
        if (!this.verifyIs("text/empty", prompt)) {
          const h3 = this.create("h3")
          h3.textContent = prompt
          node.appendChild(h3)
        }
      }
    }

    if (event === "createLeftImageHeader") {

      return (node) => {
        const header = this.create("header/left", node)
        header.left.style.width = "34px"
      }
    }

    if (event === "createNode") {

      return (tag, parent, text = "") => {
        const node = document.createElement(tag)
        node.textContent = text
        parent.appendChild(node)
        return node
      }
    }

    if (event === "createTextNode") {

      return (parent, text = "") => {
        const node = document.createTextNode(text)
        parent.appendChild(node)
        return node
      }
    }

    if (event === "createImagePlaceholder") {

      return (node) => {
        const image = document.createElement("img")
        image.src = "/public/image.svg"
        image.style.width = "100%"
        node.appendChild(image)
      }
    }

    if (event === "createCheckboxInput") {

      return node => this.create("input/checkbox", node)
    }

    if (event === "createPasswordInput") {

      return node => this.create("input/password", node)
    }

    if (event === "createSelectInput") {

      return node => this.create("input/select", node)
    }

    if (event === "createTelInput") {

      return node => this.create("input/tel", node)
    }

    if (event === "createTextInput") {

      return node => this.create("input/text", node)
    }

    if (event === "createPwithPrompt") {

      return (node) => {
        const prompt = window.prompt("Gebe den HTML Inhalt deines Paragraphen ein:")
        const p = this.create("p", node)
        p.textContent = prompt
        return p
      }
    }

    if (event === "createSpanWithTextContent") {

      return (node) => {
        Array.from(node.childNodes).forEach(it => {
          if (it.nodeType === Node.TEXT_NODE) {
            const span = document.createElement("span")
            span.textContent = it.textContent
            input.node.replaceChild(span, it)
          }
        })
      }
    }

    if (event === "createSpanWithSiPrompt") {

      return (node) => {
        const prompt = window.prompt("Gebe deine SI-Einheit ein:")
        const si = document.createElement("span")
        si.classList.add("si")
        si.textContent = node.textContent
        if (prompt === "kWh" || prompt.startsWith("ct")) si.textContent = "0"
        if (
          prompt === "€" ||
          prompt.startsWith("EURO") ||
          prompt.startsWith("Euro") ||
          prompt === "%"
        ) si.textContent = "0,00"
        const unit = document.createElement("span")
        unit.classList.add("unit")
        unit.textContent = prompt
        unit.style.margin = "0 5px"
        node.textContent = ""
        node.appendChild(si)
        node.appendChild(unit)
      }
    }

    if (event === "createTableWithMatrixPrompt") {

      return (node) => {
        const prompt = window.prompt("Trenne Spalten mit Leerzeichen und bistimme die Breite deiner Tabelle von 1-9: (z.B., 4 1 1 4 (= 10))")
        if (!this.verifyIs("text/empty", prompt)) {
          const columns = prompt.split(" ")
          const table = document.createElement("table")
          table.style.width = "100%"
          table.row = document.createElement("tr")
          table.row.style.display = "flex"
          table.row.style.width = "100%"
          for (let i = 0; i < columns.length; i++) {
            const width = columns[i]
            const number = parseInt(width)
            if (number >= 1 && number <= 9) {
              table.header = document.createElement("th")
              table.header.textContent = `(z.B., th-${i + 1})`
              table.header.style.flex = `1 1 ${number * 10}%`
              table.row.appendChild(table.header)
            }
          }
          table.appendChild(table.row)
          node.appendChild(table)
          if (table.row.children.length === 0) {
            table.remove()
          }
        }
      }
    }

    if (event === "convertTextContentToDuckDuckGoLink") {
      return (node) => {
        const duckDuckGoUrl = "https://duckduckgo.com/?q="
        const textContent = node.textContent
        const encoded = encodeURIComponent(textContent)
        const searchUrl = duckDuckGoUrl + encoded
        const link = document.createElement("a")
        link.href = searchUrl
        link.target = "_blank"
        link.textContent = `DuckDuckGo-Suche für ' ${textContent} ' öffnen.`
        Helper.style(link, {fontFamily: "sans-serif"})
        Helper.convert("link-colors", link)
        node.textContent = ""
        node.appendChild(link)
      }
    }

    if (event === "convertTextContentToH1") {
      return (node) => {
        const h1 = document.createElement("h1")
        for (let i = 0; i < node.attributes.length; i++) {
          const attribute = node.attributes[i]
          h1.setAttribute(attribute.name, attribute.value)
        }
        h1.textContent = node.textContent
        const parent = node.parentNode
        if (parent) parent.replaceChild(h1, node)
        return h1
      }
    }

    if (event === "convertTextContentToH2") {
      return (node) => {
        const h2 = document.createElement("h2")
        for (let i = 0; i < node.attributes.length; i++) {
          const attribute = node.attributes[i]
          h2.setAttribute(attribute.name, attribute.value)
        }
        h2.textContent = node.textContent
        const parent = node.parentNode
        if (parent) parent.replaceChild(h2, node)
        return h2
      }
    }

    if (event === "convertTextContentToH3") {
      return (node) => {
        const h3 = document.createElement("h3")
        for (let i = 0; i < node.attributes.length; i++) {
          const attribute = node.attributes[i]
          h3.setAttribute(attribute.name, attribute.value)
        }
        h3.textContent = node.textContent
        const parent = node.parentNode
        if (parent) parent.replaceChild(h3, node)
        return h3
      }
    }

    if (event === "convertToInlineCite") {
      return (node) => {
        node.classList.add("inline-cite")
        let citationCounter = document.querySelectorAll(".inline-cite").length
        if (citationCounter === 0) citationCounter = 1
        node.setAttribute("citation-counter", citationCounter)
        if (node.classList.contains("full-cite")) node.classList.remove("full-cite")
        window.alert("Inhalt erfolgreich markiert.")
      }
    }

    if (event === "convertToFullCite") {
      return (node) => {
        if (node.classList.contains("inline-cite")) node.classList.remove("inline-cite")
        node.removeAttribute("citation-counter")
        for (let i = 0; i < document.querySelectorAll(".inline-cite").length; i++) {
          const inlineCite = document.querySelectorAll(".inline-cite")[i]
          inlineCite.setAttribute("citation-counter", i + 1)
        }
        node.classList.add("full-cite")
        window.alert("Inhalt erfolgreich markiert.")
      }
    }

    if (event === "removeCiteMarks") {

      return (node) => {
        if (node.classList.contains("inline-cite")) node.classList.remove("inline-cite")
        if (node.classList.contains("full-cite")) node.classList.remove("full-cite")
        node.removeAttribute("citation-counter")
        for (let i = 0; i < document.querySelectorAll(".inline-cite").length; i++) {
          const inlineCite = document.querySelectorAll(".inline-cite")[i]
          inlineCite.setAttribute("citation-counter", i + 1)
        }
        node.querySelectorAll("span[inline-cite]").forEach(span => span.remove())
        window.alert("Markierung erfolgreich entfernt.")
      }
    }

    if (event === "debounce") {

      let lastExecutionTime = 0
      let isBlocked = false
      return async (fn, millis) => {
        if (isBlocked) return
        const currentTime = Date.now()
        const timeSinceLastExecution = currentTime - lastExecutionTime
        if (timeSinceLastExecution >= millis) {
          try {
            fn()
          } catch (error) {
            console.error(error)
          } finally {
            lastExecutionTime = Date.now()
            isBlocked = true
            setTimeout(() => {
                isBlocked = false
            }, millis)
          }
        }
      }
    }

    if (event === "feedback") {

      function updateCounter() {
        const counter = document.querySelector("div.counter")
        if (parseInt(counter.textContent) > 0) {
          counter.style.background = "green"
          counter.style.color = "white"
        } else {
          Helper.convert("dark-light", counter)
        }
      }

      async function icon() {
        const icon = await Helper.create("icon/branch")
        return icon
      }

      function renderFeedback(type, feedback, container, button, overlay, script) {

        Helper.convert("parent/scrollable", container)
        container.style.margin = "21px 34px"
        container.style.overscrollBehavior = "none"
        container.style.fontFamily = "monospace"
        container.style.fontSize = "21px"
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
          container.style.color = Helper.colors.dark.text
        } else {
          container.style.color = Helper.colors.light.text
        }

        for (let i = 0; i < feedback.length; i++) {
          const it = feedback[i]

          const div = document.createElement("div")
          Helper.add("outline-hover", div)
          div.style.display = "flex"
          div.style.justifyContent = "space-between"
          div.style.alignItems = "center"

          if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            if (i % 2 === 0) {
              div.style.background = Helper.colors.light.foreground
              div.style.color = Helper.colors.light.text
            } else {
              div.style.background = Helper.colors.dark.foreground
              div.style.color = Helper.colors.dark.text
            }
          } else {
            if (i % 2 === 1) {
              div.style.background = Helper.colors.light.foreground
              div.style.color = Helper.colors.light.text
            } else {
              div.style.background = Helper.colors.dark.foreground
              div.style.color = Helper.colors.dark.text
            }
          }

          const left = document.createElement("span")
          left.textContent = `${Helper.convert("millis/dd.mm.yyyy hh:mm", it.created)}`
          div.appendChild(left)

          const nextToLeft = document.createElement("span")
          nextToLeft.style.width = "100%"
          nextToLeft.style.padding = "8px"
          nextToLeft.textContent = it.text
          div.appendChild(nextToLeft)

          const right = document.createElement("span")
          right.style.padding = "13px"
          right.textContent = it.importance
          div.appendChild(right)

          container.appendChild(div)

          div.style.cursor = "pointer"
          div.onclick = () => {
            Helper.overlay("popup", updateFeedbackOverlay => {
              const removeButton = Helper.create("button/left-right", updateFeedbackOverlay)
              Helper.add("outline-hover", removeButton)
              Helper.render("icon/node/path", "/public/bucket.svg", removeButton.left).then(icon => {
                icon.style.width = "34px"
              })
              removeButton.right.textContent = "Feedback entfernen"
              removeButton.onclick = async () => {
                const confirm = window.confirm("Möchtest du diesen Beitrag wirklich entfernen?")
                if (confirm === true) {

                  let res
                  if (type === "html-value") {
                    res = await Helper.request(`/remove/feedback/${type}/`, {id: it.created})
                  }
                  if (type === "script") {
                    res = await Helper.request(`/remove/feedback/${type}/`, {scriptId: script.created, feedbackId: it.created})
                  }

                  if (res && res.status === 200) {
                    window.alert("Dieser Beitrag wurde erfolgreich entfernt.")
                    const counter = document.querySelector("div.counter")
                    counter.textContent = parseInt(counter.textContent) - 1
                    updateCounter()
                    div.remove()
                    updateFeedbackOverlay.remove()
                    overlay.remove()
                  } else {
                    window.alert("Fehler.. Bitte wiederholen.")
                    updateFeedbackOverlay.remove()
                  }
                }
              }
            })
          }
        }

      }

      function createFeedbackFields(node) {
        const fields = {}
        fields.textField = Helper.create("input/textarea", node)
        fields.textField.input.setAttribute("required", "true")
        fields.textField.input.maxLength = "377"
        fields.textField.input.style.fontSize = "13px"
        fields.textField.input.placeholder = "Schreibe ein anonymes Feedback, wenn du möchtest.."
        Helper.verify("input/value", fields.textField.input)
        Helper.add("outline-hover", fields.textField.input)
        fields.textField.input.addEventListener("input", () => Helper.verify("input/value", fields.textField.input))
        fields.importanceField = Helper.create("field/range", node)
        fields.importanceField.input.min = "0"
        fields.importanceField.input.max = "13"
        fields.importanceField.input.step = "1"
        fields.importanceField.input.value = "0"
        fields.importanceField.label.textContent = `Wichtigkeit - ${fields.importanceField.input.value}`
        fields.importanceField.input.style.cursor = "pointer"
        Helper.add("outline-hover", fields.importanceField.input)
        Helper.verify("input/value", fields.importanceField.input)
        fields.importanceField.input.addEventListener("input", (event) => {
          Helper.verify("input/value", fields.importanceField.input)
          fields.importanceField.label.textContent = `Wichtigkeit - ${event.target.value}`
        })
        fields.submit = Helper.create("toolbox/action", node)
        fields.submit.textContent = "Feedback jetzt speichern"
        return fields
      }

      function bodyButton() {
        const button = Helper.create("button/html-feedback")
        button.classList.add("feedback")
        button.counter.textContent = "0"
        Helper.convert("dark-light", button)

        let exist = false
        document.querySelectorAll("*").forEach(node => {
          if (node.classList.contains("feedback") && node.classList.contains("button")) {
            exist = true
          }
        })
        if (exist === false) document.body.appendChild(button)

        const counter = document.querySelector("div.counter")
        Helper.request("/get/feedback/length-html-value/").then((res) => {
          if (res.status === 200) {
            counter.textContent = res.response
            if (parseInt(counter.textContent) > 0) {
              counter.style.background = "green"
              counter.style.color = "white"
            }
          }
        })

        const feedbackButton = document.querySelector("div.feedback.button")
        Helper.add("outline-hover", feedbackButton)
        feedbackButton.onclick = () => openLocationOverlay(button)
      }

      async function initScriptCounter(id, button) {
        const res = await Helper.request("/get/feedback/length-script/", {id})
        if (res.status === 200) {
          const counter = document.querySelector("div.counter")
          counter.textContent = res.response
          updateCounter()
        }
      }

      async function getLocationFeedback(container, button, overlay) {
        const res = await Helper.request(`/get/feedback/html-value/`)
        if (res && res.status === 200) {
          const feedback = JSON.parse(res.response)
          renderFeedback("html-value", feedback, container, button, overlay)
        } else {
          Helper.convert("style/info", container)
          container.textContent = "Kein Feedback gefunden"
          Helper.style(container, {margin: "21px 34px"})
        }
      }

      function openLocationOverlay(button) {
        Helper.overlay("popup", async overlay => {
          overlay.info.textContent = `html.feedback`
          const funnel = Helper.create("div/scrollable", overlay)
          const fields = createFeedbackFields(funnel)
          fields.submit.onclick = async () => {
            await Helper.verify("input/value", fields.textField.input)
            Helper.overlay("security", async securityOverlay => {
              const res = await Helper.request(`/register/feedback/html-value/`, {text: fields.textField.input.value, importance: fields.importanceField.input.value})
              if (res.status === 200) {
                window.alert("Vielen Dank für dein Feedback.\n\nDein Feedback ist vollkommen anonym, dynamisch und hilft dabei diese Webseite, noch besser für dich, zu optimieren.")
                securityOverlay.remove()
                overlay.remove()
                const counter = document.querySelector("div.counter")
                counter.textContent = parseInt(counter.textContent) + 1
                updateCounter()
                await getLocationFeedback(feedbackContainer, button, overlay)
              } else {
                window.alert("Fehler.. Bitte wiederholen.")
                securityOverlay.remove()
              }
            })
          }
          const feedbackContainer = Helper.create("info/loading", funnel)
          await getLocationFeedback(feedbackContainer, button, overlay)
        })
      }

      function openScriptOverlay(button, script) {

        Helper.overlay("popup", async overlay => {
          overlay.info.textContent = `${script.name}.feedback`
          const funnel = Helper.create("div/scrollable", overlay)
          const fields = createFeedbackFields(funnel)
          fields.submit.onclick = async () => {
            await Helper.verify("field-funnel", funnel)
            Helper.overlay("security", async securityOverlay => {
              const res = await Helper.request("/register/feedback/script/", {id: script.created, text: fields.textField.input.value, importance: fields.importanceField.input.value})
              if (res.status === 200) {
                window.alert("Vielen Dank für dein Feedback.\n\nDein Feedback ist vollkommen anonym, dynamisch und hilft dabei dieses Skript, noch besser für dich, zu optimieren.")
                securityOverlay.remove()
                overlay.remove()
                const counter = document.querySelector("div.counter")
                counter.textContent = parseInt(counter.textContent) + 1
                updateCounter()
              } else {
                window.alert("Fehler.. Bitte wiederholen.")
                securityOverlay.remove()
              }
            })
          }
          const feedbackContainer = Helper.create("info/loading", funnel)
          const res = await Helper.request("/get/feedback/script/", {id: script.created})
          if (res && res.status === 200) {
            const feedback = JSON.parse(res.response)
            renderFeedback("script", feedback, feedbackContainer, button, overlay, script)
          } else {
            Helper.convert("style/info", feedbackContainer)
            feedbackContainer.textContent = "Kein Feedback gefunden"
            Helper.style(feedbackContainer, {margin: "21px 34px"})
          }
        })
      }

      return {open, icon, openScriptOverlay, bodyButton, initScriptCounter}
    }

    if (event === "handleClassName") {

      const {platform, key} = input
      const numerology = this.fn("numerology")


      const handlers = {

        birthdate: (node, value) => {

          if (platform === "numerologie") {
            const date = new Date(value)
            const lifepath = numerology.dateToLifePath(date)
            const lifepathText = Helper.convert("number/de", lifepath)
            const millis = date.getTime()
            const formatted = Helper.convert("millis/dd.mm.yyyy", millis)
            node.textContent = formatted
            Helper.on("hover", {node, class: "outline pointer"})
            node.onclick = ev => {
              numerology.openBirthDateOverlay(date)
            }
            document.querySelectorAll("[lifepath='number']").forEach(node => node.textContent = lifepath)
            fetch(`/entwicklung/numerologie/geburtsenergie-${lifepathText}/`)
            .then(data => data.text())
            .then(async text => {
              const purified = await this.convert("text/purified", text)
              const doc = this.convert("text/doc", purified)
              const contentNodes = Array.from(doc.body.querySelectorAll(".content"))
              if (contentNodes.length > 0) {
                const randomIndex = Math.floor(Math.random() * contentNodes.length)
                const randomText = contentNodes[randomIndex].textContent
                const lifepathNode = document.querySelector("[lifepath='content']")
                if (lifepathNode) {
                  lifepathNode.textContent = randomText
                }
              }
            })
          }
        },
        birthname: (node, value) => {

          node.textContent = value
          Helper.on("hover", {node, class: "outline pointer"})
          node.onclick = ev => {
            numerology.openBirthNameOverlay(value)
          }
        },
        default: (node, value) => node.textContent = value
      }
      return handlers[key] || handlers.default
    }

    if (event === "incrementStyle") {

      return ({key, node, delta}) => {
        if (node.style[key]) {
          const match = node.style[key].match(/(\d+(\.\d+)?)(\D.*)/)
          if (match) {
            let number = parseFloat(match[1])
            number = number + delta
            const remainingChars = match[3]
            node.style[key] = `${number}${remainingChars}`
          }
        }
      }

    }

    if (event === "insertAfter") {

      return (selectedNode, cache) => {
        if (selectedNode) {
          if (cache.length > 0) {
            const { node } = cache.pop()
            selectedNode.after(node)
          } else {
            this.convert("clipboard/text").then(text => {
              const node = this.convert("text/first-child", text)
              selectedNode.after(node)
            })
          }
        }
      }
    }

    if (event === "insertBefore") {

      return (selectedNode, cache) => {
        if (selectedNode) {
          if (cache.length > 0) {
            const { node } = cache.pop()
            selectedNode.before(node)
          } else {
            this.convert("clipboard/text").then(text => {
              const node = this.convert("text/first-child", text)
              selectedNode.before(node)
            })
          }
        }
      }
    }

    if (event === "insertLeft") {

      return (selectedNode, cache) => {
        if (selectedNode) {
          if (cache.length > 0) {
            const { node, parent, index } = cache.pop()
            if (selectedNode.firstChild) {
              selectedNode.insertBefore(node, selectedNode.firstChild)
            } else {
              selectedNode.appendChild(node)
            }
          } else {
            this.convert("clipboard/text").then(text => {
              const node = this.convert("text/first-child", text)
              if (selectedNode.firstChild) {
                selectedNode.insertBefore(node, selectedNode.firstChild)
              } else {
                selectedNode.appendChild(node)
              }
            })
          }
        }
      }
    }

    if (event === "insertRight") {

      return (selectedNode, cache) => {
        if (selectedNode) {
          if (cache.length > 0) {
            const { node, parent, index } = cache.pop()
            selectedNode.appendChild(node)
          } else {
            this.convert("clipboard/text").then(text => {
              const node = this.convert("text/first-child", text)
              selectedNode.appendChild(node)
            })
          }
        }
      }
    }

    if (event === "decrementStyle") {

      return ({key, node, delta}) => {
        if (node.style[key]) {
          const match = node.style[key].match(/(\d+(\.\d+)?)(\D.*)/)
          if (match) {
            let number = parseFloat(match[1])
            number = number - delta
            const remainingChars = match[3]
            node.style[key] = `${number}${remainingChars}`
          }
        }
      }

    }

    if (event === "numerology") {

      const it = {}
      const numbersAsText = ['eins', 'zwei', 'drei', 'vier', 'fuenf', 'sechs', 'sieben', 'acht', 'neun']
      const occurencies = ['ein-mal', 'zwei-mal', 'drei-mal', 'vier-mal', 'fuenf-mal', 'sechs-mal', 'sieben-mal', 'acht-mal', 'neun-mal']
      const latinAlphabet = {
        'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5,
        'f': 6, 'g': 7, 'h': 8, 'i': 9, 'j': 1,
        'k': 2, 'l': 3, 'm': 4, 'n': 5, 'o': 6,
        'p': 7, 'q': 8, 'r': 9, 's': 1, 't': 2,
        'u': 3, 'v': 4, 'w': 5, 'x': 6, 'y': 7,
        'z': 8
      }
      const greekAlphabet = {
        'α': 1, 'β': 2, 'γ': 3, 'δ': 4, 'ε': 5,
        'ζ': 6, 'η': 7, 'θ': 8, 'ι': 9, 'κ': 1,
        'λ': 2, 'μ': 3, 'ν': 4, 'ξ': 5, 'ο': 6,
        'π': 7, 'ρ': 8, 'σ': 9, 'τ': 1, 'υ': 2,
        'φ': 3, 'χ': 4, 'ψ': 5, 'ω': 6
      }
      const russianAlphabet = {
        'а': 1, 'б': 2, 'в': 3, 'г': 4, 'д': 5,
        'е': 6, 'ё': 7, 'ж': 8, 'з': 9, 'и': 1,
        'й': 2, 'к': 3, 'л': 4, 'м': 5, 'н': 6,
        'о': 7, 'п': 8, 'р': 9, 'с': 1, 'т': 2,
        'у': 3, 'ф': 4, 'х': 5, 'ц': 6, 'ч': 7,
        'ш': 8, 'щ': 9, 'ъ': 1, 'ы': 2, 'ь': 3,
        'э': 4, 'ю': 5, 'я': 6
      }
      const alphabetMap = {
        ...latinAlphabet,
        ...greekAlphabet,
        ...russianAlphabet
      }
      const latinConsonants = ['b', 'c', 'd', 'f', 'g', 'h', 'j', 'k', 'l', 'm', 'n', 'p', 'q', 'r', 's', 't', 'v', 'w', 'x', 'y', 'z']
      const greekConsonants = ['β', 'γ', 'δ', 'ζ', 'θ', 'κ', 'λ', 'μ', 'ν', 'ξ', 'π', 'ρ', 'σ', 'τ', 'φ', 'χ', 'ψ']
      const russianConsonants = ['б', 'в', 'г', 'д', 'ж', 'з', 'й', 'к', 'л', 'м', 'н', 'п', 'р', 'с', 'т', 'ф', 'х', 'ц', 'ч', 'ш', 'щ']
      const consonants = [
        ...latinConsonants,
        ...greekConsonants,
        ...russianConsonants
      ]
      const latinVowels = ['a', 'e', 'i', 'o', 'u', 'y']
      const greekVowels = ['α', 'ε', 'η', 'ι', 'ο', 'υ', 'ω']
      const russianVowels = ['а', 'е', 'ё', 'и', 'о', 'у', 'ы', 'э', 'ю', 'я']
      const vowels = [
        ...latinVowels,
        ...greekVowels,
        ...russianVowels
      ]
      function calculateAge(date) {
        const currentDate = new Date()
        let age = currentDate.getFullYear() - date.getFullYear()
        const currentMonth = currentDate.getMonth()
        const birthMonth = date.getMonth()
        if (currentMonth < birthMonth || (currentMonth === birthMonth && currentDate.getDate() < date.getDate())) {
          age--
        }
        return age
      }
      function renderDiv(node) {
        const div = document.createElement("div")
        Helper.style(div, {margin: "21px 34px", fontFamily: "sans-serif"})
        node.appendChild(div)
        return div
      }
      function renderTitleSpan(text, node) {
        const span = document.createElement("span")
        span.textContent = text
        span.style.fontSize = "21px"
        Helper.convert("text/dark-light", span)
        node.appendChild(span)
        return span
      }
      function renderHighlightedSpan(text, node) {
        const span = Helper.create("box")
        span.style.fontSize = "34px"
        span.style.margin = "0 8px"
        span.textContent = text
        Helper.convert("text/dark-light", span)
        node.appendChild(span)
        return span
      }
      function renderTitle(title, node) {
        const titleNode = Helper.create("box", node)
        titleNode.textContent = `${title}:`
        const tag = title.toLowerCase().replaceAll(" ", "-").replaceAll("ü", "ue").replaceAll("ö", "oe").replaceAll("ä", "ae").replaceAll("1.", "ersten").replaceAll("2.", "zweiten").replaceAll("3.", "dritten").replaceAll("4.", "vierten")
        titleNode.setAttribute("onclick", `window.open("https://www.get-your.de/entwicklung/numerologie/${tag}/", "_blank")`)
        return titleNode
      }
      function dateToIsoSplit(date) {
        const isoDate = date.toISOString()
        return isoDate.split("T")[0]
      }
      function renderLifePathCalculation(date) {
        date = dateToIsoSplit(date)
        const digits = [...date.toString()].map(digit => parseInt(digit))
        let text
        for (let i = 0; i < digits.length; i++) {
          const digit = digits[i]
          if (Helper.verifyIs("number/empty", digit)) continue
          if (text === undefined) {
            text = digit
          } else {
            text = text + " + " + digit
          }
        }
        return text
      }
      function dateToMaster(date) {
        date = dateToIsoSplit(date)
        const digits = [...date.toString()].map(digit => parseInt(digit, 10)).filter(Number.isFinite)
        let sum = digits.reduce((acc, digit) => acc + digit, 0)
        let prevSum = sum
        const seenSums = new Set()
        while (![11, 22, 33].includes(sum) && ![0, 1, 4, 6, 7, 9].includes(sum) && !seenSums.has(sum)) {
          seenSums.add(sum)
          prevSum = sum
          sum = [...sum.toString()].map(digit => parseInt(digit, 10)).reduce((acc, digit) => acc + digit, 0)
          if (![11, 22, 33].includes(sum) && ![0, 1, 4, 6, 7, 9].includes(sum)) {
            break
          }
        }
        return ![11, 22, 33].includes(sum) ? prevSum : sum
      }
      function renderEqualsSign(node) {
        const equalsSign = renderTitleSpan("=", node)
        equalsSign.style.margin = "0 5px"
        return equalsSign
      }
      it.dateToLifePath = date => {

        date = dateToIsoSplit(date)
        const digits = [...date.toString()].map(digit => parseInt(digit))
        let sum = 0
        for (let i = 0; i < digits.length; i++) {
          const digit = digits[i]
          if (Helper.verifyIs("number/empty", digit)) continue
          sum += digit
        }
        while (sum > 9) {
          sum = [...sum.toString()].reduce((acc, digit) => acc + parseInt(digit), 0)
        }
        return sum
      }
      function openLifePath(lifePath) {
        const url = `/entwicklung/numerologie/geburtsenergie-${numbersAsText[lifePath - 1]}/`
        window.open(url, "_blank")
      }
      function getDigits(number) {
        const numberString = Math.abs(number).toString()
        return Array.from(numberString, Number)
      }
      function sumDigits(number) {
        const digits = getDigits(number)
        const sum = digits.reduce((accumulator, currentValue) => accumulator + currentValue, 0)
        return sum
      }
      function reduceToSingleDigit(number) {
        let result = number
        while (result >= 10) {
          result = sumDigits(result)
        }
        return result
      }
      function createPrevailingEnergies(data, node) {
        const fragment = document.createDocumentFragment()
        const keys = Object.keys(data)
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i]
          if (key === "0") continue
          if (data[key] >= 2) {
            const div = Helper.create("box")
            div.style.display = "inline-block"
            div.setAttribute("onclick", `window.open("https://www.get-your.de/entwicklung/numerologie/vorherrschende-energie-${numbersAsText[key - 1]}/", "_blank")`)
            fragment.appendChild(div)
            const span1 = document.createElement("span")
            span1.textContent = `${data[key]}x`
            span1.style.fontSize = "21px"
            div.appendChild(span1)
            const span2 = document.createElement("span")
            span2.textContent = `${key},`
            span2.style.fontSize = "34px"
            div.appendChild(span2)
          }
        }
        node.appendChild(fragment)
        return node
      }
      function countOccurrences(array) {
        const occurrences = {}
        array.forEach(number => {
          occurrences[number] = (occurrences[number] || 0) + 1
        })
        return occurrences
      }
      function splitYear(year) {
        const yearString = year.toString()
        const firstPart = yearString.substring(0, 2)
        const secondPart = yearString.substring(2)
        return [firstPart, secondPart]
      }
      function fillDateNumbers(date) {
        const isoDateSplit = dateToIsoSplit(date)
        const dateNumbers = isoDateSplit.match(/\d/g).map(Number)
        const lifePathNumber = it.dateToLifePath(date)
        dateNumbers.push(lifePathNumber)
        const day = date.getDate()
        const sumDay = reduceToSingleDigit(day)
        dateNumbers.push(sumDay)
        const month = date.getMonth() + 1
        const sumMonth = reduceToSingleDigit(month)
        dateNumbers.push(sumMonth)
        const year = date.getFullYear()
        const [yearFirstPart, yearSecondPart] = splitYear(year)
        const sumYearFirstPart = reduceToSingleDigit(Number(yearFirstPart))
        const sumYearSecondPart = reduceToSingleDigit(Number(yearSecondPart))
        dateNumbers.push(sumYearFirstPart)
        dateNumbers.push(sumYearSecondPart)
        const sumDayAndMonth = reduceToSingleDigit(sumDay + sumMonth)
        dateNumbers.push(sumDayAndMonth)
        const sumYear = reduceToSingleDigit(sumYearFirstPart + sumYearSecondPart)
        dateNumbers.push(sumYear)
        return dateNumbers
      }
      function createRecedingEnergy(array, node) {
        const fragment = document.createDocumentFragment()
        for (let i = 0; i < array.length; i++) {
          const number = array[i]
          const div = Helper.create("box")
          div.textContent = `${number}${i === array.length - 1 ? "" : ","}`
          div.style.fontSize = "34px"
          Helper.convert("text/dark-light", div)
          Helper.add("outline-hover", div)
          div.setAttribute("onclick", `window.open("https://www.get-your.de/entwicklung/numerologie/zuruecktretende-energie-${numbersAsText[number - 1]}/")`)
          fragment.appendChild(div)
        }
        node.appendChild(fragment)
        return node
      }
      function openTones(tone, occurency) {
        const url = `/entwicklung/numerologie/tonarten-${occurencies[occurency - 1]}-${numbersAsText[tone - 1]}/`
        window.open(url, "_blank")
      }
      function createTones(array, node) {
        const data = countOccurrences(array)
        const fragment = document.createDocumentFragment()
        const keys = Object.keys(data)
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i]
          if (key === "0") continue
          if (data[key] >= 1) {
            const div = Helper.create("box")
            div.style.display = "inline-block"
            div.setAttribute("onclick", `window.open("https://www.get-your.de/entwicklung/numerologie/tonarten-${occurencies[data[key] - 1]}-${numbersAsText[key - 1]}/")`)
            fragment.appendChild(div)
            const span1 = document.createElement("span")
            span1.textContent = `${data[key]}x`
            span1.style.fontSize = "21px"
            div.appendChild(span1)
            const span2 = document.createElement("span")
            span2.textContent = `${key},`
            span2.style.fontSize = "34px"
            div.appendChild(span2)
          }
        }
        node.appendChild(fragment)
        return node
      }
      function renderBirthNameEnergy(array, node) {
        const fragment = document.createDocumentFragment()
        for (let i = 0; i < array.length; i++) {
          const number = array[i]
          const div = Helper.create("box")
          div.textContent = `${number}${i === array.length - 1 ? "" : ","}`
          div.style.fontSize = "34px"
          div.setAttribute("onclick", `window.open("https://www.get-your.de/entwicklung/numerologie/geburtsname-${numbersAsText[number - 1]}/", "_blank")`)
          fragment.appendChild(div)
        }
        node.appendChild(fragment)
        return node
      }
      function reduceStringToSingleDigit(str) {
        let sum = 0
        for (let i = 0; i < str.length; i++) {
          const char = str[i].toLowerCase()
          if (alphabetMap.hasOwnProperty(char)) {
            sum += alphabetMap[char]
          }
        }
        while (sum >= 10) {
          const digits = String(sum).split("").map(Number)
          sum = digits.reduce((acc, val) => acc + val, 0)
        }
        return sum
      }
      function reduceVowelsToSingleDigit(str) {
        let sum = 0
        for (let i = 0; i < str.length; i++) {
          if (vowels.includes(str[i].toLowerCase())) {
            sum += alphabetMap[str[i].toLowerCase()] || 0
          }
        }
        while (sum >= 10) {
          const digits = String(sum).split("").map(Number)
          sum = digits.reduce((acc, val) => acc + val, 0)
        }
        return sum
      }
      function reduceConsonantsToSingleDigit(str) {
        let sum = 0
        for (let i = 0; i < str.length; i++) {
          if (consonants.includes(str[i].toLowerCase())) {
            sum += alphabetMap[str[i].toLowerCase()] || 0
          }
        }
        while (sum >= 10) {
          const digits = String(sum).split("").map(Number)
          sum = digits.reduce((acc, val) => acc + val, 0)
        }
        return sum
      }
      function findDoubleLetters(str) {
        const result = []
        for (let i = 1; i < str.length; i++) {
          const currentChar = str[i].toLowerCase()
          const previousChar = str[i - 1].toLowerCase()
          if (currentChar === previousChar) {
            result.push(alphabetMap[currentChar])
          }
        }
        return result
      }
      function openDoubleLetters(energy) {
        const url = `/entwicklung/numerologie/doppelte-buchstaben-${numbersAsText[energy - 1]}/`
        window.open(url, "_blank")
      }
      function renderDoubleLettersValue(number, array) {
        const div = Helper.create("box")
        div.classList.add("double-letters-value")
        div.textContent = `${number}${i === array.length - 1 ? "" : ","}`
        div.style.display = "inline-block"
        div.style.margin = "0 5px"
        div.style.fontSize = "34px"
        Helper.convert("text/dark-light", div)
        Helper.add("outline-hover", div)
        div.setAttribute("onclick", `window.open("https://www.get-your.de/entwicklung/numerologie/doppelte-buchstaben-${numbersAsText[number - 1]}/", "_blank")`)
        return div
      }
      function countFourAndFive(str) {
        let count = 0
        for (let i = 0; i < str.length; i++) {
          const char = str[i].toLowerCase()
          const value = alphabetMap[char]
          if (value === 4 || value === 5) {
            count++
          }
        }
        return count
      }
      function countTwoThreeAndSix(str) {
        let count = 0
        for (let i = 0; i < str.length; i++) {
          const char = str[i].toLowerCase()
          const value = alphabetMap[char]
          if (value === 2 || value === 3 || value === 6) {
            count++
          }
        }
        return count
      }
      function countOneAndEight(str) {
        let count = 0
        for (let i = 0; i < str.length; i++) {
          const char = str[i].toLowerCase()
          const value = alphabetMap[char]
          if (value === 1 || value === 8) {
            count++
          }
        }
        return count
      }
      function countSevenAndNine(str) {
        let count = 0
        for (let i = 0; i < str.length; i++) {
          const char = str[i].toLowerCase()
          const value = alphabetMap[char]
          if (value === 7 || value === 9) {
            count++
          }
        }
        return count
      }
      it.openBirthDateOverlay = (date) => {

        this.overlay("pop", o1 => {
          it.renderBirthDate(date, o1.content)
        })
      }
      it.openBirthNameOverlay = (name) => {

        this.overlay("pop", o1 => {
          it.renderBirthName(name, o1.content)
        })
      }
      it.renderAge = (date, node) => {
        const age = calculateAge(date)
        const ageDiv = renderDiv(node)
        renderTitleSpan("Alter:", ageDiv)
        renderHighlightedSpan(age, ageDiv)
      }
      it.renderBirthDate = (date, node) => {

        if (date && node){
          it.renderAge(date, node)
          it.renderLifePath(date, node)
          it.renderMaster(date, node)
          it.renderBirthDayEnergy(date, node)
          it.renderPrevailingEnergies(date, node)
          it.renderRecedingEnergies(date, node)
          it.renderTones(date, node)
          it.renderFirstCycle(date, node)
          it.renderFirstKeyTone(date, node)
          it.renderSecondCycle(date, node)
          it.renderSecondKeyTone(date, node)
          it.renderThirdCycle(date, node)
          it.renderThirdKeyTone(date, node)
          it.renderFourthCycle(date, node)
          it.renderFourthKeyTone(date, node)
        }
      }
      it.renderBirthName = (name, node) => {

        if (name && node){
          it.renderBirthNameEnergies(name, node)
          it.renderDeterminationEnergy(name, node)
          it.renderHeartsDesire(name, node)
          it.renderPersona(name, node)
          it.renderDoubleLetterEnergies(name, node)
          it.renderPhysicalLevel(name, node)
          it.renderEmotionalLevel(name, node)
          it.renderMentalLevel(name, node)
          it.renderIntuitiveLevel(name, node)
        }
      }
      it.renderLifePath = (date, node) => {
        const lifePathDiv = renderDiv(node)
        renderTitle("Geburtsenergie", lifePathDiv)
        const lifePathCalc = renderTitleSpan(renderLifePathCalculation(date), lifePathDiv)
        lifePathCalc.style.margin = "0 5px"
        renderEqualsSign(lifePathDiv)
        const master = dateToMaster(date)
        const masterCalc = renderTitleSpan(master.toString().split('').join(' + '), lifePathDiv)
        masterCalc.style.margin = "0 5px"
        renderEqualsSign(lifePathDiv)
        const lifePathNumber = it.dateToLifePath(date)
        const lifePathResult = renderHighlightedSpan(lifePathNumber, lifePathDiv)
        Helper.add("outline-hover", lifePathResult)
        lifePathResult.setAttribute("onclick", `window.open("https://www.get-your.de/entwicklung/numerologie/geburtsenergie-${numbersAsText[lifePathResult.textContent - 1]}/", "_blank")`)
      }
      it.renderMaster = (date, node) => {
        const master = dateToMaster(date)
        if (master === 11 || master === 22 || master === 33) {
          const masterDiv = renderDiv(node)
          renderTitle("Masterenergie", masterDiv)
          const masterResult = renderHighlightedSpan(master, masterDiv)
          Helper.add("outline-hover", masterResult)
          if (master === 11) {
            masterResult.setAttribute("onclick", `window.open("https://www.get-your.de/entwicklung/numerologie/masterenergie-elf/", "_blank")`)
          }

          if (master === 22) {
            masterResult.setAttribute("onclick", `window.open("https://www.get-your.de/entwicklung/numerologie/masterenergie-zwei-und-zwanzig/", "_blank")`)
          }

          if (master === 33) {
            masterResult.setAttribute("onclick", `window.open("https://www.get-your.de/entwicklung/numerologie/masterenergie-drei-und-dreisig/", "_blank")`)
          }
        }
      }
      it.renderBirthDayEnergy = (date, node) => {
        const day = date.getDate()
        const birthdayEnergyNumber = reduceToSingleDigit(day)
        const birthdayEnergyDiv = renderDiv(node)
        renderTitle("Geburtstagsenergie", birthdayEnergyDiv)
        const birthdayEnergyResult = renderHighlightedSpan(birthdayEnergyNumber, birthdayEnergyDiv)
        Helper.add("outline-hover", birthdayEnergyResult)
        birthdayEnergyResult.setAttribute("onclick", `window.open("https://www.get-your.de/entwicklung/numerologie/geburtstagsenergie-${numbersAsText[birthdayEnergyNumber - 1]}/", "_blank")`)
      }
      it.renderPrevailingEnergies = (date, node) => {
        const pervailingEnergyDiv = renderDiv(node)
        renderTitle("Vorherrschende Energien", pervailingEnergyDiv)
        const dateNumbers = fillDateNumbers(date)
        createPrevailingEnergies(countOccurrences(dateNumbers), pervailingEnergyDiv)
      }
      it.renderRecedingEnergies = (date, node) => {
        const missingNumbers = []
        const dateNumbers = fillDateNumbers(date)
        for (let i = 1; i <= 9; i++) {
          if (!dateNumbers.includes(i)) {
            missingNumbers.push(i)
          }
        }
        if (missingNumbers.length > 0) {
          const recedingEnergyDiv = renderDiv(node)
          renderTitle("Zurücktretende Energien", recedingEnergyDiv)
          createRecedingEnergy(missingNumbers, recedingEnergyDiv)
        }
      }
      it.renderTones = (date, node) => {
        const tonesDiv = renderDiv(node)
        renderTitle("Tonarten", tonesDiv)
        const dateNumbers = fillDateNumbers(date)
        createTones(dateNumbers, tonesDiv)
      }
      it.renderFirstCycle = (date, node) => {
        const firstCycleDiv = renderDiv(node)
        renderTitle("Dauer des 1. Zyklus", firstCycleDiv)
        const lifePathNumber = it.dateToLifePath(date)
        const firstCycle = 36 - lifePathNumber
        const firstCycleResult = renderHighlightedSpan(`0 - ${firstCycle}`, firstCycleDiv)
        Helper.add("outline-hover", firstCycleResult)
        firstCycleResult.setAttribute("onclick", `window.open("https://www.get-your.de/entwicklung/numerologie/erster-zyklus/", "_blank")`)
      }
      it.renderFirstKeyTone = (date, node) => {
        const day = date.getDate()
        const sumDay = reduceToSingleDigit(day)
        const month = date.getMonth() + 1
        const sumMonth = reduceToSingleDigit(month)
        const sumDayAndMonth = reduceToSingleDigit(sumDay + sumMonth)
        const firstKeyTone = sumDayAndMonth
        const firstKeyToneDiv = renderDiv(node)
        renderTitle("Grundton zum 1. Zyklus", firstKeyToneDiv)
        const firstKeyToneResult = renderHighlightedSpan(firstKeyTone, firstKeyToneDiv)
        Helper.add("outline-hover", firstKeyToneResult)
        firstKeyToneResult.setAttribute("onclick", `window.open('https://www.get-your.de/entwicklung/numerologie/grundton-${numbersAsText[firstKeyTone - 1]}/', '_blank')`)
      }
      it.renderSecondCycle = (date, node) => {
        const lifePathNumber = it.dateToLifePath(date)
        const firstCycle = 36 - lifePathNumber
        const secondCycle = firstCycle + 1 + 9
        const secondCycleDiv = renderDiv(node)
        renderTitle("Dauer des 2. Zyklus", secondCycleDiv)
        const secondCycleResult = renderHighlightedSpan(`${firstCycle + 1} - ${secondCycle}`, secondCycleDiv)
        Helper.add("outline-hover", secondCycleResult)
        secondCycleResult.setAttribute("onclick", `window.open("https://www.get-your.de/entwicklung/numerologie/zweiter-zyklus/", "_blank")`)
      }
      it.renderSecondKeyTone = (date, node) => {
        const day = date.getDate()
        const sumDay = reduceToSingleDigit(day)
        const year = date.getFullYear()
        const [yearFirstPart, yearSecondPart] = splitYear(year)
        const sumYearFirstPart = reduceToSingleDigit(Number(yearFirstPart))
        const sumYearSecondPart = reduceToSingleDigit(Number(yearSecondPart))
        const sumYear = reduceToSingleDigit(sumYearFirstPart + sumYearSecondPart)
        const secondKeyTone = reduceToSingleDigit(sumDay + sumYear)
        const secondKeyToneDiv = renderDiv(node)
        renderTitle("Grundton zum 2. Zyklus", secondKeyToneDiv)
        const secondKeyToneResult = renderHighlightedSpan(secondKeyTone, secondKeyToneDiv)
        Helper.add("outline-hover", secondKeyToneResult)
        secondKeyToneResult.setAttribute("onclick", `window.open('https://www.get-your.de/entwicklung/numerologie/grundton-${numbersAsText[secondKeyTone - 1]}/', '_blank')`)
      }
      it.renderThirdCycle = (date, node) => {
        const lifePathNumber = it.dateToLifePath(date)
        const firstCycle = 36 - lifePathNumber
        const secondCycle = firstCycle + 1 + 9
        const thirdCycle = secondCycle + 1 + 9
        const thirdCycleDiv = renderDiv(node)
        renderTitle("Dauer des 3. Zyklus", thirdCycleDiv)
        const thirdCycleResult = renderHighlightedSpan(`${secondCycle + 1} - ${thirdCycle}`, thirdCycleDiv)
        Helper.add("outline-hover", thirdCycleResult)
        thirdCycleResult.setAttribute("onclick", `window.open("https://www.get-your.de/entwicklung/numerologie/dritter-zyklus/", "_blank")`)
      }
      it.renderThirdKeyTone = (date, node) => {

        const day = date.getDate()
        const sumDay = reduceToSingleDigit(day)
        const month = date.getMonth() + 1
        const sumMonth = reduceToSingleDigit(month)
        const sumDayAndMonth = reduceToSingleDigit(sumDay + sumMonth)
        const firstKeyTone = sumDayAndMonth
        const year = date.getFullYear()
        const [yearFirstPart, yearSecondPart] = splitYear(year)
        const sumYearFirstPart = reduceToSingleDigit(Number(yearFirstPart))
        const sumYearSecondPart = reduceToSingleDigit(Number(yearSecondPart))
        const sumYear = reduceToSingleDigit(sumYearFirstPart + sumYearSecondPart)
        const secondKeyTone = reduceToSingleDigit(sumDay + sumYear)
        const thirdKeyTone = reduceToSingleDigit(firstKeyTone + secondKeyTone)
        const thirdKeyToneDiv = renderDiv(node)
        renderTitle("Grundton zum 3. Zyklus", thirdKeyToneDiv)
        const thirdKeyToneResult = renderHighlightedSpan(thirdKeyTone, thirdKeyToneDiv)
        Helper.add("outline-hover", thirdKeyToneResult)
        thirdKeyToneResult.setAttribute("onclick", `window.open('https://www.get-your.de/entwicklung/numerologie/grundton-${numbersAsText[thirdKeyTone - 1]}/', '_blank')`)
      }
      it.renderFourthCycle = (date, node) => {
        const lifePathNumber = it.dateToLifePath(date)
        const firstCycle = 36 - lifePathNumber
        const secondCycle = firstCycle + 1 + 9
        const thirdCycle = secondCycle + 1 + 9
        const fourthCycle = thirdCycle + 1 + 9
        const fourthCycleDiv = renderDiv(node)
        renderTitle("Dauer des 4. Zyklus", fourthCycleDiv)
        const fourthCycleResult = renderHighlightedSpan(`${thirdCycle + 1} - ${fourthCycle}`, fourthCycleDiv)
        Helper.add("outline-hover", fourthCycleResult)
        fourthCycleResult.setAttribute("onclick", `window.open("https://www.get-your.de/entwicklung/numerologie/vierter-zyklus/", "_blank")`)
      }
      it.renderFourthKeyTone = (date, node) => {
        const month = date.getMonth() + 1
        const sumMonth = reduceToSingleDigit(month)
        const year = date.getFullYear()
        const [yearFirstPart, yearSecondPart] = splitYear(year)
        const sumYearFirstPart = reduceToSingleDigit(Number(yearFirstPart))
        const sumYearSecondPart = reduceToSingleDigit(Number(yearSecondPart))
        const sumYear = reduceToSingleDigit(sumYearFirstPart + sumYearSecondPart)
        const fourthKeyTone = reduceToSingleDigit(sumMonth + sumYear)
        const fourthKeyToneDiv = renderDiv(node)
        renderTitle("Grundton zum 4. Zyklus", fourthKeyToneDiv)
        const fourthKeyToneResult = renderHighlightedSpan(fourthKeyTone, fourthKeyToneDiv)
        Helper.add("outline-hover", fourthKeyToneResult)
        fourthKeyToneResult.setAttribute("onclick", `window.open('https://www.get-your.de/entwicklung/numerologie/grundton-${numbersAsText[fourthKeyTone - 1]}/', '_blank')`)
      }
      function getBirthNameNumbers(string) {
        const splitAlias = string.split(" ")
        const birthNameSums = []
        for (let i = 0; i < splitAlias.length; i++) {
          const alias = splitAlias[i]
          let sum = 0
          for (let i = 0; i < alias.length; i++) {
            const char = alias[i]
            sum += alphabetMap[char.toLowerCase()] || 0
          }
          birthNameSums.push(sum)
        }
        return birthNameSums.map(it => reduceToSingleDigit(it))
      }
      it.renderBirthNameEnergies = (string, node) => {
        const birthNameNumbers = getBirthNameNumbers(string)
        const birthNameDiv = renderDiv(node)
        birthNameDiv.classList.add("birth-name")
        renderTitle("Geburtsname", birthNameDiv)
        renderBirthNameEnergy(birthNameNumbers, birthNameDiv)
      }
      it.renderDeterminationEnergy = (string, node) => {
        let determinationNumber = reduceStringToSingleDigit(string)
        if (determinationNumber === 0) determinationNumber = 9
        const determinationDiv = renderDiv(node)
        renderTitle("Bestimmung", determinationDiv)
        const determinationResult = renderHighlightedSpan(determinationNumber, determinationDiv)
        determinationResult.classList.add("determination")
        Helper.add("outline-hover", determinationResult)
        determinationResult.setAttribute("onclick", `window.open("https://www.get-your.de/entwicklung/numerologie/bestimmung-${numbersAsText[determinationNumber - 1]}/", "_blank")`)
      }
      it.renderHeartsDesire = (string, node) => {
        let heartsDesire = reduceVowelsToSingleDigit(string)
        if (heartsDesire === 0) heartsDesire = 9
        const heartsDesireDiv = renderDiv(node)
        renderTitle("Herzenswunsch", heartsDesireDiv)
        const heartsDesireResult = renderHighlightedSpan(heartsDesire, heartsDesireDiv)
        heartsDesireResult.classList.add("heart-desire")
        Helper.add("outline-hover", heartsDesireResult)
        heartsDesireResult.setAttribute("onclick", `window.open("https://www.get-your.de/entwicklung/numerologie/herzenswunsch-${numbersAsText[heartsDesire - 1]}/", "_blank")`)
      }
      it.renderPersona = (string, node) => {
        let persona = reduceConsonantsToSingleDigit(string)
        if (persona === 0) persona = 9
        const personaDiv = renderDiv(node)
        renderTitle("Persona", personaDiv)
        const personaResult = renderHighlightedSpan(persona, personaDiv)
        personaResult.classList.add("persona")
        Helper.add("outline-hover", personaResult)
        personaResult.setAttribute("onclick", `window.open("https://www.get-your.de/entwicklung/numerologie/persona-${numbersAsText[persona - 1]}/", "_blank")`)
      }
      it.renderDoubleLetterEnergies = (string, node) => {
        const doubleLetters = findDoubleLetters(string)
        const doubleLettersDiv = renderDiv(node)
        doubleLettersDiv.classList.add("double-letters")
        if (doubleLetters.length > 0) {
          doubleLettersDiv.style.display = "block"
          doubleLettersDiv.textContent = ""
          renderTitle("Doppelte Buchstaben", doubleLettersDiv)
          for (let i = 0; i < doubleLetters.length; i++) {
            const number = doubleLetters[i]
            const div = renderDoubleLettersValue(number, doubleLetters)
            doubleLettersDiv.appendChild(div)
          }
        } else {
          renderTitle("Doppelte Buchstaben", doubleLettersDiv)
          doubleLettersDiv.style.display = "none"
        }
      }
      it.renderPhysicalLevel = (string, node) => {
        let physicalLevel = countFourAndFive(string)
        if (physicalLevel === 0) physicalLevel = 9
        const physicalLevelDiv = renderDiv(node)
        renderTitle("Körperliche Ebene", physicalLevelDiv)
        const physicalLevelResult = renderHighlightedSpan(physicalLevel, physicalLevelDiv)
        physicalLevelResult.classList.add("physical-level")
        Helper.add("outline-hover", physicalLevelResult)
        physicalLevelResult.setAttribute("onclick", `window.open("https://www.get-your.de/entwicklung/numerologie/koerperliche-ebene-${numbersAsText[physicalLevel - 1]}/", "_blank")`)
      }
      it.renderEmotionalLevel = (string, node) => {
        let emotionalLevel = countTwoThreeAndSix(string)
        if (emotionalLevel === 0) emotionalLevel = 9
        const emotionalLevelDiv = renderDiv(node)
        renderTitle("Emotionale Ebene", emotionalLevelDiv)
        const emotionalLevelResult = renderHighlightedSpan(emotionalLevel, emotionalLevelDiv)
        emotionalLevelResult.classList.add("emotional-level")
        Helper.add("outline-hover", emotionalLevelResult)
        emotionalLevelResult.setAttribute("onclick", `window.open("https://www.get-your.de/entwicklung/numerologie/emotionale-ebene-${numbersAsText[emotionalLevel - 1]}/", "_blank")`)
      }
      it.renderMentalLevel = (string, node) => {
        let mentalLevel = countOneAndEight(string)
        if (mentalLevel === 0) mentalLevel = 9
        const mentalLevelDiv = renderDiv(node)
        renderTitle("Mentale Ebene", mentalLevelDiv)
        const mentalLevelResult = renderHighlightedSpan(mentalLevel, mentalLevelDiv)
        mentalLevelResult.classList.add("mental-level")
        Helper.add("outline-hover", mentalLevelResult)
        mentalLevelResult.setAttribute("onclick", `window.open("https://www.get-your.de/entwicklung/numerologie/mental-ebene-${numbersAsText[mentalLevel - 1]}/", "_blank")`)
      }
      it.renderIntuitiveLevel = (string, node) => {
        let intuitiveLevel = countSevenAndNine(string)
        if (intuitiveLevel === 0) intuitiveLevel = 9
        const intuitiveLevelDiv = renderDiv(node)
        renderTitle("Intuitive Ebene", intuitiveLevelDiv)
        const intuitiveLevelResult = renderHighlightedSpan(intuitiveLevel, intuitiveLevelDiv)
        intuitiveLevelResult.classList.add("intuitive-level")
        Helper.add("outline-hover", intuitiveLevelResult)
        intuitiveLevelResult.setAttribute("onclick", `window.open("https://www.get-your.de/entwicklung/numerologie/intuitive-ebene-${numbersAsText[intuitiveLevel - 1]}/", "_blank")`)
      }
      it.renderBirthNameFunctions = (birthname, node) => {
        it.renderBirthNameEnergies(birthname, node)
        it.renderDeterminationEnergy(birthname, node)
        it.renderHeartsDesire(birthname, node)
        it.renderPersona(birthname, node)
        it.renderDoubleLetterEnergies(birthname, node)
        it.renderPhysicalLevel(birthname, node)
        it.renderEmotionalLevel(birthname, node)
        it.renderMentalLevel(birthname, node)
        it.renderIntuitiveLevel(birthname, node)
      }
      it.updateBirthNameFunctions = (birthname) => {

        const birthNameNumbers = getBirthNameNumbers(birthname)
        const birthnameDiv = document.querySelector(".birth-name")
        birthnameDiv.textContent = ""
        renderTitle("Geburtsname", birthnameDiv)
        renderBirthNameEnergy(birthNameNumbers, birthnameDiv)

        let determinationNumber = reduceStringToSingleDigit(birthname)
        if (determinationNumber === 0) determinationNumber = 9
        document.querySelector(".determination").textContent = determinationNumber

        let heartsDesire = reduceVowelsToSingleDigit(birthname)
        if (heartsDesire === 0) heartsDesire = 9
        document.querySelector(".heart-desire").textContent = heartsDesire

        let persona = reduceConsonantsToSingleDigit(birthname)
        if (persona === 0) persona = 9
        document.querySelector(".persona").textContent = persona

        const doubleLettersDiv = document.querySelector(".double-letters")
        const doubleLettersValue = doubleLettersDiv.querySelector(".double-letters-value")
        const doubleLetters = findDoubleLetters(birthname)
        if (doubleLetters.length > 0) {
          doubleLettersDiv.style.display = "block"
          doubleLettersDiv.textContent = ""
          renderTitle("Doppelte Buchstaben", doubleLettersDiv)
          for (let i = 0; i < doubleLetters.length; i++) {
            const number = doubleLetters[i]
            const div = renderDoubleLettersValue(number, doubleLetters)
            doubleLettersDiv.appendChild(div)
          }
        } else {
          doubleLettersDiv.style.display = "none"
        }

        let intuitiveLevel = countSevenAndNine(birthname)
        if (intuitiveLevel === 0) intuitiveLevel = 9
        document.querySelector(".intuitive-level").textContent = intuitiveLevel

        let mentalLevel = countOneAndEight(birthname)
        if (mentalLevel === 0) mentalLevel = 9
        document.querySelector(".mental-level").textContent = mentalLevel

        let emotionalLevel = countTwoThreeAndSix(birthname)
        if (emotionalLevel === 0) emotionalLevel = 9
        document.querySelector(".emotional-level").textContent = emotionalLevel

        let physicalLevel = countFourAndFive(birthname)
        if (physicalLevel === 0) physicalLevel = 9
        document.querySelector(".physical-level").textContent = physicalLevel

      }
      return it
    }

    if (event === "openAudiosOverlay") {

      return (node) => {
        this.overlay("pop", async o1 => {
          o1.info.textContent = ".audios"
          const content = o1.content
          const searchField = this.create("input/text", content)
          searchField.input.placeholder = "Suche nach dem Titel"
          o1.renderTabs()
          o1.appendChild(o1.addButton)
          o1.addButton.onclick = ev => {

            this.overlay("pop", o2 => {
              o2.info.textContent = `.create.audio`
              o1.openMic(node, o2)
              o1.upload("audio/*", o2)
            })
          }
          o1.it = "audios"
          o1.filter = "title"
          o1.input = searchField.input
          o1.rerender = this.create("info/loading", content)
          o1.createItButton = async it => {

            const box = this.div("box sans-serif relative dark-light flex between align wrap m8")
            this.on("hover", {node: box, class: "pointer outline"})
            let title
            if (it.title) {
              const titleDiv = this.div("mb13", box)
              title = await this.convert("text/purified", it.title)
              if (it.query) {
                title = await Helper.convert("text/purified", it.query)
                titleDiv.innerHTML = title
              } else {
                titleDiv.textContent = title
              }
            }
            const audio = this.render("audio", it.url, box)
            this.render("text/hover-bottom-right", it.visibility, box)
            return box
          }
          o1.closedOptions = it => {
            this.overlay("pop", o2 => {
              if (it.title) o2.info.textContent = it.title
              o1.appendButton(it, node, o2)
              o1.removeIt(it, o2)
              o1.titleIt(it, o2)
              o1.visibility(it, o2)
            })
          }
          o1.openOptions = it => {
            this.overlay("pop", o2 => {
              if (it.title) o2.info.textContent = it.title
              o1.appendButton(it, node, o2)
            })
          }
        })
      }
    }

    if (event === "openFunnelOverlay") {

      function createDataButton() {
        const button = Helper.create("toolbox/left-right")
        button.className = "data-button"
        button.left.textContent = ".data"
        button.right.textContent = "Datenfelder definieren"
        return button
      }

      function createOptionField() {
        const text = Helper.create("input/text")
        text.className = "option-field"
        text.input.placeholder = "Option"
        text.input.setAttribute("required", "true")
        text.input.setAttribute("accept", "text/length")
        text.input.maxLength = "34"
        Helper.add("style/not-valid", text.input)
        text.input.addEventListener("input", ev => Helper.verify("input/value", text.input))
        return text
      }

      function onDataButtonClick(dataButton, idField, overlay, data) {
        openDataOverlay(idField.input.value, data)
        Helper.remove("style/circle", dataButton.left)
        Helper.convert("button/left-right", dataButton)
      }

      function openDataOverlay(id, data) {

        if (Helper.verifyIs("text/empty", id)) {
          window.alert("Es wurde keine Id eingegeben.")
          return
        }
        let it = {}
        Helper.overlay("pop", overlay => {
          overlay.info.textContent = `${id}.data`
          const funnel = Helper.create("div", overlay.content)
          const idField = Helper.create("input/id", funnel)
          const typeField = Helper.create("input/select", funnel)
          typeField.input.add(["-- Datentyp auswählen", "checkbox", "date", "email", "file", "number", "object", "password", "range", "select", "tel", "text", "textarea"])
          Helper.add("style/not-valid", typeField.input)
          let dataButton = overlay.querySelector(".data-button")
          let optionField
          typeField.input.addEventListener("input", async ev => {
            const value = ev.target.value
            if (value.startsWith("--")) {
              Helper.add("style/not-valid", typeField.input)
              dataButton.remove()
              dataButton = undefined
              return
            }
            if (Helper.verifyIs("text/empty", idField.input.value)) {
              window.alert("Es wurde keine Id eingegeben.")
              typeField.input.value = "-- Datentyp auswählen"
              Helper.add("style/not-valid", idField.input)
              idField.input.focus()
              Helper.add("style/not-valid", typeField.input)
              return
            }
            if (value === "object") {
              if (!dataButton) {
                dataButton = createDataButton()
                dataButton.addEventListener("click", ev => {
                  onDataButtonClick(dataButton, idField, overlay, data => {
                    it[idField.input.value] = data
                    renderPreview(it)
                  })
                })
                typeField.insertAdjacentElement('afterend', dataButton)
              }
            }
            else {
              if (dataButton) {
                dataButton.remove()
                dataButton = undefined
              }
            }
            if (value === "select") {
              if (!optionField) {
                optionField = createOptionField()
                typeField.insertAdjacentElement('afterend', optionField)
                optionField.input.focus()
                Helper.on("enter", optionField.input, ev => {
                  submitData(idField, typeField, it)
                })
              }
            } else {
              if (optionField) {
                optionField.remove()
                optionField = undefined
              }
            }
          })
          async function submitData(idField, typeField, it) {

            await Helper.verify("input/value", idField.input)
            await Helper.verify("input/value", typeField.input)
            const id = idField.input.value
            const type = typeField.input.value
            if (type.startsWith("--")) {
              window.alert("Es wurden kein Datentyp ausgewählt.")
              Helper.add("style/not-valid", typeField.input)
              return
            }
            if (type === "select") {
              const option = optionField.input.value
              if (!Helper.verifyIs("text/empty", option)) {
                options.push(option)
              } else {
                window.alert("Es wurde keine Option gefunden.")
                Helper.add("style/not-valid", optionField.input)
              }
              it[id] = options
              renderPreview(it)
              optionField.input.value = ""
              Helper.add("style/not-valid", optionField.input)
              optionField.input.focus()
              return
            }
            if (type === "object") {
              if (Helper.verifyIs("object/empty", object)) {
                window.alert("Es wurden keine Datenfelder gefunden.")
                Helper.add("style/red", dataButton)
                Helper.add("style/circle", dataButton.left)
                return
              }
              renderPreview(it)
              resetInput()
              return
            }
            it[id] = type
            function resetInput() {
              idField.input.value = ""
              idField.input.focus()
              typeField.input.value = "-- Datentyp auswählen"
              Helper.add("style/not-valid", idField.input)
              Helper.add("style/not-valid", typeField.input)
            }
            renderPreview(it)
            resetInput()
          }
          const options = []
          const object = {}
          const submit = Helper.create("toolbox/action", funnel)
          submit.textContent = "Datenfeld erstellen"
          submit.onclick = async () => {
            submitData(idField, typeField, it)
          }
          Helper.render("text/hr", "Meine Datenstruktur", overlay.content)
          const preview = Helper.create("box", overlay.content)
          Helper.style(preview, {fontSize: "21px", margin: "21px 34px", display: "block", fontFamily: "monospace", textAlign: "center", padding: "55px"})
          const text = Helper.render("text/hover-bottom-right", "Datenstruktur einsetzen", preview)
          renderPreview(it)
          function renderPreview(object) {
            const data = preview.querySelector(".data")
            if (data) data.remove()
            const fragment = document.createDocumentFragment()
            const div = document.createElement("div")
            div.className = "data"
            div.textContent = JSON.stringify(object, null, 2)
            fragment.appendChild(div)
            preview.appendChild(fragment)
          }
          preview.addEventListener("click", ev => {
            if (data) data(it)
            overlay.remove()
          })
        })
      }

      function updateData(node, key = "", data = {}, type) {

        const keyCheck = node.querySelector(".key")
        if (keyCheck) keyCheck.remove()
        const dataCheck = node.querySelector(".data")
        if (dataCheck) dataCheck.remove()
        const fragment = document.createDocumentFragment()
        const keySpan = document.createElement("span")
        keySpan.textContent = `${key}: `
        keySpan.className = "key"
        fragment.appendChild(keySpan)
        const dataSpan = document.createElement("span")
        dataSpan.textContent = JSON.stringify(data)
        if (type.startsWith("json-list:")) {
          dataSpan.textContent = `[${JSON.stringify(data)}]`
        }
        dataSpan.className = "data"
        fragment.appendChild(dataSpan)
        node.appendChild(fragment)
      }

      return (node, type) => {

        this.overlay("pop", async o1 => {
          o1.info.textContent = "user.funnel"
          const searchField = this.create("input/text", o1.content)
          searchField.input.placeholder = "Suche nach Id"
          if (node) {
            o1.content.appendChild(o1.addButton)
            o1.addButton.onclick = async () => {

              let blueprint = {}
              this.overlay("pop", o2 => {
                o2.info.textContent = `.register.funnel`
                const content = o2.content
                const idField = this.create("input/id", content)
                idField.input.addEventListener("input", ev => {
                  updateData(submit, ev.target.value, blueprint, typeField.input.value)
                })
                const typeField = this.create("input/select", content)
                this.add("style/not-valid", typeField.input)
                typeField.input.add(["-- Datentyp auswählen", "json: {key: value, .. }", "json-list: [{key: value}, .. ]"])
                let dataButton = o2.querySelector(".data-button")
                typeField.input.addEventListener("input", async ev => {
                  const value = ev.target.value
                  if (value.startsWith("--")) {
                    Helper.add("style/not-valid", typeField.input)
                    dataButton.remove()
                    dataButton = undefined
                    return
                  }
                  if (Helper.verifyIs("text/empty", idField.input.value)) {
                    window.alert("Es wurde keine Id eingegeben.")
                    typeField.input.value = "-- Datentyp auswählen"
                    Helper.add("style/not-valid", idField.input)
                    idField.input.focus()
                    Helper.add("style/not-valid", typeField.input)
                    return
                  }
                  if (!dataButton) {
                    dataButton = createDataButton()
                    dataButton.addEventListener("click", ev => {
                      onDataButtonClick(dataButton, idField, o2, data => {
                        blueprint = data
                        updateData(submit, idField.input.value, data, typeField.input.value)
                      })
                    })
                    typeField.insertAdjacentElement('afterend', dataButton)
                  }

                  updateData(submit, idField.input.value, blueprint, typeField.input.value)
                })
                this.render("text/hr", "Meine Datenstruktur", content)
                const submit = this.create("box", content)
                this.style(submit, {fontSize: "21px", margin: "21px 34px", display: "block", fontFamily: "monospace", textAlign: "center", padding: "55px"})
                const text = this.render("text/hover-bottom-right", "Funnel jetzt speichern", submit)
                updateData(submit, idField.input.value, blueprint, typeField.input.value)
                submit.onclick = async () => {
                  const type = typeField.input.value.split(":")[0]
                  if (type.startsWith("--")) {
                    window.alert("Es wurde kein Datentyp ausgewählt.")
                    this.add("style/not-valid", typeField.input)
                    return
                  }
                  await this.verify("input/value", idField.input)
                  const id = idField.input.value
                  if (this.verifyIs("object/empty", blueprint)) {
                    window.alert("Es wurden keine Datenfelder gefunden.")
                    this.add("style/red", dataButton)
                    this.add("style/circle", dataButton.left)
                    return
                  }
                  const res = await o1.registerIt({id, type, blueprint})
                  if (res.status === 200) {
                    o2.remove()
                  } else {
                    this.add("style/not-valid", idField.input)
                  }
                }
              })
            }
          }
          o1.createItButton = async it => {

            const button = Helper.create("toolbox/left-right")
            if (it.id && it.type) {
              if (it.query) {
                const id = await Helper.convert("text/purified", it.query)
                const type = await Helper.convert("text/purified", it.type)
                button.left.innerHTML = `#${id}:${type}`
              } else {
                button.left.textContent = `#${it.id}:${it.type}`
              }
            }
            if (it.blueprint) {
              const blueprint = document.createElement("pre")
              blueprint.style.fontSize = "21px"
              blueprint.style.whiteSpace = "pre-wrap"
              blueprint.style.wordWrap = "break-word"
              blueprint.textContent = JSON.stringify(it.blueprint, null, 2)
              button.right.style.margin = "8px"
              button.right.appendChild(blueprint)
            }
            if (it.visibility) {
              Helper.render("text/hover-bottom-right", it.visibility, button)
            }
            return button
          }
          function openButtons(it, o) {
            if (node) {
              const button = Helper.create("toolbox/left-right", o.content)
              button.left.textContent = ".append"
              button.right.textContent = "Funnel anhängen"
              button.onclick = async () => {

                Helper.overlay("pop", o2 => {
                  {
                    const button = Helper.create("toolbox/left-right", o2.content)
                    button.left.textContent = ".form"
                    button.right.textContent = "Als HTML Form anhängen"
                    button.addEventListener("click", async ev => {
                      const fragment = document.createDocumentFragment()
                      const form = Helper.convert("map/form", it.blueprint)
                      fragment.appendChild(form)
                      node.appendChild(fragment)
                      o1.remove()
                      o2.remove()
                      o.remove()
                    })
                  }
                })
              }
            }
            {
              const button = Helper.create("toolbox/left-right", o.content)
              button.left.textContent = ".copy"
              button.right.textContent = "Speicher deinen Funnel in deiner Zwischenablage"
              button.onclick = () => {
                navigator.clipboard.writeText(JSON.stringify(it.blueprint)).then(() => window.alert("Dein Funnel wurde erfolgreich in deiner Zwischablage gespeichert."))
              }
            }
            {
              const button = Helper.create("toolbox/left-right", o.content)
              button.left.textContent = ".email"
              button.right.textContent = "Versende deinen Funnel per E-Mail"
              button.onclick = async () => {
                const mailtoLink = `mailto:?body=${encodeURIComponent(JSON.stringify(it.blueprint))}`
                const a = document.createElement("a")
                a.href = mailtoLink
                a.click()
              }
            }
          }
          o1.closedOptions = it => {

            Helper.overlay("pop", async o2 => {
              const content = o2.content
              if (it.id) o2.info.textContent = `#${it.id}.options`
              openButtons(it, o2)

              if (type === "expert") {
                const button = Helper.create("toolbox/left-right", content)
                button.left.textContent = ".field-funnel-sign-support"
                button.right.textContent = "Unterstütze deine Nutzer bei der Eingabe mit Symbole und Farben"
                button.onclick = () => {
                  const script = Helper.create("script", {id: "field-funnel-sign-support", js: 'Helper.add("field-funnel-sign-support")'})
                  Helper.add("script-onbody", script)
                  window.alert("Skript wurde erfolgreich angehängt.")
                }
              }
              if (type === "expert") {
                const button = Helper.create("toolbox/left-right", content)
                button.left.textContent = ".next"
                button.right.textContent = "Nach Abschluss, zur Werteinheit"
                button.addEventListener("click", () => {
                  Helper.overlay("pop", o3 => {
                    const content = o3.content
                    Helper.render("next/path", node, content)
                  })
                })
              }
              if (type === "expert") {
                const button = Helper.create("toolbox/left-right", content)
                button.left.textContent = ".on-info-click"
                button.right.textContent = "Dieses Skript sucht und öffnet deine Tags im Field Funnel"
                button.onclick = () => {
                  const script = Helper.create("script", {id: "on-info-click", js: 'Helper.add("on-info-click")'})
                  Helper.add("script-onbody", script)
                  window.alert("Skript wurde erfolgreich angehängt.")
                }
              }
              if (type === "expert") {
                const button = Helper.create("toolbox/left-right", content)
                button.left.textContent = ".prefill-field-funnel"
                button.right.textContent = "Fülle die Datenfelder mit den eigenen Nutzerdaten"
                button.onclick = () => {
                  const script = Helper.create("script", {id: "prefill-field-funnel", js: `await Helper.add("prefill-field-funnel")`})
                  Helper.add("script-onbody", script)
                  window.alert("Skript wurde erfolgreich angehängt.")
                }
              }
              if (["closed", "expert"].includes(type)) {
                await o1.removeIt(it, o2)
              }
              if (type === "expert") {
                const button = Helper.create("toolbox/left-right", content)
                button.left.textContent = ".reset"
                button.right.textContent = "Klick Funnel zurücksetzen"
                button.addEventListener("click", () => {

                  for (let i = 0; i < node.children.length; i++) {
                    const element = node.children[i]
                    element.style.display = "none"
                    if (element.classList.contains("start-click-funnel-button")) {
                      element.style.display = "flex"
                    }
                  }
                  window.alert("Funnel erfolgreich zurückgesetzt.")
                })
              }
              if (type === "expert") {
                const button = Helper.create("toolbox/left-right", content)
                button.left.textContent = ".submit-field-funnel"
                button.right.textContent = "Field Funnel Submit Skript anhängen"
                button.onclick = () => {
                  const script = Helper.create("script", {id: "submit-field-funnel", js: 'Helper.add("submit-field-funnel")'})
                  Helper.add("script-onbody", script)
                  window.alert("Skript wurde erfolgreich angehängt.")
                }
              }
              if (["closed", "expert"].includes(type)) {

                o1.visibility(it, o2)
              }
            })
          }
          o1.openOptions = it => {

            Helper.overlay("pop", o1 => {
              if (it.id) o1.info.textContent = `#${it.id}.options`
              openButtons(it, o1)
            })
          }
          o1.renderTabs()
          o1.it = "funnel"
          o1.filter = "id"
          o1.input = searchField.input
          const content = this.create("info/loading", o1.content)
          o1.rerender = content

        })
      }
    }

    if (event === "openImagesOverlay") {

      return (node) => {
        this.overlay("pop", async o1 => {
          o1.info.textContent = ".images"
          const content = o1.content
          const searchField = this.create("input/text", content)
          searchField.input.placeholder = "Suche nach deinem Alias"
          o1.renderTabs()
          o1.appendChild(o1.addButton)
          o1.addButton.onclick = ev => {

            this.overlay("pop", o2 => {
              o2.info.textContent = `.create.image`
              o1.openCam(node, o2)
              o1.upload("image/*", o2)
            })
          }
          o1.it = "images"
          o1.filter = "alias"
          o1.input = searchField.input
          o1.rerender = this.create("info/loading", content)
          o1.rerenderStyle = it => {
            this.convert("parent/flex-around", it)
            it.style.margin = "21px 34px"
          }
          o1.createItButton = async it => {

            const box = this.div("box sans-serif relative dark-light w21")
            this.on("hover", {node: box, class: "pointer outline"})
            let alias
            if (it.alias) {
              alias = await this.convert("text/purified", it.alias)
              if (it.query) {
                alias = await Helper.convert("text/purified", it.query)
                box.innerHTML = alias
              } else {
                box.textContent = alias
              }
            }
            this.render("img", it.url, box)
            this.render("text/hover-bottom-right", it.visibility, box)
            return box
          }
          o1.closedOptions = it => {
            this.overlay("pop", o2 => {
              if (it.alias) o2.info.textContent = `.image.${it.alias}`
              o1.aliasIt(it, o2)
              o1.appendImage(it, node, o2)
              o1.removeIt(it, o2)
              o1.visibility(it, o2)
            })
          }
          o1.openOptions = it => {
            this.overlay("pop", o2 => {
              if (it.alias) o2.info.textContent = `.image.${it.alias}`
              o1.appendImage(it, node, o2)
            })
          }
        })
      }
    }

    if (event === "openLayerOverlay") {

      return (layer, node) => {
        this.overlay("popup", async layerOverlay => {
          this.render("text/title", "Wähle einen Layer aus", layerOverlay)
          const buttons = this.create("div/scrollable", layerOverlay)
          const fatherButton = this.create("button/left-right", buttons)
          fatherButton.classList.add("father-button")
          this.add("outline-hover", fatherButton)

          let selectedNode
          if (node.classList.contains("layer")) {
            selectedNode = node.parentElement
          } else {
            selectedNode = node
          }

          let fatherZIndex = 0
          if (selectedNode.style.zIndex) fatherZIndex = selectedNode.style.zIndex
          fatherButton.left.textContent = "Ebene " + fatherZIndex
          fatherButton.style.backgroundColor = this.colors.light.error
          fatherButton.right.textContent = this.convert("node/selector", selectedNode)
          fatherButton.onclick = async () => {
            await this.remove("element/selected-node", selectedNode.parentElement)
            this.add("element/selected-node", selectedNode)
            layerOverlay.remove()
          }

          for (let i = 0; i < selectedNode.querySelectorAll("*").length; i++) {
            const child = selectedNode.querySelectorAll("*")[i]
            if (child.classList.contains("layer")) {
              const button = this.create("button/left-right")
              button.left.textContent = "Ebene " + child.style.zIndex
              button.right.textContent = this.convert("node/selector", child)
              this.add("outline-hover", button)

              button.onclick = async () => {
                await layer(child)
                layerOverlay.remove()
              }
              if (child.style.zIndex >= fatherZIndex) {
                fatherButton.before(button)
              }
              if (child.style.zIndex < fatherZIndex) {
                buttons.append(button)
              }
            }
          }
        })
      }
    }

    if (event === "openMediaQueriesOverlay") {

      return () => {
        this.overlay("toolbox", queriesOverlay => {
          const content = this.create("div/scrollable", queriesOverlay)
          document.head.querySelectorAll("style").forEach((style, i) => {
            if (style.id === "large-device") this.render("text/hr", "Für Bildschirme breiter als 1025 Pixel", content)
            if (style.id === "middle-device") this.render("text/hr", "Für Bildschirme zwischen 601 und 1024 Pixel", content)
            if (style.id === "small-device") this.render("text/hr", "Für Bildschirme kleiner als 600 Pixel", content)
            if (style.id === "printer-device") this.render("text/hr", "Für Drucker", content)
            const queries = style.textContent.split("@")
            for (var i = 0; i < queries.length; i++) {
              const query = queries[i]
              if (query.trim() === "") continue
              const queryButton = this.create("toolbox/left-right", content)
              queryButton.left.textContent = this.convert("query/selector", query)
              queryButton.right.textContent = `Media Query ${i}`
              queryButton.onclick = () => {
                this.overlay("toolbox", queryOverlay => {
                  queryOverlay.info.textContent = currentSelector
                  const buttons = this.create("div/scrollable", queryOverlay)
                  const currentSelector = this.convert("query/selector", query)
                  const cssSplit = this.convert("query/css", query).split(" ")
                  const currentCss = cssSplit[0] + " " + cssSplit[1]
                  {
                    const button = this.create("toolbox/left-right", buttons)
                    this.add("outline-hover", button)
                    button.left.textContent = ".selector"
                    button.right.textContent = "Ziel Element ändern"
                    button.onclick = () => {
                      this.overlay("toolbox", selectorOverlay => {
                        selectorOverlay.info.textContent = `${currentSelector}.selector`
                        const funnel = this.create("div/scrollable", selectorOverlay)
                        const selectorField = this.create("field/textarea", funnel)
                        selectorField.label.textContent = "CSS Selektor"
                        selectorField.input.style.fontSize = "13px"
                        selectorField.input.value = currentSelector
                        this.verify("input/value", selectorField.input)
                        const submit = this.create("button/action", funnel)
                        submit.textContent = "Selektor jetzt speichern"
                        submit.onclick = () => {
                          try {
                            const newSelector = selectorField.input.value
                            style.textContent = style.textContent.replace(currentSelector, newSelector)
                            window.alert("Selektor erfolgreich gespeichert.")
                            queriesOverlay.remove()
                            queryOverlay.remove()
                            selectorOverlay.remove()
                          } catch (error) {
                            console.error(error)
                            window.alert("Fehler.. Bitte wiederholen.")
                          }
                        }
                      })
                    }
                  }
                  {
                    const button = this.create("toolbox/left-right", buttons)
                    button.left.textContent = ".css"
                    button.right.textContent = "Style anpassen"
                    button.onclick = () => {
                      this.overlay("toolbox", cssOverlay => {
                        cssOverlay.info.textContent = `${currentSelector}.css`
                        const funnel = this.create("div/scrollable", cssOverlay)
                        const cssField = this.create("field/textarea", funnel)
                        cssField.label.textContent = "CSS Regel"
                        cssField.input.style.fontSize = "13px"
                        cssField.input.value = currentCss
                        this.verify("input/value", cssField.input)
                        const submit = this.create("button/action", funnel)
                        submit.textContent = "CSS jetzt speichern"
                        submit.onclick = () => {
                          try {
                            const newCss = cssField.input.value
                            style.textContent = style.textContent.replace(currentCss, newCss)
                            window.alert("CSS erfolgreich gespeichert.")
                            queriesOverlay.remove()
                            queryOverlay.remove()
                            cssOverlay.remove()
                          } catch (error) {
                            console.error(error)
                            window.alert("Fehler.. Bitte wiederholen.")
                          }
                        }
                      })
                    }
                  }
                  {
                    const button = this.create("toolbox/left-right", buttons)
                    button.left.textContent = ".remove"
                    button.right.textContent = "Media Query entfernen"
                    button.onclick = () => {
                      try {
                        style.textContent = style.textContent.replace(`@${query}`, "")
                        queriesOverlay.remove()
                        queryOverlay.remove()
                        window.alert("Media Query erfolgreich entfernt.")
                      } catch (error) {
                        console.error(error)
                        window.alert("Fehler.. Bitte wiederholen.")
                      }
                    }
                  }
                })
              }
            }
          })
        })
      }
    }

    if (event === "openNodeLayerOverlay") {

      return async ({node}) => {
        const result = await this.verifyIs("class/found", {node: node, class: "layer" })
        if (result === true) {

          this.overlay("popup", async layerOverlay => {
            this.render("text/title", "Wähle einen Layer aus", layerOverlay)

            const layers = this.create("div/scrollable", layerOverlay)

            const fatherButton = this.create("button/left-right", layers)
            this.add("outline-hover", fatherButton)
            fatherButton.classList.add("father-button")

            let fatherZIndex = 0
            if (node.style.zIndex) fatherZIndex = node.style.zIndex
            fatherButton.left.textContent = "Ebene " + fatherZIndex

            fatherButton.style.backgroundColor = this.colors.light.error

            const fatherSelector = await this.convert("element/selector", node)
            fatherButton.right.textContent = fatherSelector

            fatherButton.onclick = async () => {
              await this.remove("element/selected-node", node.parentElement)
              this.add("element/selected-node", node)
              layerOverlay.remove()
            }

            node.querySelectorAll("*").forEach(async(item, i) => {
              if (item.classList.contains("layer")) {

                const selector = await this.convert("element/selector", item)

                const button = this.create("button/left-right")
                this.add("outline-hover", button)
                button.left.textContent = "Ebene " + item.style.zIndex
                button.right.textContent = selector
                button.onclick = async () => {
                  console.log(node);
                  console.log(item);
                  // onclick the cached selectedNode is not changing
                  await this.remove("element/selected-node", node.parentElement)
                  // node = item
                  this.add("selected/node", item)
                  this.convert("node/selected", node)
                  layerOverlay.remove()
                }

                if (item.style.zIndex >= fatherZIndex) {
                  fatherButton.before(button)
                }

                if (item.style.zIndex < fatherZIndex) {
                  layers.append(button)
                }

              }
            })

          })

        }
        if (result === false) {
          window.alert("In diesem Element sind keine Layer enthalten.")
        }

      }
    }

    if (event === "openPdfOverlay") {

      return (node) => {
        this.overlay("pop", async o1 => {
          o1.info.textContent = ".pdf"
          const content = o1.content
          const searchField = this.create("input/text", content)
          searchField.input.placeholder = "Suche nach deinem Alias"
          o1.renderTabs()
          o1.appendChild(o1.addButton)
          o1.it = "pdf"
          o1.filter = "alias"
          o1.input = searchField.input
          o1.rerender = this.create("info/loading", o1.content)
          o1.addButton.onclick = ev => {

            Helper.overlay("pop", async o2 => {
              o2.info.textContent = `.upload.pdf`
              const funnel = this.render("upload", "application/pdf", o2)
              funnel.submit.onclick = async () => {
                await Helper.verify("input/value", funnel.url.input)
                const res = await o1.registerIt({url: funnel.url.input.value})
                if (res.status === 200) o2.remove()
              }
            })
          }
          o1.closedOptions = it => {
            this.overlay("pop", o2 => {
              if (it.alias) o2.info.textContent = `.pdf#${it.alias}`
              o1.aliasIt(it, o2)
              o1.openWindow(it, o2)
              o1.removeIt(it, o2)
              o1.sharePdf(it, o2)
              o1.visibility(it, o2)
            })
          }
          o1.openOptions = it => {
            this.overlay("pop", o2 => {
              if (it.alias) o2.info.textContent = `.pdf#${it.alias}`
              o1.openWindow(it, o2)
              o1.sharePdf(it, o2)
            })
          }
          o1.createItButton = async it => {

            const button = this.div("box sans-serif relative dark-light")
            this.on("hover", {node: button, class: "pointer outline"})
            let alias
            if (it.alias) {
              alias = await this.convert("text/purified", it.alias)
              if (it.query) {
                alias = await Helper.convert("text/purified", it.query)
                button.innerHTML = alias
              } else {
                button.textContent = alias
              }
            }
            const pdf = await this.render("pdf", it.url, button)
            pdf.style.margin = "21px 0"
            this.render("text/hover-bottom-right", it.visibility, button)
            return button
          }
        })
      }
    }

    if (event === "open-profile") {

      const {it, node, overlay} = input
      if (it && it.id && node && overlay) {
        const split = window.location.pathname.split("/")
        const expert = split[1]
        const platform = split[2]
        const url = `/${expert}/${platform}/profil/${it.id}/`
        node.addEventListener("click", ev => {
          window.open(url, "_blank")
          overlay.remove()
        })
      }
    }

    if (event === "openScriptsOverlay") {

      return (selectedNode, type) => {
        this.overlay("pop", async o1 => {
          o1.info.textContent = `.scripts`
          o1.content.appendChild(o1.addButton)
          o1.addButton.onclick = () => {
            this.overlay("pop", o2 => {
              o2.info.textContent = ".script"
              const funnel = o2.content
              const idField = this.create("input/id", funnel)
              const scriptField = this.create("input/script", funnel)
              const submit = this.create("toolbox/action", funnel)
              submit.textContent = "Skript jetzt speichern"
              submit.onclick = async () => {
                await this.verify("funnel", funnel)
                const res = await o1.registerIt({id: idField.input.value, html: scriptField.input.value})
                if (res.status === 200) {
                  o2.remove()
                }
              }
            })
          }
          const searchField = this.create("input/text", o1.content)
          searchField.input.placeholder = "Suche nach Titel"
          o1.createItButton = async it => {
            const button = Helper.create("toolbox/left-right")
            button.left.style.flex = "1 1 0"
            Helper.render("text/node/bottom-right-onhover", it.visibility, button)
            this.render("text/pre", it.html, button.right)
            if (it.query) {
              const id = await Helper.convert("text/purified", it.query)
              button.left.innerHTML = `#${id}`
            } else {
              button.left.textContent = `#${it.id}`
            }
            return button
          }
          o1.closedOptions = it => {
            this.overlay("pop", async o2 => {
              o2.info.textContent = `#${it.id}.options`
              const content = o2.content
              openButtons(it, o2)
              await o1.removeIt(it, o2)
              {
                const button = this.create("toolbox/left-right", content)
                button.left.textContent = ".update"
                button.right.textContent = "Skript bearbeiten"
                button.onclick = () => {

                  this.overlay("pop", o3 => {
                    o3.info.textContent = `#${it.id}.update`
                    const funnel = o3.content
                    const nameField = this.create("input/id", funnel)
                    nameField.input.value = it.id
                    this.verify("input/value", nameField.input)
                    const scriptField = this.create("input/script", funnel)
                    scriptField.input.value = it.html
                    this.verify("input/value", scriptField.input)
                    const submit = this.create("toolbox/action", funnel)
                    submit.textContent = "Skript jetzt speichern"
                    submit.onclick = async () => {
                      await this.verify("funnel", funnel)
                      const res = await o1.updateIt(it, {html: scriptField.input.value, id: nameField.input.value})
                      if (res.status === 200) {
                        o3.remove()
                        o2.remove()
                      }
                    }
                  })
                }
              }

              o1.visibility(it, o2)
            })
          }
          function openButtons(it, o) {
            o1.appendScript(it, selectedNode, o)
            {
              const button = Helper.create("toolbox/left-right", o.content)
              button.left.textContent = ".execute"
              button.right.textContent = "Skript ausführen"
              button.addEventListener("click", async ev => {
                const script = await Helper.convert("text/script", it.html)
                Helper.convert("text/js", script.textContent)
              })
            }
          }
          o1.openOptions = it => {

            Helper.overlay("pop", o2 => {
              if (it.id) o2.info.textContent = `#${it.id}.options`
              openButtons(it, o2)
            })
          }
          o1.renderTabs()
          o1.it = "scripts"
          o1.filter = "id"
          o1.input = searchField.input
          const content = this.create("info/loading", o1.content)
          o1.rerender = content
        })
      }
    }

    if (event === "openSourcesOverlay") {

      return (selectedNode, type) => {
        this.overlay("pop", async o1 => {
          o1.info.textContent = "user.sources"
          o1.content.appendChild(o1.addButton)
          o1.addButton.onclick = () => {

            this.overlay("pop", async o2 => {
              o2.info.textContent = ".add.source"
              const searchField = this.create("input/text", o2.content)
              searchField.input.placeholder = "Suche nach dem Titel deiner Quelle"
              setTimeout(() => searchField.input.focus(), 34)
              this.verify("input/value", searchField.input)
              this.on("enter", searchField.input, ev => {

                this.overlay("pop", async o3 => {
                  o3.info.textContent = ".sources"
                  const h1 = this.render("text/h1", `Quellen werden gesucht..`, o3.content)
                  const filterTitleField = this.create("input/text", o3.content)
                  filterTitleField.input.placeholder = "Filter genauer nach Titel"
                  filterTitleField.style.margin = "0 34px"
                  this.verify("input/value", filterTitleField.input)
                  const buttons = this.create("info/loading", o3.content)
                  this.convert("text/sources", ev.target.value).then(async sources => {
                    if (sources.length === 0) {
                      window.alert("Es wurden keine Quellen gefunden.")
                      this.add("style/not-valid", searchField.input)
                      o3.remove()
                    } else if (sources.length === 1) {
                      h1.textContent = `Es wurde ${sources.length} Quelle gefunden`
                    } else {
                      h1.textContent = `Es wurden ${sources.length} Quellen gefunden`
                    }
                    async function renderButtons(array, node, query = "") {
                      const filtered = array?.filter(it => it["title"]?.toLowerCase().includes(query))
                      Helper.convert("parent/scrollable", node)
                      for (let i = 0; i < filtered.length; i++) {
                        const source = filtered[i]
                        if (!Helper.verifyIs("text/empty", query)) {
                          const regex = new RegExp(`(${query})`, "gi")
                          source.query = source.title.replace(regex, '<mark>$1</mark>')
                        }
                        const button = await o1.createItButton(source)
                        node.appendChild(button)
                        button.onclick = () => {
                          Helper.render("funnel/source", source, funnel)
                          Helper.verify("funnel", funnel)
                          o3.remove()
                        }
                      }
                    }
                    filterTitleField.input.oninput = async (ev) => {
                      await renderButtons(sources, buttons, ev.target.value)
                    }
                    await renderButtons(sources, buttons)
                  })
                })
              })
              this.render("text/hr", "Neue Quelle anlegen", o2.content)
              const funnel = this.create("funnel/source", o2.content)
              funnel.submit.onclick = async () => {
                await this.verify("funnel", funnel)
                const map = this.convert("funnel/map", funnel)
                const source = Helper.map("source", map.source)
                o1.registerIt(source)
                o1.tabs.meine.click()
                o2.remove()
              }
            })
          }
          if (type === "expert") {
            const button = Helper.create("toolbox/left-right", o1.content)
            button.left.textContent = ".cite-button"
            button.right.textContent = "Erlaube deinen Nutzern dieses Dokument zu zitieren"
            button.onclick = () => {

              function extractAuthors() {
                const authorsElement = document.querySelector('.authors')
                if (authorsElement) {
                  const authorsText = authorsElement.textContent.replace('Authoren: ', '').trim()
                  const authorsArray = authorsText.split(',').map(author => author.trim())
                  const formattedAuthors = authorsArray.join(', ')
                  return formattedAuthors
                } else {
                  window.alert('Kein Element mit der Klasse "authors" gefunden!')
                }
              }

              function extractTitle() {
                const titleElement = document.querySelector('title')
                if (titleElement) {
                  return titleElement.textContent
                } else {
                  window.alert('Es wurde kein <title> im Dokument gefunden!')
                }
              }

              function extractYear() {
                const createdElement = document.querySelector('.post-created')
                if (createdElement) {
                  const dateText = createdElement.textContent.replace('Erstellt am: ', '').trim()
                  return dateText.match(/\b\d{4}\b/)
                } else {
                  window.alert('Kein Element mit der Klasse "post-created" gefunden!')
                }
              }

              const authors = extractAuthors()
              const title = extractTitle()
              const year = extractYear()
              const requested = createRequested()
              const fullCite = `${authors}, "${title}", getyour-plattform, ${year}, https://www.get-your.de${window.location.pathname}${requested.textContent}`
              const script = Helper.create("script", {id: "cite-button", js: `Helper.add('cite-button', '${fullCite}')`})
              Helper.add("script-onbody", script)
              window.alert("Dein Zitier-Button wurde erfolgreich im <body> angehängt.")
              Helper.remove("overlays")
            }
          }
          function createRequested() {
            const span = document.createElement("span")
            span.textContent = `, Aufgerufen am: ${Helper.convert("millis/dd.mm.yyyy hh:mm", Date.now())}`
            return span
          }
          {
            const button = Helper.create("toolbox/left-right", o1.content)
            button.left.textContent = ".requested"
            button.right.textContent = "Aktuell abgerufen Markierung anhängen"
            button.onclick = () => {
              const span = createRequested()
              selectedNode?.appendChild(span)
              o1.remove()
            }
          }
          const timestampButton = this.create("toolbox/left-right", o1.content)
          timestampButton.left.textContent = ".timestamp"
          timestampButton.right.textContent = "Füge einen Zeitstempel ein"
          timestampButton.onclick = () => {
            const p = document.createElement("p")
            p.className = "post-created"
            p.style.fontSize = "13px"
            p.textContent = `Erstellt am: ${Helper.convert("millis/dd.mm.yyyy hh:mm", Date.now())}`
            selectedNode.appendChild(p)
            o1.remove()
          }
          const searchField = this.create("input/text", o1.content)
          searchField.input.placeholder = "Suche nach Titel"
          o1.createItButton = async it => {

            const button = Helper.create("toolbox/left-right")
            Helper.render("text/node/bottom-right-onhover", it.visibility, button)
            const title = Helper.create("div", button.left)
            title.style.fontSize = "34px"
            if (it.query) {
              title.innerHTML = await Helper.convert("text/purified", it.query)
            } else {
              title.textContent = it.title
            }

            if (it.authors) {
              const authors = Helper.create("div", button.left)
              authors.style.fontSize = "21px"
              authors.style.fontWeight = "bold"
              authors.style.color = Helper.colors.matte.sunflower
              authors.textContent = it.authors.join(", ")
            }

            if (it.publisher) {
              const publisher = Helper.create("div", button.left)
              publisher.style.fontSize = "13px"
              publisher.textContent = it.publisher.join(", ")
            }

            if (it.isbn) {
              const isbn = Helper.create("div", button.left)
              isbn.style.fontSize = "13px"
              isbn.textContent = `ISBN: ${it.isbn.join(", ")}`
            }

            if (it.published) {
              const published = Helper.create("div", button.left)
              published.style.fontSize = "34px"
              published.textContent = this.convert("millis/yyyy", Number(it.published))
            }

            if (it.image) {
              const img = document.createElement("img")
              img.style.width = "100%"
              img.src = it.image
              button.right.append(img)
              button.right.style.width = "128px"
            }

            return button
          }
          o1.closedOptions = it => {

            const source = it
            Helper.overlay("pop", async o2 => {
              o2.info.textContent = source.title
              Helper.convert("node-text/slice-width", {node: o2.info, text: source.title, width: 89})
              const buttons = o2.content
              openButtons(source, o2)
              await o1.removeIt(it, o2)
              const updateButton = this.create("toolbox/left-right", buttons)
              updateButton.left.textContent = ".update"
              updateButton.right.textContent = "Quelle aktualisieren"
              updateButton.onclick = () => {
                this.overlay("pop", o3 => {
                  o3.info.textContent = source.title
                  const funnel = this.create("funnel/source", o3.content)
                  this.render("funnel/source", source, funnel)
                  this.verify("funnel", funnel)
                  funnel.submit.onclick = async () => {
                    await Helper.verify("funnel", funnel)
                    const map = await Helper.convert("funnel/map", funnel)
                    const source = Helper.map("source", map.source)
                    const res = await o1.updateIt(it, source)
                    if (res.status === 200) {
                      o2.remove()
                      o3.remove()
                    }
                  }
                })
              }

              o1.visibility(it, o2)
            })
          }
          o1.openOptions = it => {

            Helper.overlay("pop", o2 => {
              if (it.title) o2.info.textContent = `${it.title}.options`
              openButtons(it, o2)
            })
          }
          o1.renderTabs()
          o1.it = "sources"
          o1.filter = "title"
          o1.input = searchField.input
          const content = this.create("info/loading", o1.content)
          o1.rerender = content
          function openButtons(source, o) {

            const authorsButton = Helper.create("toolbox/left-right", o.content)
            authorsButton.left.textContent = ".authors"
            authorsButton.right.textContent = "Füge die Authoren ein"
            authorsButton.onclick = () => {
              const p = document.createElement("p")
              p.className = "authors"
              p.style.fontSize = "13px"
              p.textContent = `Authoren: ${source.authors.join(", ")}`
              selectedNode.appendChild(p)
              o.remove()
              o1.remove()
            }

            const fullButton = Helper.create("toolbox/left-right", o.content)
            fullButton.left.textContent = ".full-cite"
            fullButton.right.textContent = "Füge einen Block Verweis ein"
            fullButton.onclick = () => {

              const authors = []
              for (let i = 0; i < source.authors.length; i++) {
                const author = source.authors[i]
                const names = author.split(" ")
                const formattedName = names[names.length - 1] + " " + names.slice(0, names.length - 1).join(" ")
                authors.push(formattedName)
              }

              const authorStr = authors.join(", ")

              let publisherStr = source.publisher[0]
              if (source.publisher.length > 1) {
                publisherStr = `${source.publisher[0]} et al.`
              }
              const cite = document.createElement("p")
              cite.className = "full-cite"
              const title = source.title.slice(0, -7)
              cite.textContent = `${authorStr}, "${title}", ${publisherStr}, ${Helper.convert("millis/yyyy", Number(source.published))}`
              selectedNode?.appendChild(cite)
              o.remove()
              o1.remove()
            }

            const inlineButton = Helper.create("toolbox/left-right", o.content)
            inlineButton.left.textContent = ".inline-cite"
            inlineButton.right.textContent = "Füge einen Verweis im Text ein"
            inlineButton.onclick = () => {

              const cite = document.createElement("span")
              cite.setAttribute("inline-cite", "")
              cite.style.marginLeft = "5px"
              const year = Helper.convert("millis/yyyy", Number(source.published))
              if (source.authors.length === 0) {
                let title
                try {
                  title = source.title.split("(")[0].trim()
                } catch (error) {
                  title = source.title
                }
                cite.textContent = `(${title} ${year})`
              } else {
                if (source.authors.length === 1) {
                  const author = source.authors[0].split(" ").at(-1)
                  cite.textContent = `(${author} ${year})`
                }
                if (source.authors.length === 2) {
                  const first = source.authors[0].split(" ").at(-1)
                  const second = source.authors[1].split(" ").at(-1)
                  cite.textContent = `(${first} & ${second} ${year})`
                }
                if (source.authors.length > 2) {
                  const author = source.authors[0].split(" ").at(-1)
                  cite.textContent = `(${author} et al. ${year})`
                }
              }
              selectedNode.classList.add("inline-cite")
              const citationCounter = document.querySelectorAll(".inline-cite").length
              selectedNode.setAttribute("citation-counter", citationCounter)
              selectedNode?.appendChild(cite)
              o.remove()
              o1.remove()
            }
          }
        })
      }
    }

    if (event === "openTemplatesOverlay") {

      return (node) => {
        this.overlay("pop", async o1 => {
          const searchField = this.create("input/text", o1.content)
          searchField.input.placeholder = "Suche nach Text in deinem Template"
          if (node) {
            o1.appendChild(o1.addButton)
            o1.addButton.onclick = async () => {
              if (node.hasAttribute("contenteditable")) {
                node.removeAttribute("contenteditable")
              }
              if (node.hasAttribute("id")) {
                node.removeAttribute("id")
              }
              await this.remove("element/selected-node", node)
              const confirm = window.confirm("Möchtest du das ausgewählte Element als Template speichern?")
              if (confirm === true) {
                await o1.registerIt({html: node.outerHTML})
              }
            }
          }
          o1.createItButton = async it => {

            const button = this.create("toolbox/left-right")
            button.style.width = "610px"
            button.style.margin = "21px 34px"
            let html = await Helper.convert("text/purified", it.html)
            if (it.query) {
              html = await Helper.convert("text/purified", it.query)
              button.left.innerHTML = html
            } else {
              button.left.innerHTML = html
            }
            button.left.style.height = "34vh"
            button.left.style.overflow = "auto"
            button.right.style.fontSize = "21px"
            if (it.alias) button.right.textContent = it.alias
            const signCounter = document.createElement("div")
            signCounter.textContent = `Zeichen: ${button.left.textContent.length}`
            button.right.appendChild(signCounter)
            this.render("text/hover-bottom-right", it.visibility, button)
            return button
          }
          o1.renderTabs()
          o1.it = "templates"
          o1.filter = "html"
          o1.input = searchField.input
          o1.rerender = this.create("info/loading", o1.content)
          o1.rerenderStyle = it => this.convert("parent/flex-around", it)
          o1.openOptions = it => {

            this.overlay("pop", o2 => {
              if (it.alias) o2.info.textContent = `${it.alias}.options`
              o1.appendHtml(it, node, o2)
              o1.appendText(it, node, o2)
              o1.copyHtml(it, o2)
              o1.copyText(it, o2)
              o1.emailHtml(it, o2)
              o1.emailText(it, o2)
              o1.translateText(it, o2)
              o1.shebang(it, o2)
            })
          }
          o1.closedOptions = it => {

            this.overlay("pop", o2 => {
              o2.info.textContent = `.options`
              o1.aliasIt(it, o2)
              o1.appendHtml(it, node, o2)
              o1.appendText(it, node, o2)
              o1.copyHtml(it, o2)
              o1.copyText(it, o2)
              o1.emailHtml(it, o2)
              o1.emailText(it, o2)
              o1.removeIt(it, o2)
              o1.translateText(it, o2)
              o1.shebang(it, o2)
              o1.visibility(it, o2)
            })
          }
        })
      }
    }

    if (event === "openVideosOverlay") {

      return (node) => {
        this.overlay("pop", async o1 => {
          o1.info.textContent = ".videos"
          const content = o1.content
          const searchField = this.create("input/text", content)
          searchField.input.placeholder = "Suche nach dem Titel"
          o1.appendChild(o1.addButton)
          o1.addButton.onclick = ev => {

            this.overlay("pop", o2 => {
              o2.info.textContent = `.create.video`
              o1.openVid(node, o2)
              o1.upload("video/*", o2)
            })
          }
          o1.renderTabs()
          o1.it = "videos"
          o1.filter = "title"
          o1.input = searchField.input
          o1.rerender = this.create("info/loading", content)
          o1.createItButton = async it => {

            const button = this.create("toolbox/left-right")
            let title
            if (it.title) {
              const titleDiv = this.div("", button.left)
              title = await this.convert("text/purified", it.title)
              if (it.query) {
                title = await Helper.convert("text/purified", it.query)
                titleDiv.innerHTML = title
              } else {
                titleDiv.textContent = title
              }
            }
            this.render("video", it.url, button.right)
            this.style(button.right, {margin: "21px 34px", display: "flex"})
            this.render("text/hover-bottom-right", it.visibility, button)
            return button
          }
          o1.closedOptions = it => {
            this.overlay("pop", o2 => {
              if (it.title) o2.info.textContent = it.title
              o1.appendButton(it, node, o2)
              o1.openWindow(it, o2)
              o1.removeIt(it, o2)
              o1.titleIt(it, o2)
              o1.visibility(it, o2)
            })
          }
          o1.openOptions = it => {
            this.overlay("pop", o2 => {
              if (it.title) o2.info.textContent = it.title
              o1.appendButton(it, node, o2)
              o1.openWindow(it, o2)
            })
          }
        })
      }
    }

    if (event === "pointer") {

      return (node) => {
        this.add("pointer", node)
      }
    }

    if (event === "replaceInnerHtmlWithPrompt") {

      return async (node) => {
        const prompt = window.prompt("Ersetze den Inhalt deines Elements mit folgendem HTML: (z.B., Hallo HTML)")
        node.innerHTML = await Helper.convert("text/purified", prompt)
      }
    }

    if (event === "replaceTextContentWithPrompt") {

      return (node) => {
        const prompt = window.prompt("Ersetze den Inhalt deines Elements mit folgendem HTML: (z.B., Hallo HTML)")
        node.textContent = prompt
      }
    }

    if (event === "scaleWithPrompt") {

      return (node) => {
        const prompt = window.prompt("Gebe die Höhe deiner Skalierung ein: (z.B., 2)")
        if (!this.verifyIs("text/empty", prompt)) {
          node.style.transform = `scale(${prompt})`
        }
      }
    }

    if (event === "setAttributeWithPrompt") {

      return (node) => {
        const prompt = window.prompt("Markiere dein Element mit einem Attribut: (z.B., id=neue-id)")
        if (!this.verifyIs("text/empty", prompt)) {
          try {
            const promptSplit = prompt.split("=")
            if (promptSplit.length === 2) {
              node.setAttribute(promptSplit[0], promptSplit[1])
            }
          } catch (error) {
            window.alert("Du musst ein 'Gleichheitszeichen =' nutzen, um dein Attribut vom Wert zu trennen.")
          }
        }
      }
    }

    if (event === "setChildrenStyleWithPrompt") {

      return (key, node, message) => {
        const prompt = window.prompt(message)
        for (var i = 0; i < node.children.length; i++) {
          const child = node.children[i]
          child.style[key] = prompt
        }
      }

    }

    if (event === "setClassWithPrompt") {

      return (node) => {
        const prompt = window.prompt("Füge deinem Element einen Klassen Namen hinzu:")
        if (!this.verifyIs("text/empty", prompt)) {
          node.classList.add(prompt)
          window.alert("Klasse wurde erfolgreich angehängt.")
        }
      }
    }

    if (event === "setIdWithPrompt") {

      return (node) => {
        const prompt = window.prompt("Gebe deinem Element einen eindeutige Id: (z.B., mein-html)")
        if (!this.verifyIs("text/empty", prompt)) {
          const found = document.getElementById(prompt)
          if (found === null) {
            node.setAttribute("id", prompt)
            window.alert("Id wurde erfolgreich gesetzt.")
          } else {
            window.alert("Diese Id existiert bereits.")
          }
        }
      }
    }

    if (event === "setStyleWithPrompt") {

      return ({key, node, message}) => {
        const prompt = window.prompt(message)
        node.style[key] = prompt
      }

    }

    if (event === "styleBackgroundImage") {

      return (node) => {
        const url = window.prompt("Gebe die Quelle des Bildes ein: (text/url)")
        if (this.verifyIs("text/url", url)) {
          node.style.background = `url('${url}')`
        } else {
          window.alert("Keine gültige URL.")
        }
      }
    }

    if (event === "svg") {

      const it = {}

      it.icons = async (node, callback) => {
        Helper.create("info/loading", node)
        const fragment = document.createDocumentFragment()
        const res = await Helper.request("/get/svg/list-open/")
        if (res.status === 200) {
          const list = JSON.parse(res.response)
          for (let i = 0; i < list.length; i++) {
            const svgName = list[i]
            const button = Helper.create("toolbox/icon", fragment)
            const text = await Helper.convert("path/text", `/public/${svgName}`)
            const svgFragment = Helper.convert("text/fragment", text)
            Helper.convert("svg/dark-light", svgFragment.firstChild)
            svgFragment.firstChild.setAttribute("width", "100%")
            if (typeof callback === "function") callback(button, svgFragment.firstChild)
            button.appendChild(svgFragment.firstChild)
          }
          node.textContent = ""
          node?.appendChild(fragment)
          return fragment
        }
      }

      return it
    }

    if (event === "toggleAttribute") {

      let cache
      return (attribute, node) => {
        if (!node.hasAttribute(attribute)) {
          if (cache) {
            node.setAttribute(attribute, cache)
          } else {
            node.removeAttribute(attribute)
          }
        } else {
          cache = node.getAttribute(attribute)
          node.removeAttribute(attribute)
        }
      }

    }

    if (event === "toggleInnerHtml") {
      let cache
      return async (node) => {
        if (this.verifyIs("text/empty", node.innerHTML)) {
          if (cache) {
            node.innerHTML = await Helper.convert("text/purified", cache)
          } else {
            node.innerHTML = ""
          }
        } else {
          cache = node.innerHTML
          node.innerHTML = ""
        }
      }

    }

    if (event === "toggleTextContent") {

      let cache
      return (node) => {
        if (this.verifyIs("text/empty", node.textContent)) {
          if (cache) {
            node.textContent = cache
          } else {
            node.textContent = ""
          }
        } else {
          cache = node.textContent
          node.textContent = ""
        }
      }

    }

    if (event === "toggleNodeAndChildrenStyles") {

      let originalNodeStyle
      let originalChildrenStyles = []
      return ({nodeStyle, childrenStyle, node}) => {
        if (originalNodeStyle) {
          node.setAttribute("style", originalNodeStyle)
          originalNodeStyle = null
        } else {
          originalNodeStyle = node.getAttribute("style")
          for (const [key, value] of Object.entries(nodeStyle)) {
            node.style[key] = value
          }
        }
        for (let i = 0; i < node.children.length; i++) {
          const child = node.children[i]
          if (originalChildrenStyles[i]) {
            child.setAttribute("style", originalChildrenStyles[i])
            originalChildrenStyles[i] = null
          } else {
            originalChildrenStyles[i] = child.getAttribute("style")
            for (const [key, value] of Object.entries(childrenStyle)) {
              child.style[key] = value
            }
          }
        }
      }

    }

    if (event === "translateWithPrompt") {

      return (node) => {
        const prompt = window.prompt("Gebe den X und Y Wert ein und bewege dein Element in die gewünschte Richtung: (z.B., (21px, -34px))")
        if (!this.verifyIs("text/empty", prompt)) {
          node.style.transform = `translate(${prompt})`
        } else {
          node.style.transform = null
        }
      }
    }

    if (event === "translateXWithPrompt") {

      return (node) => {
        const prompt = window.prompt("Gebe den X-Wert ein und bewege dein Element in die gewünschte Richtung: (z.B., 34px)")
        if (!this.verifyIs("text/empty", prompt)) {
          node.style.transform = `translateX(${prompt})`
        } else {
          node.style.transform = null
        }
      }
    }

    if (event === "translateYWithPrompt") {

      return (node) => {
        const prompt = window.prompt("Gebe den Y-Wert ein und bewege dein Element in die gewünschte Richtung: (z.B., -34px)")
        if (!this.verifyIs("text/empty", prompt)) {
          node.style.transform = `translateY(${prompt})`
        } else {
          node.style.transform = null
        }
      }
    }

    if (event === "fixedGridPrompt") {

      let originalGridFixedStyle
      let originalGridFixedChildrenStyle = []
      return ({node}) => {
        if (originalGridFixedStyle) {
          node.setAttribute("style", originalGridFixedStyle)
          originalGridFixedStyle = null
          for (var i = 0; i < node.children.length; i++) {
            const child = node.children[i]
            const style = originalGridFixedChildrenStyle.shift()
            if (style) {
              child.setAttribute("style", style)
            } else {
              child.removeAttribute("style")
            }
          }
        } else {
          const prompt = window.prompt("Gebe die exakte Dimension deiner Grid Elemente ein: (z.B., 144px)")
          originalGridFixedStyle = node.getAttribute("style")
          node.style.display = "grid"
          node.style.gridTemplateColumns = `repeat(auto-fit, minmax(${prompt}, 1fr))`
          node.style.gridTemplateRows = `repeat(auto-fit, minmax(0, ${prompt}))`
          node.style.gridGap = "21px"
          for (var i = 0; i < node.children.length; i++) {
            const child = node.children[i]
            originalGridFixedChildrenStyle.push(child.getAttribute("style"))
            child.style.height = prompt
          }
        }
      }

    }

    if (event === "removeAllLayer") {

      return (node) => {
        node.querySelectorAll("*").forEach((item, i) => {
          if (item.classList.contains("layer")) {
            item.remove()
          }
        })
        window.alert("Alle Layer wurden erfolgreich entfernt.")
      }
    }

    if (event === "removeGridColumn") {

      return (node) => {
        const templateColumns = node.style.gridTemplateColumns.split(" ")
        templateColumns.pop()
        node.style.gridTemplateColumns = templateColumns.join(" ")
        if (node.lastElementChild) {
          node.lastElementChild.remove()
        }
      }
    }

    if (event === "removeGridRow") {

      return (node) => {
        const templateRows = node.style.gridTemplateRows.split(" ")
        templateRows.pop()
        node.style.gridTemplateRows = templateRows.join(" ")
        if (node.lastElementChild) {
          node.lastElementChild.remove()
        }
      }
    }

    if (event === "renderColors") {

      return (node, callback) => {
        for (const [key, value] of Object.entries(Helper.colors)) {
          if (typeof value === "string") {
            if (!Helper.verifyIs("text/empty", value)) {
              const button = Helper.create("button/key-value-color", {key, value})
              Helper.add("outline-hover", button)
              button.onclick = () => callback(value)
              node.appendChild(button)
            }
          }
          if (typeof value === "object") {
            Helper.render("text/hr", key, node)
            for (const [key, val] of Object.entries(value)) {
              if (typeof val === "string") {
                if (!Helper.verifyIs("text/empty", val)) {
                  const button = Helper.create("button/key-value-color", {key, value: val})
                  Helper.add("outline-hover", button)
                  button.onclick = () => callback(val)
                  node.appendChild(button)
                }
              }
            }
          }
        }
      }
    }

    if (event === "rotateNode") {

      let rotationDegree = 0
      return ({degree, node}) => {
        rotationDegree += degree
        if (rotationDegree === 360) rotationDegree = 0
        node.style.transform = `rotate(${rotationDegree}deg)`
      }

    }

    if (event === "rotateNodeLeftWithPrompt") {

      return (node) => {
        const prompt = window.prompt("Gebe den exakten Winkel für deine Rotation, nach links, ein: (z.B., 45)")
        if (this.verifyIs("text/+int", prompt)) {
          let degree = parseInt(prompt)
          if (degree >= 0) {
            if (degree === 360) degree = 0
            if (degree > 360) degree = degree - 360
            node.style.transform = `rotate(-${degree}deg)`
          }
        } else {
          node.style.transform = null
        }
      }
    }

    if (event === "rotateNodeRightWithPrompt") {

      return (node) => {
        const prompt = window.prompt("Gebe den exakten Winkel für deine Rotation, nach rechts, ein: (z.B., 45)")
        if (this.verifyIs("text/+int", prompt)) {
          let degree = parseInt(prompt)
          if (degree >= 0) {
            if (degree === 360) degree = 0
            if (degree > 360) degree = degree - 360
            node.style.transform = `rotate(${degree}deg)`
          }
        } else {
          node.style.transform = null
        }
      }
    }

    if (event === "toggleNode") {

      let originalRemoveNode
      let originalParentNode
      let originalIndex
      return (node) => {
        if (originalRemoveNode) {
          if (originalParentNode) {
            originalParentNode.insertBefore(originalRemoveNode, originalParentNode.childNodes[originalIndex])
          }
          node = originalRemoveNode
          originalRemoveNode = null
          originalParentNode = null
          originalIndex = null
        } else {
          originalParentNode = node.parentElement
          originalIndex = Array.from(originalParentNode.childNodes).indexOf(node)
          originalRemoveNode = node.cloneNode(true)
          node.remove()
        }
      }

    }

    if (event === "toggleStyle") {

      let cache
      return ({key, value, node}) => {
        if (node.style[key] === value) {
          if (cache) {
            node.style[key] = cache
          } else {
            node.style[key] = null
          }
        } else {
          cache = node.style[key]
          node.style[key] = value
        }
      }

    }

    if (event === "toggleStyles") {

      let cache
      return ({styles, node}) => {
        if (cache) {
          node.setAttribute("style", cache)
          cache = undefined
        } else {
          cache = node.getAttribute("style");
          for (const [key, value] of Object.entries(styles)) {
            node.style[key] = value
          }
        }
      }

    }

    if (event === "trimLines") {

      return (node) => {
        const textContent = node.textContent
        node.textContent = textContent.split('\n').map(line => line.trim()).join('\n')
      }

    }

    if (event === "spanColumnWithPrompt") {

      return (node) => {
        const prompt = window.prompt("Gebe die Anzahl an Spalten ein, die dein Grid Element einnehmen soll: (z.B., 5)")
        if (this.verifyIs("text/+int", prompt)) {
          const columns = parseInt(prompt)
          if (columns > 0) {
            node.style.gridColumn = `span ${columns}`
          }
        }
      }
    }

    if (event === "spanRowWithPrompt") {

      return (node) => {
        const prompt = window.prompt("Gebe die Anzahl an Zeilen ein, die dein Grid Elemente einnehmen soll: (z.B., 3)")
        if (this.verifyIs("text/+int", prompt)) {
          const rows = parseInt(prompt)
          if (rows > 0) {
            node.style.gridRow = `span ${rows}`
            node.style.height = "100%"
          }
        }
      }
    }

    if (event === "wrapAnchorWithPrompt") {

      return async (node) => {
        const prompt = window.prompt("Gebe die Quell-Url deines Links ein:")
        if (!this.verifyIs("text/empty", prompt)) {
          const a = document.createElement("a")
          a.style.textDecoration = "none"
          a.href = prompt
          node.style.cursor = "pointer"
          a.innerHTML = await this.convert("text/purified", node.outerHTML)
          node.replaceWith(a)
          return a
        }
      }
    }

  }

  static get(event, parent, input) {
    // event = thing/from/algorithm

    // no parent needed to get data
    if (arguments.length === 2) {
      input = parent
    }


    if (event === "funnel/select-option") {

      const optionField = this.create("field/text", parent)
      optionField.label.textContent = "Antwortmöglichkeit"
      optionField.input.setAttribute("required", "true")
      this.verify("input/value", optionField.input)
      optionField.input.addEventListener("input", () => {

        const value = optionField.input.value

        if (input !== undefined) {
          if (input.tagName === "OPTION") {
            input.value = value
            input.text = value
          }
        }

      })

      if (input !== undefined) {
        if (input.tagName === "OPTION") {
          optionField.input.value = input.value
          this.verify("input/value", optionField.input)
          // optionField.value(() => input.value)
          // optionField.verifyValue()
        }
      }

      if (input !== undefined) {
        if (input.tagName !== "OPTION") {
          const submitButton = this.create("button/action", parent)
          submitButton.textContent = "Option jetzt anhängen"
          submitButton.addEventListener("click", async () => {

            await this.verify("input/value", optionField.input)

            const value = optionField.input.value

            const option = document.createElement("option")
            option.value = value
            option.text = value

            input.append(option)

            if (input.ok !== undefined) await input.ok()
          })


        }
      }



    }

    if (event === "field-funnel/fields") {

      if (input.classList.contains("field-funnel")) {


        parent.textContent = ""
        for (let i = 0; i < input.children.length; i++) {
          const field = input.children[i]

          if (field.classList.contains("submit-field-funnel-button")) continue

          if (field.classList.contains("field")) {
            const fieldInput = field.querySelector(".field-input")


            const button = this.create("button/left-right", parent)
            button.left.textContent = field.id

            button.right.append(this.convert("element/alias", fieldInput))
            button.addEventListener("click", () => {
              this.overlay("toolbox", overlay => {
                overlay.info.append(this.convert("element/alias", fieldInput))
                const content = this.create("div/scrollable", overlay)
                if (fieldInput.tagName === "SELECT") {
                  {
                    const button = this.create("button/left-right", content)
                    button.left.textContent = ".options"
                    button.right.textContent = "Antwortmöglichkeiten definieren"
                    button.addEventListener("click", () => {
                      this.overlay("toolbox", overlay => {
                        this.removeOverlayButton(overlay)

                        const info = this.create("header/info", overlay)
                        info.append(this.convert("element/alias", fieldInput))
                        info.append(this.convert("text/span", ".options"))

                        {
                          const button = this.create("button/left-right", overlay)
                          button.left.textContent = ".append"
                          button.right.textContent = "Neue Antwortmöglichkeit anhängen"
                          button.addEventListener("click", () => {

                            this.overlay("toolbox", overlay => {
                              this.removeOverlayButton(overlay)

                              const info = this.create("header/info", overlay)
                              info.append(this.convert("element/alias", fieldInput))
                              info.append(this.convert("text/span", ".option.append"))

                              const optionFunnel = this.create("div/scrollable", overlay)

                              const optionField = this.create("field/textarea", optionFunnel)
                              optionField.label.textContent = "Antwortmöglichkeit"
                              optionField.input.setAttribute("required", "true")
                              this.verify("input/value", optionField.input)
                              optionField.input.addEventListener("input", () => this.verify("input/value", optionField.input))

                              const submitButton = this.create("button/action", optionFunnel)
                              submitButton.textContent = "Option jetzt anhängen"
                              submitButton.addEventListener("click", async () => {

                                const value = optionField.input.value

                                const option = document.createElement("option")
                                option.value = value
                                option.text = value
                                fieldInput.appendChild(option)

                                this.render("select/options", fieldInput, options)

                                overlay.remove()

                              })



                            })
                          })
                        }

                        this.render("text/hr", "Optionen", overlay)

                        const options = this.create("div/scrollable", overlay)
                        this.render("select/options", fieldInput, options)

                      })
                    })
                  }

                }

                field.ok = () => {
                  this.get(event, parent, input)
                  overlay.remove()
                }

                this.get("funnel/field", content, field)






              })
            })
          }

        }





      }

    }

    if (event === "funnel/field") {

      const funnel = this.create("div/scrollable", parent)

      const idField = this.create("field/tag", funnel)
      idField.label.textContent = "Gebe deinem Datenfeld eine Id"
      this.verify("input/value", idField.input)
      idField.input.addEventListener("input", () => {

        this.verify("input/value", idField.input)

        const id = idField.input.value

        if (document.getElementById(id) !== null) {
          this.add("style/not-valid", idField.input)
        }

        if (input !== undefined) {
          if (input.classList.contains("field")) {
            if (document.getElementById(id) === null) {
              input.setAttribute("id", id)
            }
          }
        }

      })

      if (input !== undefined) {
        if (input.classList.contains("field")) {
          if (input.hasAttribute("id")) {
            idField.input.value = input.getAttribute("id")
            this.verify("input/value", idField.input)
          }
        }
      }


      const labelField = this.create("field/textarea", funnel)
      labelField.label.textContent = "Beschreibe das Datenfeld für dein Netzwerk"
      labelField.input.setAttribute("required", "true")
      this.verify("input/value", labelField.input)
      labelField.input.addEventListener("input", () => {

        const label = input.querySelector(".field-label")
        const value = labelField.input.value
        if (input !== undefined) {
          if (input.classList.contains("field")) {
            if (label !== null) {
              label.textContent = value
            }
          }
        }
        this.verify("input/value", labelField.input)

      })

      if (input !== undefined) {
        if (input.classList.contains("field")) {
          if (input.querySelector(".field-label") !== null) {
            labelField.input.value = input.querySelector(".field-label").textContent
            this.verify("input/value", labelField.input)
          }
        }
      }

      const infoField = this.create("field/textarea", funnel)
      infoField.label.textContent = "Hier kannst du, wenn du möchtest, mehr Informationen zu diesem Datenfeld, als HTML, für deine Nutzer, bereitstellen"
      infoField.input.style.height = "144px"
      infoField.input.placeholder = "<div>..</div>"
      infoField.input.style.fontFamily = "monospace"
      infoField.input.style.fontSize = "13px"
      this.verify("input/value", infoField.input)

      infoField.input.addEventListener("input", () => {
        const info = infoField.input.value

        const script = this.create("script", {id: "on-info-click", js: 'Helper.add("on-info-click")'})
        this.add("script-onbody", script)

        if (this.verifyIs("text/empty", info)) return input.removeAttribute("on-info-click")

        if (input !== undefined) {
          if (input.classList.contains("field")) {
            input.setAttribute("on-info-click", info)
          }
        }
        this.verify("input/value", infoField.input)

      })

      if (input !== undefined) {
        if (input.classList.contains("field")) {
          if (input.hasAttribute("on-info-click")) {
            infoField.input.value = input.getAttribute("on-info-click")
            this.verify("input/value", infoField.input)
          }
        }
      }

      const typeField = this.create("field/select", funnel)
      typeField.label.textContent = "Welchen Datentyp soll dein Netzwerk eingeben können"
      typeField.input.add(["text", "textarea", "email", "tel", "range", "password", "number", "file", "date", "checkbox", "select"])
      this.verify("input/value", typeField.input)
      typeField.input.addEventListener("input", () => {
        const value = typeField.input.value

        if (input !== undefined) {
          if (input.classList.contains("field")) {
            const fieldInput = input.querySelector(".field-input")

            if (fieldInput !== null) {

              this.update("field-input/type", fieldInput, value)

            }
          }
        }

        this.render("funnel/field-input", {type: value, field: input})

        if (input.classList.contains("field-funnel")) {
          this.render("field-funnel/fields", input)
        } else {
          this.render("field-funnel/fields", input.parentElement)
        }

      })

      if (input !== undefined) {

        if (input.classList.contains("field")) {
          const fieldInput = input.querySelector(".field-input")

          let type
          if (fieldInput.tagName === "INPUT") {
            type = fieldInput.getAttribute("type")
          }
          if (fieldInput.tagName === "SELECT") {
            type = "select"
          }
          if (fieldInput.tagName === "TEXTAREA") {
            type = "textarea"
          }

          if (fieldInput !== null) {
            typeField.input.add([type])

            const fieldInputFunnel = this.create("div", funnel)
            this.render("funnel/field-input", {type, field: input}, fieldInputFunnel)

          }
        }
      }

      if (input !== undefined) {
        if (input.classList.contains("field-funnel")) {

          const button = this.create("button/action", funnel)
          button.textContent = "Datenfeld jetzt anhängen"
          button.addEventListener("click", async () => {

            await this.verify("field-funnel", funnel)

            const id = idField.input.value
            const type = typeField.input.value
            const label = labelField.input.value
            const info = infoField.input.value

            if (document.getElementById(id) !== null) {
              window.alert("Id existiert bereits.")
              idField.scrollIntoView({behavior: "smooth"})
              this.add("style/not-valid", idField.input)
              throw new Error("id exist")
            }

            if (document.getElementById(id) === null) {

              const field = this.convert("text/field", type)
              field.id = id
              field.label.textContent = label

              if (!this.verifyIs("text/empty", info)) {
                field.setAttribute("on-info-click", info)
                const script = this.create("script", {id: "on-info-click", js: 'Helper.add("on-info-click")'})
                this.add("script-onbody", script)
              }

              input.querySelector(".submit-field-funnel-button").before(field)
              if (input.ok !== undefined) await input.ok()

            }

          })

        }
      }


      if (input !== undefined) {
        if (input.classList.contains("field")) {

          const button = this.create("button/action", funnel)
          button.style.backgroundColor = this.colors.dark.error
          button.style.color = this.colors.light.text
          button.textContent = "Datenfeld entfernen"
          button.addEventListener("click", async () => {

            input.remove()
            if (input.ok !== undefined) await input.ok()


          })

        }
      }

    }

    if (event === "role-apps/closed") {

      return new Promise(async (resolve, reject) => {

        const content = this.create("info/loading", parent)

        const res = await this.request("/verify/user/closed/")
        if (res.status === 200) {

          const res = await this.request("/get/platform/role-apps/", {id: input})
          if (res.status === 200) {
            const apps = JSON.parse(res.response)

            this.convert("parent/scrollable", content)

            for (let i = 0; i < apps.length; i++) {
              const app = apps[i]

              const button = this.create("button/left-right", content)
              button.left.textContent = `.${app}`

              if (app === "scripts") {
                button.right.textContent = "Meine HTML Skripte"


                button.addEventListener("click", () => {
                  this.overlay("toolbox", async overlay => {

                    this.removeOverlayButton(overlay)
                    const info = this.create("header/info", overlay)
                    info.textContent = `.scripts`

                    const create = this.create("button/left-right", overlay)
                    create.left.textContent = ".create"
                    create.right.textContent = "Neues Skript hochladen"
                    create.addEventListener("click", () => {

                      this.overlay("toolbox", overlay => {
                        this.removeOverlayButton(overlay)
                        const info = this.create("header/info", overlay)
                        info.append(this.convert("text/span", ".script"))

                        const funnel = this.create("div/scrollable", overlay)

                        const nameField = this.create("field/tag", funnel)
                        nameField.input.placeholder = "mein-skript"
                        this.verify("input/value", nameField.input)
                        nameField.input.addEventListener("input", () => this.verify("input/value", nameField.input))

                        const scriptField = this.create("field/script", funnel)
                        scriptField.input.style.height = "100vh"
                        this.verify("input/value", scriptField.input)
                        scriptField.input.addEventListener("input", () => this.verify("input/value", scriptField.input))

                        const button = this.create("button/action", funnel)
                        button.textContent = "Skript jetzt speichern"
                        button.addEventListener("click", async () => {

                          await this.verify("field-funnel", funnel)

                          const map = {}
                          map.script = scriptField.input.value
                          map.id = nameField.input.value

                          this.overlay("security", async securityOverlay => {

                            const res = await this.request("/register/script/closed", map)

                            if (res.status === 200) {

                              this.convert("parent/loading", content)
                              await this.render("scripts/update-buttons", content)

                              securityOverlay.remove()
                              overlay.remove()

                            }

                            if (res.status !== 200) {
                              window.alert("Fehler.. Bitte wiederholen.")
                              securityOverlay.remove()
                            }

                          })

                        })

                      })

                    })

                    this.render("text/hr", "Meine Skripte", overlay)

                    const content = this.create("info/loading", overlay)

                    await this.render("scripts/update-buttons", content)


                  })
                })

              }


            }

            return resolve(content)

          }

          if (res.status !== 200) {
            this.convert("element/reset", content)
            this.render("nav/open", content)
          }
        } else {
          this.convert("element/reset", content)
          this.render("nav/open", content)
        }
      })
    }

  }

  static lorem(length) {
    const words = [
      "Lorem", "ipsum", "dolor", "sit", "amet", "consectetur", "adipiscing", "elit",
      "sed", "do", "eiusmod", "tempor", "incididunt", "ut", "labore", "et", "dolore",
      "magna", "aliqua", "Ut", "enim", "ad", "minim", "veniam", "quis", "nostrud",
      "exercitation", "ullamco", "laboris", "nisi", "ut", "aliquip", "ex", "ea", "commodo",
      "consequat", "Duis", "aute", "irure", "dolor", "in", "reprehenderit", "in", "voluptate",
      "velit", "esse", "cillum", "dolore", "eu", "fugiat", "nulla", "pariatur", "Excepteur",
      "sint", "occaecat", "cupidatat", "non", "proident", "sunt", "in", "culpa", "qui",
      "officia", "deserunt", "mollit", "anim", "id", "est", "laborum"
    ]
    let text = ""
    for (let i = 0; i < length; i++) {
      const randomIndex = Math.floor(Math.random() * words.length)
      text += words[randomIndex] + " "
    }
    return text.trim()
  }

  static map(event, input) {

    if (event === "source") {

      input.authors = input.authors.split(",").map(it => it.trim())
      input.publisher = input.publisher.split(",").map(it => it.trim())
      input.isbn = input.isbn.split(",").map(it => it.trim())
      input.keywords = input.keywords.split(",").map(it => it.trim())
      input.language = input.language.split(",").map(it => it.trim())
      return input
    }
  }

  static on(event, input, callback) {

    if (event === "click") {
      input.addEventListener("click", ev => {
        ev.preventDefault()
        callback(ev)
      })
    }

    if (event === "enter") {
      input.addEventListener("keydown", ev => {
        if (ev.key === 'Enter') {
          ev.preventDefault()
          callback(ev)
        }
      })
    }

    if (event === "hover") {

      const split = input.class.split(" ")
      input.node.addEventListener("mouseout", ev => {
        for (let i = 0; i < split.length; i++) {
          const className = split[i]
          input.node.classList.remove(className)
        }
      })
      input.node.addEventListener("mouseover", ev => {
        for (let i = 0; i < split.length; i++) {
          const className = split[i]
          input.node.classList.add(className)
        }
      })
    }

    if (event === "shift+enter") {
      input.addEventListener("keydown", ev => {
        if (ev.key === 'Enter') {
          if (ev.shiftKey) {
            // do default
          } else {
            ev.preventDefault()
            callback()
          }
        }
      })
    }

  }

  static overlay(event, callback) {

    if (event === "children") {

      if (!callback) callback = {}
      this.overlay("toolbox", overlay => {
        if (callback.info) overlay.info.textContent = callback.info
        const childrenContainer = this.create("div/scrollable", overlay)

        childrenLoop: for (let i = 0; i < callback.node.children.length; i++) {
          let child = callback.node.children[i]

          if (child.id === "toolbox") continue
          if (child.id === "toolbox-getter") continue
          if (child.getAttribute("data-id") === "toolbox") continue
          if (child.classList.contains("overlay")) continue

          for (let i = 0; i < child.classList.length; i++) {
            if (child.classList[i].startsWith("overlay")) continue childrenLoop
          }

          const childrenButton = this.create("toolbox/left-right", childrenContainer)
          childrenButton.left.append(this.convert("element/alias", child))
          childrenButton.right.textContent = "Element bearbeiten"

          if (child.tagName === "SCRIPT") {
            this.render("left-right/local-script-toggle", child.id, childrenButton)
          }

          childrenButton.onclick = () => {

            this.overlay("toolbox", async overlay => {
              overlay.info.textContent = `<${this.convert("node/selector", child)}`

              {
                const buttons = this.create("div/scrollable", overlay)

                if (child.closest("svg") !== null) {
                  const button = this.create("toolbox/left-right", buttons)
                  button.left.textContent = ".animate"
                  button.right.textContent = "Animiere dein SVG Element"
                  button.onclick = () => {
                    this.overlay("toolbox", animateSvgOverlay => {
                      animateSvgOverlay.info.textContent = this.convert("node/selector", child)
                      const buttons = this.create("div/scrollable", animateSvgOverlay)
                      {
                        const button = this.create("toolbox/left-right", buttons)
                        button.left.textContent = ".up-and-down"
                        button.right.textContent = "Bewegt dein SVG Element hoch und runter"
                        button.onclick = () => {
                          const animateTransform = document.createElementNS('http://www.w3.org/2000/svg', 'animateTransform')
                          animateTransform.setAttribute('attributeName', 'transform')
                          animateTransform.setAttribute('attributeType', 'XML')
                          animateTransform.setAttribute('type', 'translate')
                          animateTransform.setAttribute('values', '0 0; 0 8; 0 0')
                          animateTransform.setAttribute('dur', '2s')
                          animateTransform.setAttribute('repeatCount', 'indefinite')
                          animateTransform.setAttribute('calcMode', 'spline')
                          animateTransform.setAttribute('keySplines', '0.5 0 0.5 1; 0.5 0 0.5 1')
                          child.appendChild(animateTransform)
                          window.alert("Animation wurde erfolgreich angehängt.")
                          this.remove("overlays")
                        }
                      }
                    })
                  }
                }

                if (child.tagName === "BODY") {
                  if (callback.type === "expert") {
                    const button = this.create("toolbox/left-right", buttons)
                    button.left.textContent = ".back-button"
                    button.right.textContent = "Hänge eine Zurück Taste an"
                    button.onclick = () => {
                      const script = this.create("script", {id: "back-button", js: 'Helper.create("back-button", document.body)'})
                      this.add("script-onbody", script)
                      window.alert("Zurück Taste wurde erfolgreich angehängt.")
                    }
                  }
                }

                if (child.tagName === "BODY") {
                  if (callback.type === "expert") {
                    const button = this.create("toolbox/left-right", buttons)
                    button.left.textContent = ".cite-checker"
                    button.right.textContent = "Lass deine Nutzer, Zitate selber prüfen"
                    button.onclick = () => {
                      const script = this.create("script", {id: "cite-checker", js: `await Helper.add("cite-checker")`})
                      this.add("script-onbody", script)
                      window.alert("Skript wurde erfolgreich angehängt.")
                    }
                  }
                }

                if (child.tagName !== "SCRIPT") {
                  const button = this.create("toolbox/left-right", buttons)
                  button.left.textContent = ".children"
                  button.right.textContent = "Element Inhalt"
                  button.onclick = async () => {

                    if (child.children.length > 0) {
                      this.overlay("children", {node: child, type: callback.type, info: `${this.convert("element/alias", child).textContent}.children`})
                    } else alert("Das HTML Element ist leer.")
                  }
                }

                {
                  const button = this.create("toolbox/left-right", buttons)
                  button.left.textContent = ".class"
                  button.right.textContent = "Klassen definieren"
                  button.onclick = () => {

                    this.overlay("toolbox", overlay => {
                      overlay.info.textContent = `<${this.convert("node/selector", child)}.class`
                      const classField = this.create("input/textarea", overlay)
                      classField.input.placeholder = "mehrere klassen werden mit einem leerzeichen getrennt"
                      classField.input.style.fontFamily = "monospace"
                      classField.input.style.height = "34vh"
                      if (child.hasAttribute("class")) {
                        classField.input.value = child.getAttribute("class")
                      }
                      this.add("outline-hover", classField.input)
                      this.verify("input/value", classField.input)
                      classField.input.oninput = () => {
                        const value = classField.input.value
                        if (this.verifyIs("text/empty", value)) {
                          child.removeAttribute("class")
                        } else {
                          child.setAttribute("class", value)
                        }
                        overlay.info.textContent = `<${this.convert("node/selector", child)}.class`
                        this.render(event, input, parent)
                      }
                    })
                  }
                }

                if (!["BODY"].includes(child.tagName)) {
                  const button = this.create("toolbox/left-right", buttons)
                  button.left.textContent = ".copy"
                  button.right.textContent = "Element kopieren"
                  button.onclick = async () => {
                    await this.convert("text/clipboard", child.outerHTML)
                    window.alert(`${child.tagName} wurde erfolgreich in deine Zwischenablage kopiert.`)
                  }
                }

                if (child.tagName === "BODY") {

                  if (callback.type === "expert") {
                    const button = this.create("toolbox/left-right", buttons)
                    button.left.textContent = ".contact-location-expert"
                    button.right.textContent = "Nutzer dürfen dir Kontaktanfragen per E-Mail senden"
                    button.onclick = () => {
                      const script = this.create("script/contact-location-expert")
                      const exist = document.getElementById(script.id)
                      if (exist === null) {
                        document.body.append(script)
                      } else {
                        exist.remove()
                        document.body.append(script)
                      }
                      window.alert("Skript erfolgreich angehängt.")
                    }
                  }

                  if (callback.type === "expert") {
                    const button = this.create("toolbox/left-right", buttons)
                    button.left.textContent = ".creator-button"
                    button.right.textContent = "Erlaube Nutzer deine Werteinheit zu bearbeiten"
                    button.onclick = async () => {

                      const prompt = window.prompt("Gebe den Typ an: (open/closed/expert)")
                      if (!this.verifyIs("text/empty", prompt)) {
                        if (["open", "closed", "expert"].includes(prompt)) {
                          const script = this.create("script", {id: `${prompt}-creator`, js: `await Helper.add('${prompt}-creator')`})
                          this.add("script-onbody", script)
                          window.alert("Creator wurde erfolgreich angehängt.")
                          this.remove("overlays")
                        }
                      } else {
                        window.alert("Kein gültiger Creator-Typ")
                      }


                    }
                  }
                }

                if (!["SCRIPT", "HEAD"].includes(child.tagName)) {
                  const button = this.create("toolbox/left-right", buttons)
                  button.left.textContent = ".dark-light"
                  button.right.textContent = "Dark Light Modus umschalten"
                  button.onclick = () => {
                    this.convert("node/dark-light-toggle", child)
                    window.alert("Dark Light Modus erfolgreich umgeschaltet.")
                    this.remove("overlays")
                  }
                }

                if (["BODY", "DIV"].includes(child.tagName)) {
                  if (callback.type === "expert") {
                    const button = this.create("toolbox/left-right", buttons)
                    button.left.textContent = ".dark-light-aware"
                    button.right.textContent = "Dark Light Skript für dein Element anhängen"
                    button.onclick = async () => {
                      const selector = await this.convert("element/selector", child)
                      const script = this.create("script", {id: "sdark-light-aware", js: `Helper.convert("selector/dark-light", "${selector}")`})
                      this.add("script-onbody", script)
                      window.alert("Dark Light Skript erfolgreich angehängt.")
                    }
                  }
                }

                if (child.tagName === "SCRIPT") {
                  {
                    const button = this.create("toolbox/left-right", buttons)
                    this.render("left-right/disable-script-local", {script: child, ok: () => {
                      this.render("left-right/local-script-toggle", child.id, childrenButton)
                      overlay.remove()
                    }}, button)

                    const scripts = JSON.parse(window.localStorage.getItem("scripts")) || []
                    for (let i = 0; i < scripts.length; i++) {
                      const script = scripts[i]
                      if (script.id === child.id) {
                        if (script.disabled) {
                          this.render("left-right/enable-script-local", {script: child, ok: () => {
                            this.render("left-right/local-script-toggle", child.id, childrenButton)
                            overlay.remove()
                          }}, button)
                        }
                      }
                    }
                  }
                }

                if (["BODY", "DIV"].includes(child.tagName)) {
                  const button = this.create("toolbox/left-right", buttons)
                  button.left.textContent = ".div"
                  button.right.textContent = "DIV-Element anhängen"
                  button.onclick = () => {
                    this.render("text/div", "DIV", child)
                    window.alert("DIV Element wurde erfolgreich angehängt.")
                    this.remove("overlays")
                  }
                }

                if (child.tagName === "DIV") {

                  if (["closed", "expert"].includes(callback.type)) {
                    const button = this.create("toolbox/left-right", buttons)
                    button.left.textContent = ".div-creator"
                    button.right.textContent = "Bearbeite dein Element schnell und einfach"
                    button.onclick = () => {

                      this.overlay("toolbox", async overlay => {

                        if (callback.type === "expert") {
                          overlay.registerHtmlButton = this.registerHtmlButton(overlay)
                          overlay.registerHtmlButton.onclick = async () => {
                            this.remove("contenteditable", clone)
                            this.remove("selected-node", clone)
                            child.replaceWith(clone)
                            this.add("register-html")
                          }
                        }

                        overlay.info.append(this.convert("element/alias", child))
                        overlay.info.append(this.convert("text/span", ".clone"))

                        const content = this.create("div", overlay)
                        content.style.height = "100vh"
                        content.style.touchAction = "manipulation"

                        const preview = document.createElement("div")
                        preview.style.height = `${window.innerHeight * 0.4}px`
                        preview.style.overflow = "auto"
                        content.append(preview)

                        const backgroundColor = child.parentElement.style.backgroundColor
                        if (!backgroundColor || backgroundColor === "transparent") {
                          preview.style.backgroundColor = "white"
                        } else {
                          preview.style.backgroundColor = backgroundColor
                        }

                        let clone = child.cloneNode(true)
                        clone.setAttribute("contenteditable", "true")
                        preview.append(clone)

                        let selectedNode = clone

                        preview.addEventListener("keydown", ev => {
                          if (ev.metaKey && ev.key === 'c') {
                            ev.preventDefault()
                            if (selectedNode) {
                              this.convert("text/clipboard", selectedNode.outerHTML).then(() => window.alert("Dein HTML Element wurde erfolgreich in die Zwischenablage gespeichert."))
                            }
                          }
                        })

                        preview.addEventListener("keydown", ev => {
                          if (ev.metaKey && ev.key === 'v') {
                            ev.preventDefault()
                            if (selectedNode) {
                              this.convert("clipboard/text").then(text => {
                                const node = this.convert("text/first-child", text)
                                selectedNode.append(node)
                              })
                            }
                          }
                        })

                        let rememberSelectedNodes = []
                        preview.addEventListener("keydown", ev => {
                          if (ev.metaKey && ev.key === 'Backspace') {
                            ev.preventDefault()
                            if (selectedNode) {
                              rememberSelectedNodes.push({ node: selectedNode, parent: selectedNode.parentElement, index: Array.from(selectedNode.parentElement.children).indexOf(selectedNode)})
                              selectedNode.remove()
                            }
                          }
                        })

                        preview.addEventListener("keydown", ev => {
                          if (ev.metaKey && ev.key === 'z') {
                            ev.preventDefault()
                            if (selectedNode) {
                              if (rememberSelectedNodes.length > 0) {
                                const { node, parent, index } = rememberSelectedNodes.pop()
                                const children = Array.from(parent.children)
                                if (index >= 0 && index < children.length) {
                                  parent.insertBefore(node, children[index])
                                } else {
                                  parent.appendChild(node)
                                }
                              }

                            }
                          }
                        })

                        selectedNode.onclick = async (ev) => {
                          ev.preventDefault()
                          ev.stopPropagation()
                          await this.remove("element/selected-node", preview)
                          selectedNode = clone
                          this.add("element/selected-node", selectedNode)
                        }

                        preview.onclick = async (ev) => {
                          ev.preventDefault()
                          ev.stopPropagation()
                          await this.remove("element/selected-node", preview)
                          selectedNode = clone
                        }

                        for (let i = 0; i < clone.children.length; i++) {
                          const cloneChild = clone.children[i]

                          this.add("event/dbltouch", {node: cloneChild, callback: async ev => {
                            ev.preventDefault()
                            ev.stopPropagation()
                            await this.remove("element/selected-node", preview)
                            selectedNode = ev.target.parentElement
                            this.add("element/selected-node", selectedNode)
                          }})

                          cloneChild.ondblclick = async (ev) => {
                            ev.preventDefault()
                            ev.stopPropagation()
                            await this.remove("element/selected-node", preview)
                            selectedNode = ev.target.parentElement
                            this.add("element/selected-node", selectedNode)
                          }

                          cloneChild.onclick = async (ev) => {
                            ev.preventDefault()
                            ev.stopPropagation()

                            if (ev.target.hasAttribute("selected-node")) {
                              await this.remove("element/selected-node", preview)
                              selectedNode = clone
                              this.add("element/selected-node", selectedNode)
                            } else {
                              await this.remove("element/selected-node", preview)
                              selectedNode = ev.target
                              this.add("element/selected-node", selectedNode)
                            }

                          }

                        }

                        const observer = new MutationObserver((mutationsList) => {
                          mutationsList.forEach((mutation) => {
                            if (mutation.type === "childList" && mutation.addedNodes.length > 0) {

                              mutation.addedNodes.forEach(async (node) => {

                                if (node.nodeType === Node.ELEMENT_NODE) {


                                  this.add("event/dbltouch", {node: node, callback: async ev => {
                                    ev.preventDefault()
                                    ev.stopPropagation()
                                    await this.remove("element/selected-node", preview)
                                    selectedNode = ev.target.parentElement
                                    this.add("element/selected-node", selectedNode)
                                  }})

                                  node.ondblclick = async (ev) => {
                                    ev.preventDefault()
                                    ev.stopPropagation()
                                    await this.remove("element/selected-node", preview)
                                    selectedNode = ev.target.parentElement
                                    this.add("element/selected-node", selectedNode)
                                  }

                                  node.onclick = async (ev) => {
                                    ev.preventDefault()
                                    ev.stopPropagation()

                                    if (ev.target.hasAttribute("selected-node")) {
                                      await this.remove("element/selected-node", preview)
                                      selectedNode = clone
                                      this.add("element/selected-node", selectedNode)
                                    } else {
                                      await this.remove("element/selected-node", preview)
                                      selectedNode = ev.target
                                      this.add("element/selected-node", selectedNode)
                                    }

                                  }

                                }
                              })
                            }
                          })
                        })
                        observer.observe(selectedNode, { childList: true, subtree: true })

                        const buttons = this.fn("creator-buttons", {parent: content, type: callback.type})

                        buttons.convertTextContentToH1Button.onclick = () => {
                          const h1 = buttons.convertTextContentToH1(selectedNode)
                          selectedNode = h1
                        }
                        buttons.convertTextContentToH2Button.onclick = () => {
                          const h2 = buttons.convertTextContentToH2(selectedNode)
                          selectedNode = h2
                        }
                        buttons.convertTextContentToH3Button.onclick = () => {
                          const h3 = buttons.convertTextContentToH3(selectedNode)
                          selectedNode = h3
                        }


                        buttons.openVideosOverlayButton.onclick = () => buttons.openVideosOverlay(selectedNode, callback.type)
                        buttons.openAudiosOverlayButton.onclick = () => buttons.openAudiosOverlay(selectedNode, callback.type)
                        buttons.openPdfOverlayButton.onclick = () => buttons.openPdfOverlay(selectedNode, callback.type)
                        buttons.openFunnelOverlayButton.onclick = () => buttons.openFunnelOverlay(selectedNode, callback.type)
                        buttons.styleBackgroundImageButton.onclick = () => buttons.styleBackgroundImage(selectedNode)
                        buttons.appendImageButton.onclick = () => buttons.appendImage(selectedNode)
                        buttons.trimLinesButton.onclick = () => buttons.trimLines(selectedNode)
                        buttons.openUrlButton.onclick = () => buttons.openUrl(selectedNode)
                        buttons.convertToInlineCiteButton.onclick = () => buttons.convertToInlineCite(selectedNode)
                        buttons.convertToFullCiteButton.onclick = () => buttons.convertToFullCite(selectedNode)
                        buttons.removeCiteMarksButton.onclick = () => buttons.removeCiteMarks(selectedNode)
                        buttons.myValueUnitsButton.onclick = () => buttons.createMyValueUnitsBox(selectedNode)
                        buttons.profileSurveysButton.onclick = () => buttons.createProfileSurveysBox(selectedNode)
                        buttons.imageTextAndActionButton.onclick = () => buttons.createImageTextAndActionBox(selectedNode)
                        buttons.backgroundImageWithTitlesButton.onclick = () => buttons.createBackgroundImageWithTitles(selectedNode)
                        buttons.duckDuckGoButton.onclick = () => buttons.convertTextContentToDuckDuckGoLink(selectedNode)
                        buttons.pointerButton.onclick = () => buttons.pointer(selectedNode)
                        buttons.sourcesButton.onclick = () => buttons.openSourcesOverlay(selectedNode, callback.type)
                        buttons.templatesButton.onclick = () => buttons.openTemplatesOverlay(selectedNode)
                        if (callback.type === "expert") {
                          buttons.openScriptsOverlayButton.onclick = () => buttons.openScriptsOverlay(selectedNode, callback.type)
                        }
                        buttons.openImagesOverlayButton.onclick = () => buttons.openImagesOverlay(selectedNode)
                        buttons.createFlexButton.onclick = () => buttons.createFlexWidthWithPrompt(selectedNode)
                        buttons.createGridButton.onclick = () => buttons.createGridMatrixWithPrompt(selectedNode)
                        buttons.appendDivButton.onclick = () => buttons.appendDiv(selectedNode)
                        buttons.rowContainerButton.onclick = () => buttons.createFlexRow(selectedNode)
                        buttons.columnContainerButton.onclick = () => buttons.createFlexColumn(selectedNode)
                        buttons.imageTextButton.onclick = () => buttons.createImageText(selectedNode)
                        buttons.keyValueButton.onclick = () => buttons.createKeyValue(selectedNode)
                        buttons.actionBtnButton.onclick = () => buttons.createActionButton(selectedNode)
                        buttons.horizontalHrButton.onclick = () => buttons.createHr(selectedNode)
                        buttons.simpleHeaderButton.onclick = () => buttons.createLeftImageHeader(selectedNode)
                        buttons.h1Button.onclick = () => buttons.createH1withPrompt(selectedNode)
                        buttons.h2Button.onclick = () => buttons.createH2withPrompt(selectedNode)
                        buttons.h3Button.onclick = () => buttons.createH3withPrompt(selectedNode)
                        buttons.pButton.onclick = () => buttons.createPwithPrompt(selectedNode)
                        buttons.imageButton.onclick = () => buttons.createImagePlaceholder(selectedNode)
                        buttons.tableHeaderButton.onclick = () => buttons.createTableWithMatrixPrompt(selectedNode)
                        buttons.pdfLinkButton.onclick = async () => await buttons.createPdfLinkWithPrompt(selectedNode)
                        buttons.wrapLinkButton.onclick = async () => {
                          const link = await buttons.wrapAnchorWithPrompt(selectedNode)
                          clone = link
                        }
                        buttons.aLinkButton.onclick = () => buttons.createAnchorWithPrompt(selectedNode)
                        buttons.locationAssignButton.onclick = () => buttons.addLocationAssign(selectedNode)
                        buttons.windowOpenBlankButton.onclick = () => buttons.addWindowOpenBlank(selectedNode)
                        buttons.spanButton.onclick = () => buttons.createSpanWithTextContent(selectedNode)
                        buttons.changeSiButton.onclick = () => buttons.createSpanWithSiPrompt(selectedNode)
                        buttons.addSpaceButton.onclick = () => buttons.createSpaceWithHeightPrompt(selectedNode)
                        buttons.arrowRightButton.onclick = () => buttons.createArrowRightWithColorPrompt(selectedNode)
                        buttons.divScrollableButton.onclick = () => buttons.createScrollableY(selectedNode)
                        buttons.packDivButton.onclick = async () => {
                          const div = await buttons.createDivPackOuter(selectedNode)
                          clone = div
                        }
                        buttons.textInputButton.onclick = () => buttons.createTextInput(selectedNode)
                        buttons.numberInputButton.onclick = () => buttons.createTelInput(selectedNode)
                        buttons.checkboxInputButton.onclick = () => buttons.createCheckboxInput(selectedNode)
                        buttons.passwordInputButton.onclick = () => buttons.createPasswordInput(selectedNode)
                        buttons.selectInputButton.onclick = () => buttons.createSelectInput(selectedNode)
                        buttons.createDateInputButton.onclick = () => buttons.createDateInput(selectedNode)
                        buttons.growWidthButton.onclick = () => buttons.toggleStyle({key: "width", value: "100%", node: selectedNode})
                        buttons.maxWidthButton.onclick = () => buttons.setStyleWithPrompt({key: "maxWidth", node: selectedNode, message: "Gebe die maximale Breite deines Elements ein: (z.B., 900px)"})
                        buttons.minWidthButton.onclick = () => buttons.setStyleWithPrompt({key: "minWidth", node: selectedNode, message: "Gebe die minimale Breite deines Elements ein: (z.B., 300px)"})
                        buttons.exactWidthButton.onclick = () => buttons.setStyleWithPrompt({key: "width", node: selectedNode, message: "Gebe die exakte Breite deines Elements ein: (z.B., 350px)"})
                        buttons.increaseWidthButton.onclick = () => buttons.incrementStyle({key: "width", node: selectedNode, delta: 1})
                        buttons.decreaseWidthButton.onclick = () => buttons.decrementStyle({key: "width", node: selectedNode, delta: 1})
                        buttons.growHeightButton.onclick = () => buttons.toggleStyle({key: "height", value: "100%", node: selectedNode})
                        buttons.maxHeightButton.onclick = () => buttons.setStyleWithPrompt({key: "maxHeight", node: selectedNode, message: "Gebe die maximale Höhe deines Elements ein: (z.B., 89vh)"})
                        buttons.minHeightButton.onclick = () => buttons.setStyleWithPrompt({key: "minHeight", node: selectedNode, message: "Gebe die minimale Höhe deines Elements ein: (z.B., 21px)"})
                        buttons.exactHeightButton.onclick = () => buttons.setStyleWithPrompt({key: "height", node: selectedNode, message: "Gebe die exakte Höhe deines Elements ein: (z.B., 21vh)"})
                        buttons.increaseHeightButton.onclick = () => buttons.incrementStyle({key: "height", node: selectedNode, delta: 1})
                        buttons.decreaseHeightButton.onclick = () => buttons.decrementStyle({key: "height", node: selectedNode, delta: 1})
                        buttons.exactDisplayButton.onclick = () => buttons.setStyleWithPrompt({key: "display", node: selectedNode, message: "Gebe den exakten Display Wert ein: (z.B., flex)"})
                        buttons.displayBlockButton.onclick = () => buttons.toggleStyle({key: "display", value: "block", node: selectedNode})
                        buttons.displayInlineButton.onclick = () => buttons.toggleStyle({key: "display", value: "inline", node: selectedNode})
                        buttons.toggleDisplayGridButton.onclick = () => buttons.toggleStyle({key: "display", value: "grid", node: selectedNode})
                        buttons.toggleDisplayFlexButton.onclick = () => buttons.toggleStyle({key: "display", value: "flex", node: selectedNode})
                        buttons.toggleDisplayTableButton.onclick = () => buttons.toggleStyle({key: "display", value: "table", node: selectedNode})
                        buttons.gridMobileButton.onclick = () => buttons.toggleStyles({styles: {display: "grid", gridTemplateColumns: "1fr", gridGap: "21px"}, node: selectedNode})
                        buttons.gridFullDisplayButton.onclick = () => buttons.toggleNodeAndChildrenStyles({nodeStyle: {display: "grid", gridTemplateColumns: "1fr", gridGap: "21px"}, childrenStyle: {height: "89vh"}, node: selectedNode})
                        buttons.gridTwoColumnsButton.onclick = () => buttons.toggleNodeAndChildrenStyles({nodeStyle: {display: "grid", gridTemplateColumns: "1fr 1fr", gridGap: "21px"}, childrenStyle: {height: "89vh"}, node: selectedNode})
                        buttons.gridThreeColumnsButton.onclick = () => buttons.toggleNodeAndChildrenStyles({nodeStyle: {display: "grid", gridTemplateColumns: "1fr 1fr 1fr", gridGap: "21px"}, childrenStyle: {height: "89vh"}, node: selectedNode})
                        buttons.gridFixedButton.onclick = () => buttons.fixedGridPrompt({node: selectedNode})
                        buttons.gridListRowsButton.onclick = () => buttons.toggleNodeAndChildrenStyles({nodeStyle: {display: "grid", gridTemplateColumns: "89px 1fr", gridTemplateRows: `repeat(auto-fit, 55px)`, gridGap: "21px"}, childrenStyle: {height: "55px"}, node: selectedNode})
                        buttons.gridSpanColumnButton.onclick = () => buttons.spanColumnWithPrompt(selectedNode)
                        buttons.gridSpanRowButton.onclick = () => buttons.spanRowWithPrompt(selectedNode)
                        buttons.exactGridGapButton.onclick = () => buttons.setStyleWithPrompt({key: "gap", node: selectedNode, message: "Gebe den exakten Abstand zwischen deinen Grid Elementen ein: (z.B., 13px)"})
                        buttons.gridAddColumnButton.onclick = () => buttons.addGridColumn(selectedNode)
                        buttons.gridRemoveColumnButton.onclick = () => buttons.removeGridColumn(selectedNode)
                        buttons.gridAddRowButton.onclick = () => buttons.addGridRow(selectedNode)
                        buttons.gridRemoveRowButton.onclick = () => buttons.removeGridRow(selectedNode)
                        buttons.alignColumnButton.onclick = () => buttons.toggleStyles({styles: {display: "flex", flexDirection: "column", flexWrap: null}, node: selectedNode})
                        buttons.alignLeftButton.onclick = () => buttons.toggleStyles({styles: {display: "flex", justifyContent: "flex-start"}, node: selectedNode})
                        buttons.alignCenterButton.onclick = () => buttons.toggleStyles({styles: {display: "flex", justifyContent: "center"}, node: selectedNode})
                        buttons.alignRightButton.onclick = () => buttons.toggleStyles({styles: {display: "flex", justifyContent: "flex-end"}, node: selectedNode})
                        buttons.alignRowButton.onclick = () => buttons.toggleStyles({styles: {display: "flex", flexDirection: null, flexWrap: "wrap"}, node: selectedNode})
                        buttons.alignTopButton.onclick = () => buttons.toggleStyles({styles: {display: "flex", alignItems: "flex-start"}, node: selectedNode})
                        buttons.alignVerticalButton.onclick = () => buttons.toggleStyles({styles: {display: "flex", alignItems: "center"}, node: selectedNode})
                        buttons.alignBottomButton.onclick = () => buttons.toggleStyles({styles: {display: "flex", alignItems: "flex-end"}, node: selectedNode})
                        buttons.flexButton.onclick = () => buttons.setStyleWithPrompt({key: "flex", node: selectedNode, message: "Gebe die Flex Matrix für dein Element ein: (z.B., 1 1 55px)"})
                        buttons.spaceBetweenButton.onclick = () => buttons.toggleStyles({styles: {display: "flex", flexWrap: "wrap", justifyContent: "space-between"}, node: selectedNode})
                        buttons.spaceAroundButton.onclick = () => buttons.toggleStyles({styles: {display: "flex", flexWrap: "wrap", justifyContent: "space-around"}, node: selectedNode})
                        buttons.toggleWrapButton.onclick = () => buttons.toggleStyles({styles: {display: "flex", flexWrap: "wrap"}, node: selectedNode})
                        const onLayerClick = async layer => {
                          await this.remove("element/selected-node", preview)
                          selectedNode = layer
                          this.add("selected/node", layer)
                        }
                        buttons.layerButton.onclick = () => buttons.openLayerOverlay(onLayerClick, selectedNode)
                        buttons.positiveLayerButton.onclick = () => buttons.addLayerAbove(selectedNode)
                        buttons.negativeLayerButton.onclick = () => buttons.addLayerBelow(selectedNode)
                        buttons.exactLayerButton.onclick = async () => buttons.addLayerPrompt(selectedNode)
                        buttons.removeLayerButton.onclick = () => buttons.removeAllLayer(selectedNode)
                        buttons.positionAbsoluteButton.onclick = () => buttons.toggleStyle({key: "position", value: "absolute", node: selectedNode})
                        buttons.positionTopButton.onclick = () => buttons.setStyleWithPrompt({key: "top", node: selectedNode, message: "Geben den exakten Abstand nach oben ein: (z.B., 300px)"})
                        buttons.positionRightButton.onclick = () => buttons.setStyleWithPrompt({key: "right", node: selectedNode, message: "Geben den exakten Abstand nach rechts ein: (z.B., 300px)"})
                        buttons.positionBottomButton.onclick = () => buttons.setStyleWithPrompt({key: "bottom", node: selectedNode, message: "Geben den exakten Abstand nach unten ein: (z.B., 300px)"})
                        buttons.positionLeftButton.onclick = () => buttons.setStyleWithPrompt({key: "left", node: selectedNode, message: "Geben den exakten Abstand nach links ein: (z.B., 300px)"})
                        buttons.transformTranslateButton.onclick = () => buttons.translateWithPrompt(selectedNode)
                        buttons.transformTranslateXButton.onclick = () => buttons.translateXWithPrompt(selectedNode)
                        buttons.transformTranslateYButton.onclick = () => buttons.translateYWithPrompt(selectedNode)
                        buttons.zIndexButton.onclick = () => buttons.setStyleWithPrompt({key: "zIndex", node: selectedNode, message: "Gebe deinen Z-Index ein: (z.B., -1)"})
                        buttons.scaleButton.onclick = () => buttons.scaleWithPrompt(selectedNode)
                        buttons.rotateRightButton.onclick = () => buttons.rotateNode({degree: 90, node: selectedNode})
                        buttons.exactRotateRightButton.onclick = () => buttons.rotateNodeRightWithPrompt(selectedNode)
                        buttons.rotateLeftButton.onclick = () => buttons.rotateNode({degree: -90, node: selectedNode})
                        buttons.exactRotateLeftButton.onclick = () => buttons.rotateNodeLeftWithPrompt(selectedNode)
                        buttons.whiteSpaceNoWrapButton.onclick = () => buttons.toggleStyle({key: "whiteSpace", value: "nowrap", node: selectedNode})
                        buttons.fontFamilyButton.onclick = () => buttons.toggleStyle({key: "fontFamily", value: "sans-serif", node: selectedNode})
                        buttons.fontWeightNormalButton.onclick = () => buttons.toggleStyle({key: "fontWeight", value: "normal", node: selectedNode})
                        buttons.fontWeightButton.onclick = () => buttons.toggleStyle({key: "fontWeight", value: "bold", node: selectedNode})
                        buttons.fontStyleButton.onclick = () => buttons.toggleStyle({key: "fontStyle", value: "italic", node: selectedNode})
                        buttons.textDecorationButton.onclick = () => buttons.toggleStyle({key: "textDecoration", value: "underline", node: selectedNode})
                        buttons.fontSizeButton.onclick = () => buttons.setStyleWithPrompt({key: "fontSize", node: selectedNode, message: "Gebe deine Schriftgröße ein: (z.B., 34px)"})
                        buttons.fontColorButton.onclick = () => buttons.setStyleWithPrompt({key: "color", node: selectedNode, message: "Gebe deine Schriftfarbe ein: (z.B., (#888, grey, rgb(88, 88, 88), rgba(0, 0, 0, 0.5)))"})
                        buttons.fontColorButton.onclick = () => buttons.setStyleWithPrompt({key: "backgroundColor", node: selectedNode, message: "Gebe deine Hintergrundfarbe ein: (z.B., (#888, grey, rgb(88, 88, 88), rgba(0, 0, 0, 0.5)))"})
                        buttons.unorderedListButton.onclick = () => buttons.appendUnorderedListItem(selectedNode)
                        buttons.orderedListButton.onclick = () => buttons.appendOrderedListItem(selectedNode)
                        buttons.lineHeightButton.onclick = () => buttons.setStyleWithPrompt({key: "lineHeight", node: selectedNode, message: "Gebe die exakte Linien Höhe ein: (z.B., 1.8)"})
                        buttons.overflowYButton.onclick = () => buttons.toggleStyle({key: "overflowY", value: "auto", node: selectedNode})
                        buttons.overflowXButton.onclick = () => buttons.toggleStyle({key: "overflowX", value: "auto", node: selectedNode})
                        buttons.toggleDisplayNoneButton.onclick = () => buttons.toggleStyle({key: "display", value: "none", node: selectedNode})
                        buttons.toggleVisibilityHiddenButton.onclick = () => buttons.toggleStyle({key: "visibility", value: "hidden", node: selectedNode})
                        buttons.exactOpacityButton.onclick = () => buttons.addOpacityWithPrompt(selectedNode)
                        buttons.toggleMarginButton.onclick = () => buttons.toggleStyle({key: "margin", value: "21px 34px", node: selectedNode})
                        buttons.toggleMarginTopButton.onclick = () => buttons.toggleStyle({key: "marginTop", value: "21px", node: selectedNode})
                        buttons.toggleMarginRightButton.onclick = () => buttons.toggleStyle({key: "marginRight", value: "34px", node: selectedNode})
                        buttons.toggleMarginTopButton.onclick = () => buttons.toggleStyle({key: "marginBottom", value: "21px", node: selectedNode})
                        buttons.toggleMarginLeftButton.onclick = () => buttons.toggleStyle({key: "marginLeft", value: "34px", node: selectedNode})
                        buttons.exactMarginButton.onclick = () => buttons.setStyleWithPrompt({key: "margin", node: selectedNode, message: "Gebe den exakten Außenabstand ein: (z.B., 21px 34px 13px 144px)"})
                        buttons.exactMarginTopButton.onclick = () => buttons.setStyleWithPrompt({key: "marginTop", node: selectedNode, message: "Gebe den exakten Außenabstand nach oben ein: (z.B., 21px)"})
                        buttons.exactMarginRightButton.onclick = () => buttons.setStyleWithPrompt({key: "marginRight", node: selectedNode, message: "Gebe den exakten Außenabstand nach rechts ein: (z.B., 21px)"})
                        buttons.exactMarginBottomButton.onclick = () => buttons.setStyleWithPrompt({key: "marginRight", node: selectedNode, message: "Gebe den exakten Außenabstand nach unten ein: (z.B., 21px)"})
                        buttons.exactMarginLeftButton.onclick = () => buttons.setStyleWithPrompt({key: "marginLeft", node: selectedNode, message: "Gebe den exakten Außenabstand nach links ein: (z.B., 21px)"})
                        buttons.togglePaddingButton.onclick = () => buttons.toggleStyle({key: "padding", value: "21px 34px", node: selectedNode})
                        buttons.togglePaddingTopButton.onclick = () => buttons.toggleStyle({key: "paddingTop", value: "21px", node: selectedNode})
                        buttons.togglePaddingRightButton.onclick = () => buttons.toggleStyle({key: "paddingRight", value: "34px", node: selectedNode})
                        buttons.togglePaddingBottomButton.onclick = () => buttons.toggleStyle({key: "paddingBottom", value: "21px", node: selectedNode})
                        buttons.togglePaddingLeftButton.onclick = () => buttons.toggleStyle({key: "paddingLeft", value: "34px", node: selectedNode})
                        buttons.exactPaddingButton.onclick = () => buttons.setStyleWithPrompt({key: "padding", node: selectedNode, message: "Gebe den exakten Innenabstand ein: (z.B., 21px 34px 13px 144px)"})
                        buttons.exactPaddingTopButton.onclick = () => buttons.setStyleWithPrompt({key: "paddingTop", node: selectedNode, message: "Gebe den exakten Innenabstand nach oben ein: (z.B., 21px)"})
                        buttons.exactPaddingRightButton.onclick = () => buttons.setStyleWithPrompt({key: "paddingRight", node: selectedNode, message: "Gebe den exakten Innenabstand nach rechts ein: (z.B., 21px)"})
                        buttons.exactPaddingBottomButton.onclick = () => buttons.setStyleWithPrompt({key: "paddingRight", node: selectedNode, message: "Gebe den exakten Innenabstand nach unten ein: (z.B., 21px)"})
                        buttons.exactPaddingLeftButton.onclick = () => buttons.setStyleWithPrompt({key: "paddingLeft", node: selectedNode, message: "Gebe den exakten Innenabstand nach links ein: (z.B., 21px)"})
                        buttons.toggleBorderButton.onclick = () => buttons.toggleStyle({key: "border", value: "1px solid black", node: selectedNode})
                        buttons.toggleBorderTopButton.onclick = () => buttons.toggleStyle({key: "borderTop", value: "1px solid black", node: selectedNode})
                        buttons.toggleBorderRightButton.onclick = () => buttons.toggleStyle({key: "borderTop", value: "1px solid black", node: selectedNode})
                        buttons.toggleBorderBottomButton.onclick = () => buttons.toggleStyle({key: "borderBottom", value: "1px solid black", node: selectedNode})
                        buttons.toggleBorderLeftButton.onclick = () => buttons.toggleStyle({key: "borderLeft", value: "1px solid black", node: selectedNode})
                        buttons.exactBorderButton.onclick = () => buttons.setStyleWithPrompt({key: "border", node: selectedNode, message: "Gebe die exakten Grenzlinien ein: (z.B., 3px solid red)"})
                        buttons.exactBorderTopButton.onclick = () => buttons.setStyleWithPrompt({key: "borderTop", node: selectedNode, message: "Gebe die exakten Grenzlinien nach oben ein: (z.B., 3px solid red)"})
                        buttons.exactBorderRightButton.onclick = () => buttons.setStyleWithPrompt({key: "borderRight", node: selectedNode, message: "Gebe die exakten Grenzlinien nach rechts ein: (z.B., 3px solid red)"})
                        buttons.exactBorderBottomButton.onclick = () => buttons.setStyleWithPrompt({key: "borderBottom", node: selectedNode, message: "Gebe die exakten Grenzlinien nach unten ein: (z.B., 3px solid red)"})
                        buttons.exactBorderLeftButton.onclick = () => buttons.setStyleWithPrompt({key: "borderLeft", node: selectedNode, message: "Gebe die exakten Grenzlinien nach links ein: (z.B., 3px solid red)"})
                        buttons.toggleBorderRadiusButton.onclick = () => buttons.toggleStyle({key: "borderRadius", value: "3px", node: selectedNode})
                        buttons.toggleBorderTopLeftRadiusButton.onclick = () => buttons.toggleStyle({key: "borderTopLeftRadius", value: "3px", node: selectedNode})
                        buttons.toggleBorderTopRightRadiusButton.onclick = () => buttons.toggleStyle({key: "borderTopRightRadius", value: "3px", node: selectedNode})
                        buttons.toggleBorderBottomRightRadiusButton.onclick = () => buttons.toggleStyle({key: "borderBottomRightRadius", value: "3px", node: selectedNode})
                        buttons.toggleBorderBottomLeftRadiusButton.onclick = () => buttons.toggleStyle({key: "borderBottomLeftRadius", value: "3px", node: selectedNode})
                        buttons.exactBorderRadiusButton.onclick = () => buttons.setStyleWithPrompt({key: "borderRadius", node: selectedNode, message: "Gebe den exakten Radius, für alle Ecken, ein: (z.B. 13px)"})
                        buttons.exactBorderTopLeftRadiusButton.onclick = () => buttons.setStyleWithPrompt({key: "borderTopLeftRadius", node: selectedNode, message: "Gebe den exakten Radius, für die Ecke Oben-Links, ein: (z.B., 13px)"})
                        buttons.exactBorderTopRightRadiusButton.onclick = () => buttons.setStyleWithPrompt({key: "borderTopRightRadius", node: selectedNode, message: "Gebe den exakten Radius, für die Ecke Oben-Rechts, ein: (z.B., 13px)"})
                        buttons.exactBorderBottomLeftRadiusButton.onclick = () => buttons.setStyleWithPrompt({key: "borderBottomRightRadius", node: selectedNode, message: "Gebe den exakten Radius, für die Ecke Unten-Links, ein: (z.B., 13px)"})
                        buttons.exactBorderBottomRightRadiusButton.onclick = () => buttons.setStyleWithPrompt({key: "borderBottomLeftRadius", node: selectedNode, message: "Gebe den exakten Radius, für die Ecke Unten-Rechts, ein: (z.B., 13px)"})
                        buttons.toggleBorderNoneButton.onclick = () => buttons.toggleStyle({key: "border", value: "none", node: selectedNode})
                        buttons.boxButton.onclick = () => buttons.toggleStyles({styles: {margin: "21px 34px", padding: "8px", borderRadius: "3px", boxShadow: "rgba(0, 0, 0, 0.13) 0px 1px 3px"}, node: selectedNode})
                        buttons.exactBoxShadowButton.onclick = () => buttons.setStyleWithPrompt({key: "boxShadow", node: selectedNode, message: "Geben den exakten Schatten ein: (z.B., rgba(0, 0, 0, 0.13) 0px 1px 3px)"})
                        buttons.mediaQueriesOverviewButton.onclick = () => buttons.openMediaQueriesOverlay()
                        buttons.largeDeviceButton.onclick = () => buttons.addLargeStyle(selectedNode)
                        buttons.middleDeviceButton.onclick = () => buttons.addMiddleStyle(selectedNode)
                        buttons.smallDeviceButton.onclick = () => buttons.addSmallStyle(selectedNode)
                        buttons.printerDeviceButton.onclick = () => buttons.addPrinterStyle(selectedNode)

                        let rememberCuttedNodes = []
                        buttons.insertAfterButton.onclick =  () => buttons.insertAfter(selectedNode, rememberCuttedNodes)
                        buttons.insertBeforeButton.onclick =  () => buttons.insertBefore(selectedNode, rememberCuttedNodes)
                        buttons.insertLeftButton.onclick =  () => buttons.insertLeft(selectedNode, rememberCuttedNodes)
                        buttons.insertRightButton.onclick =  () => buttons.insertRight(selectedNode, rememberCuttedNodes)
                        buttons.cutOuterHtmlButton.onclick = () => {
                          if (selectedNode) {
                            rememberCuttedNodes.push({ node: selectedNode, parent: selectedNode.parentElement, index: this.convert("node/index", selectedNode)})
                            selectedNode.remove()
                          }
                        }
                        buttons.copyOuterHtmlButton.onclick = () => buttons.addOuterHtmlToClipboard(selectedNode)
                        buttons.pasteOuterHtmlButton.onclick = () => buttons.appendClipboardToNode(selectedNode)
                        buttons.copyStyleButton.onclick = () => buttons.addStyleToClipboard(selectedNode)
                        buttons.pasteStyleButton.onclick = () => buttons.addClipboardToStyle(selectedNode)
                        buttons.removeStyleButton.onclick = () => buttons.toggleAttribute("style", selectedNode)
                        buttons.removeInnerButton.onclick = () => buttons.toggleInnerHtml(selectedNode)
                        buttons.removeInnerWithTextButton.onclick = async () => await buttons.replaceInnerHtmlWithPrompt(selectedNode)
                        buttons.removeNodeButton.onclick = () => buttons.toggleNode(selectedNode)
                        buttons.idButton.onclick = () => buttons.setIdWithPrompt(selectedNode)
                        buttons.addClassButton.onclick = () => buttons.setClassWithPrompt(selectedNode)
                        buttons.setAttributeButton.onclick = () => buttons.setAttributeWithPrompt(selectedNode)
                        buttons.appendStyleButton.onclick = () => buttons.appendStyleWithPrompt(selectedNode)
                        buttons.fontSizeForEachChildButton.onclick = () => buttons.setChildrenStyleWithPrompt("fontSize", selectedNode, "Gebe die Schriftgrüße für alle Kind Elemente: (z.B., 21px)")

                        const svgIconsFragment = await buttons.svgIcons.appendSvgIconsFragment(buttons.svgPickerOptions, (button) => {
                          selectedNode.appendChild(button.querySelector(".icon").cloneNode(true))
                        })

                      })

                    }
                  }

                }

                if (child.closest("svg") !== null) {

                  {
                    const button = this.create("toolbox/left-right", buttons)
                    button.left.textContent = ".fill"
                    button.right.textContent = "Passe die Farbe deine SVG Elements an"
                    button.onclick = () => {
                      this.overlay("toolbox", colorsOverlay => {
                        colorsOverlay.info.textContent = ".fill.colors"
                        const container = this.create("div/flex-row", colorsOverlay)
                        container.style.overflow = "auto"
                        container.style.paddingBottom = "144px"
                        this.fn("renderColors")(container, (value) => {
                          child.setAttribute("fill", value)
                          window.alert(`Das 'fill'-Attribut wurde erfolgreich im ${child.tagName.toUpperCase()} gesetzt.`)
                          this.remove("overlays")
                        })
                      })
                    }
                  }

                  {
                    const button = this.create("toolbox/left-right", buttons)
                    button.left.textContent = ".fixed-bottom-center"
                    button.right.textContent = "Positioniere dein SVG fixiert-unten-mittig"
                    button.onclick = () => {
                      this.style(child, {position: "fixed", bottom: "0", left: "50%", transform: "translateX(-50%)"})
                      window.alert("Dein SVG wurde erfolgreich positioniert.")
                    }
                  }


                }

                {
                  const button = this.create("toolbox/left-right", buttons)
                  button.left.textContent = ".html"
                  button.right.textContent = "HTML anhängen"
                  button.onclick = () => {

                    this.overlay("toolbox", overlay => {
                      overlay.info.textContent = `<${this.convert("node/selector", child)}.html`
                      const funnel = this.create("div/scrollable", overlay)
                      const field = this.create("input/textarea", funnel)
                      field.input.placeholder = `<div>..</div>`
                      field.input.style.fontSize = "13px"
                      field.input.style.fontFamily = `monospace`
                      field.input.style.height = "55vh"
                      field.input.setAttribute("required", "true")
                      this.verify("input/value", field.input)
                      field.input.oninput = () => this.verify("input/value", field.input)
                      const submit = this.create("toolbox/action", funnel)
                      submit.textContent = "HTML jetzt anhängen"
                      submit.onclick = async () => {
                        const html = await this.convert("text/purified", field.input.value)
                        if (!this.verifyIs("text/empty", html)) {
                          child.append(html)
                          this.remove("overlays")
                        } else {
                          window.alert("Kein gültiges HTML.")
                        }
                      }
                    })
                  }
                }

                if (child.tagName === "BODY") {
                  if (callback.type === "expert") {
                    const button = this.create("toolbox/left-right", buttons)
                    button.left.textContent = ".html-feedback"
                    button.right.textContent = "Lass dir Feedback für deine Werteinheiten geben"
                    button.onclick = () => {
                      const script = this.create("script", {id: "html-feedback", js: 'Helper.add("html-feedback")'})
                      this.add("script-onbody", script)
                      window.alert("Feedback Taste wurde erfolgreich angehängt.")
                    }
                  }

                  if (callback.type === "expert") {
                    const button = this.create("toolbox/left-right", buttons)
                    button.left.textContent = ".html-statistics"
                    button.right.textContent = "Entscheide welche Statistiken du, für deine Werteinheit, anwenden möchtest"
                    button.onclick = () => {
                      this.overlay("toolbox", overlay => {
                        overlay.info.textContent = ".html-statistics"
                        const buttons = this.create("div/scrollable", overlay)
                        {
                          const button = this.create("toolbox/left-right", buttons)
                          button.right.textContent = ".html-requested"
                          button.left.textContent = "Speichert, wie oft deine Werteinheit angefordert wird"
                          button.onclick = () => {
                            const script = this.create("script", {id: "html-requested", js: 'Helper.request("/register/location/html-requested/")'})
                            this.add("script-onbody", script)
                            window.alert("HTML Requested Skript wurde erfolgreich angehängt.")
                          }
                        }
                      })
                    }
                  }
                }

                {
                  const button = this.create("toolbox/left-right", buttons)
                  button.left.textContent = ".id"
                  button.right.textContent = "Element Id definieren"
                  button.onclick = async () => {

                    this.overlay("toolbox", async overlay => {
                      overlay.info.textContent = `<${this.convert("node/selector", child)}.id`
                      const idField = this.create("input/text", overlay)
                      idField.input.setAttribute("accept", "text/tag")
                      idField.input.placeholder = "Identifikationsname (text/tag)"
                      if (child.hasAttribute("id")) {
                        idField.input.value = child.getAttribute("id")
                      }
                      this.add("outline-hover", idField.input)
                      this.verify("input/value", idField.input)
                      idField.input.oninput = async () => {
                        await this.verify("input/value", idField.input)
                        const value = idField.input.value
                        if (this.verifyIs("text/empty", value)) {
                          child.removeAttribute("id")
                        } else {
                          if (!document.getElementById(value)) {
                            child.setAttribute("id", value)
                          } else {
                            this.add("style/not-valid", idField.input)
                          }
                        }
                        overlay.info.textContent = `<${this.convert("node/selector", child)}.id`
                      }
                    })



                  }
                }

                {
                  const button = this.create("toolbox/left-right", buttons)
                  button.left.textContent = ".innerHTML"
                  button.right.textContent = "HTML Inhalt ersetzen"
                  button.onclick = async () => {
                    this.overlay("toolbox", overlay => {
                      overlay.info.append(this.convert("element/alias", document.body))
                      overlay.info.append(this.convert("text/span", ".innerHTML"))
                      const funnel = this.create("div/scrollable", overlay)
                      const htmlField = this.create("input/textarea", funnel)
                      htmlField.input.style.height = "55vh"
                      htmlField.input.style.fontFamily = "monospace"
                      htmlField.input.style.fontSize = "13px"
                      htmlField.input.placeholder = "<body>..</body>"
                      this.verify("input/value", htmlField.input)
                      const submit = this.create("toolbox/action", funnel)
                      submit.textContent = "Inhalte jetzt ersetzen"
                      submit.onclick = async () => {
                        const purified = await Helper.convert("text/purified", htmlField.input.value)
                        if (!this.verifyIs("text/emtpy", purified)) {
                          const s1 = child.querySelector("script#html-creator")
                          const s2 = child.querySelector("script#toolbox-getter")
                          child.innerHTML = purified
                          if (s1) this.add("html-creator")
                          if (s2) this.add("toolbox-getter")
                          this.remove("overlays")
                        } else {
                          window.alert("Kein gültiges HTML.")
                        }
                      }
                    })
                  }
                }

                if (child.tagName === "BODY") {
                  if (callback.type === "expert") {
                    const button = this.create("toolbox/left-right", buttons)
                    button.left.textContent = ".location-list-funnel-button"
                    button.right.textContent = "Definiere Listen, mit der sich deine Nutzer selber markieren können"
                    button.onclick = () => {
                      this.overlay("toolbox", async overlay => {
                        const funnel = this.create("div/scrollable", overlay)
                        const pathField = await this.create("field/open-expert-values-path-select", funnel)
                        const submitButton = this.create("button/action", funnel)
                        submitButton.textContent = "Button jetzt anhängen"
                        submitButton.onclick = async () => {
                          const fieldFunnel = await this.convert("path/field-funnel", pathField.input.value)
                          const script = this.create("script", {id: `${fieldFunnel.id}-location-list`, js: `await Helper.add("location-list-funnel", {tag: "${fieldFunnel.id}", path: "${pathField.input.value}"})`})
                          this.add("script-onbody", script)
                          const button = this.create("button/image-text", document.body)
                          button.text.textContent = this.convert("text/capital-first-letter", fieldFunnel.id)
                          button.id = `${fieldFunnel.id}-location-list-button`
                          this.remove("overlays")
                          window.alert("Location List Funnel Button wurde erfolgreich angehängt.")
                        }
                      })
                    }
                  }
                }

                if (child.tagName === "BODY") {
                  if (callback.type === "expert") {
                    const button = this.create("toolbox/left-right", buttons)
                    button.left.textContent = ".match-maker"
                    button.right.textContent = "Match Maker Skripte anhängen"
                    button.onclick = () => {
                      this.overlay("toolbox", async overlay => {
                        overlay.info.textContent = ".match-maker"

                        const content = this.create("info/loading", overlay)

                        const res = await this.request("/get/platform/match-maker-location-expert/")

                        if (res.status === 200) {
                          const matchMaker = JSON.parse(res.response)

                          this.convert("parent/scrollable", content)

                          this.render("match-maker/buttons", matchMaker, content)
                        }

                        if (res.status !== 200) {
                          const res = await this.request("/get/platform/match-maker-location-writable/")

                          if (res.status === 200) {
                            const matchMaker = JSON.parse(res.response)

                            this.convert("parent/scrollable", content)

                            this.render("match-maker/buttons", matchMaker, content)
                          }

                          if (res.status !== 200) {
                            this.convert("parent/info", content)
                            content.textContent = "Es wurden keine Match Maker gefunden."
                            throw new Error("match maker not found")
                          }
                        }


                      })
                    }
                  }
                }

                if (["BODY", "DIV"].includes(child.tagName)) {
                  const button = this.create("toolbox/left-right", buttons)
                  button.left.textContent = ".md"
                  button.right.textContent = "Markdown konvertieren und anhängen"
                  button.onclick = async () => {
                    this.overlay("toolbox", markdownToHtmlOverlay => {
                      markdownToHtmlOverlay.info.textContent = ".md-to-div"
                      const funnel = this.create("div/scrollable", markdownToHtmlOverlay)
                      const markdownField = this.create("input/textarea", funnel)
                      markdownField.input.placeholder = "Markdown zu HTML konvertieren (md/html)\n\n# Hello, Markdown! .. "
                      markdownField.input.style.fontSize = "13px"
                      markdownField.input.style.height = "55vh"
                      markdownField.input.setAttribute("required", "true")
                      markdownField.input.oninput = () => this.verify("input/value", markdownField.input)
                      this.verify("input/value", markdownField.input)
                      const submit = this.create("toolbox/action", funnel)
                      submit.textContent = "Markdown jetzt anhängen"
                      submit.onclick = async () => {
                        await this.verify("input/value", markdownField.input)
                        const markdown = markdownField.input.value
                        const html = this.convert("markdown/html", markdown)
                        const markdownDiv = document.createElement("div")
                        markdownDiv.classList.add("markdown-container")
                        markdownDiv.innerHTML = await this.convert("text/purified", html)
                        child.appendChild(markdownDiv)
                        window.alert(`Markdown erfolgreich konvertiert und im ${child.tagName} angehängt.`)
                        this.remove("overlays")
                      }
                    })
                  }
                }

                if (!["SCRIPT", "HEAD", "BODY"].includes(child.tagName)) {
                  const button = this.create("toolbox/left-right", buttons)
                  button.left.textContent = ".paste"
                  button.right.textContent = "Kopiertes Element anhängen"
                  button.onclick = async () => {

                    const text = await this.convert("clipboard/text")
                    const purified = await this.convert("text/purified", text)
                    if (this.verifyIs("text/empty", purified)) {
                      window.alert("Kein gültiges HTML.")
                      return
                    }
                    const fragment = document.createDocumentFragment()
                    const html = this.convert("text/html", purified)
                    fragment.appendChild(html)
                    child.appendChild(fragment)
                    window.alert(`Zwischenablage wurde erfolgreich in '${child.tagName}' angehängt.`)
                    this.remove("overlays")
                  }
                }

                if (child.tagName === "BODY") {
                  if (callback.type === "expert") {
                    const button = this.create("toolbox/left-right", buttons)
                    button.left.textContent = ".role-apps"
                    button.right.textContent = "Rollenapps Freigabe Button anhängen"
                    button.addEventListener("click", () => {

                      this.overlay("toolbox", async overlay => {
                        this.render("text/title", "Für welche Rolle möchtest du den Button anhängen?", overlay)

                        const content = this.create("info/loading", overlay)

                        const res = await this.request("/get/platform/roles-location-expert/")

                        if (res.status === 200) {
                          const roles = JSON.parse(res.response)

                          this.convert("parent/scrollable", content)

                          for (let i = 0; i < roles.length; i++) {
                            const role = roles[i]

                            this.render("role/role-apps-button-onbody", role, content)

                          }
                        }

                        if (res.status !== 200) {
                          const res = await this.request("/get/platform/roles-location-writable/")

                          if (res.status === 200) {
                            const roles = JSON.parse(res.response)

                            this.convert("parent/scrollable", content)

                            for (let i = 0; i < roles.length; i++) {
                              const role = roles[i]

                              this.render("role/role-apps-button-onbody", role, content)

                            }

                          }

                          if (res.status !== 200) {
                            this.convert("parent/info", content)
                            content.textContent = "Keine Rollen gefunden."
                          }
                        }


                      })
                    })
                  }
                }

                if (["BODY", "DIV"].includes(child.tagName)) {

                  if (callback.type === "expert") {
                    const button = this.create("toolbox/left-right", buttons)
                    button.left.textContent = ".role-login"
                    button.right.textContent = "Rollen Zugang anhängen"
                    button.onclick = () => {
                      this.overlay("toolbox", async overlay => {
                        overlay.info.textContent = `<${this.convert("node/selector", child)}.access`
                        this.render("text/title", "Für welche Rolle möchtest du einen Zugang anhängen?", overlay)
                        const content = this.create("info/loading", overlay)

                        function renderRoleButtons(roles, child, node) {
                          Helper.convert("parent/scrollable", node)
                          for (let i = 0; i < roles.length; i++) {
                            const role = roles[i]
                            const button = Helper.create("button/left-right", node)
                            button.left.textContent = role.name
                            button.right.textContent = `Rolle ${i + 1}`
                            Helper.add("outline-hover", button)
                            button.onclick = () => {
                              Helper.create("field-funnel/login", child)
                              const script = Helper.create("script", {id: "role-login", js: `Helper.add("role-login", {"id":${role.created},"name":"${role.name}"})`})
                              Helper.add("script-onbody", script)
                              window.alert("Zugang wurde erfolgreich angehängt.")
                              Helper.remove("overlays")
                            }
                          }
                        }

                        const res = await this.request("/get/platform/roles-location-expert/")
                        if (res.status === 200) {
                          const roles = JSON.parse(res.response)
                          renderRoleButtons(roles, input, content)
                        } else {
                          const res = await this.request("/get/platform/roles-location-writable/")
                          if (res.status === 200) {
                            const roles = JSON.parse(res.response)
                            renderRoleButtons(roles, input, content)
                          } else {
                            this.convert("parent/info", content)
                            content.textContent = "Es wurden keine Rollen gefunden."
                          }
                        }

                      })
                    }
                  }
                }

                if (!["BODY", "HEAD"].includes(child.tagName)) {

                  {
                    const button = this.create("toolbox/left-right", buttons)
                    button.left.textContent = ".remove"
                    button.right.textContent = "Element entfernen"
                    button.onclick = async () => {
                      child.remove()
                      this.remove("overlays")
                    }
                  }
                }

                if (child.tagName === "BODY") {
                  if (callback.type === "expert") {
                    const button = this.create("toolbox/left-right", buttons)
                    button.left.textContent = ".script"
                    button.right.textContent = "JavaScript anhängen"
                    button.onclick = () => {
                      this.overlay("toolbox", overlay => {
                        const funnel = this.create("div/scrollable", overlay)
                        const nameField = this.create("field/id", funnel)
                        const jsField = this.create("field/js", funnel)
                        jsField.label.textContent = "JavaScript Browser Funktionen + Plattform Helper Funktionen"
                        jsField.input.oninput = () => this.verify("input/value", jsField.input)
                        this.verifyIs("field-funnel/valid", funnel)
                        const submit = this.create("button/action", funnel)
                        submit.textContent = "Skript jetzt anhängen"
                        submit.onclick = async () => {
                          await this.verify("field-funnel", funnel)
                          const script = this.create("script", {id: nameField.input.value, js: jsField.input.value})
                          if (!this.verifyIs("id/unique", script.id)) {
                            this.add("style/not-valid", nameField.input)
                          }
                          this.add("id-onbody", script)
                        }
                      })
                    }
                  }
                }

                if (["BODY", "DIV"].includes(child.tagName)) {

                  if (callback.type === "expert") {
                    const button = this.create("toolbox/left-right", buttons)
                    button.left.textContent = ".session-login"
                    button.right.textContent = "Anmelde Zugang anhängen"
                    button.onclick = () => {
                      this.create("session-login", child)
                      const script = this.create("script", {id: "session-login", js: `Helper.add("session-login", document.body)`})
                      this.add("script-onbody", script)
                      window.alert("Zugang wurde erfolgreich angehängt.")
                      this.remove("overlays")
                    }
                  }
                }

                {
                  const button = this.create("toolbox/left-right", buttons)
                  button.left.textContent = ".setAttribute"
                  button.right.textContent = "Neues Attribut setzen"
                  button.onclick = () => {
                    const attribute = window.prompt("Gebe dein neues Attribut ein: (z.B., width)")
                    if (!this.verifyIs("text/empty", attribute)) {
                      const value = window.prompt("Gebe den Wert ein: (z.B., 100%)")
                      if (!this.verifyIs("text/empty", value)) {
                        child.setAttribute(attribute, value)
                        window.alert(`"Dein neues Attribut wurde erfolgreich im ${child.tagName} gesetzt`)
                      }
                    }
                  }
                }

                if (child.tagName === "BODY") {

                  if (callback.type === "expert") {
                    const button = this.create("toolbox/left-right", buttons)
                    button.left.textContent = ".scripts"
                    button.right.textContent = "Nutze geprüfte HTML Skripte"
                    button.onclick = () => {

                      this.overlay("toolbox", async overlay => {
                        overlay.info.textContent = ".scripts"
                        const content = this.create("info/loading", overlay)
                        const res = await this.request("/get/scripts/toolbox/")
                        if (res.status === 200) {
                          const scripts = JSON.parse(res.response)
                          await this.render("toolbox-scripts", scripts, content)
                        } else {
                          const res = await this.request("/get/scripts/writable/")
                          if (res.status === 200) {
                            const scripts = JSON.parse(res.response)
                            await this.render("toolbox-scripts", scripts, content)
                          } else {
                            this.convert("parent/info", content)
                            content.textContent = "Keine Skripte gefunden"
                            this.style(content, {margin: "21px 34px"})
                          }
                        }
                      })

                    }
                  }
                }

                if (child.tagName === "HEAD") {


                  {
                    const button = this.create("toolbox/left-right", buttons)
                    button.left.textContent = ".style"
                    button.right.textContent = "Design als Style Tag anhängen"
                    button.onclick = () => {

                      this.overlay("toolbox", overlay => {
                        overlay.info.textContent = `<${this.convert("node/selector", child)}.style`
                        const funnel = this.create("div/scrollable", overlay)
                        const cssField = this.create("input/textarea", funnel)
                        cssField.input.placeholder = `.class {..}`
                        cssField.input.style.fontFamily = "monospace"
                        cssField.input.style.fontSize = "13px"
                        cssField.input.style.height = "55vh"
                        cssField.input.setAttribute("required", "true")
                        cssField.input.oninput = () => this.verify("input/value", cssField.input)
                        const submit = this.create("toolbox/action", funnel)
                        submit.textContent = "Style jetzt anhängen"
                        submit.onclick = async () => {
                          await this.verify("input/value", cssField.input)
                          const style = document.createElement("style")
                          style.textContent = cssField.input.value
                          child.appendChild(style)
                          this.remove("overlays")
                        }
                      })
                    }
                  }

                }

                if (!["SCRIPT", "BODY", "HEAD"].includes(child.tagName)) {

                  const button = this.create("toolbox/left-right", buttons)
                  button.left.textContent = ".style"
                  button.right.textContent = "CSS Import mit Vorschau bearbeiten"
                  button.onclick = () => {

                    this.overlay("toolbox", overlay => {
                      overlay.info.textContent = `<${this.convert("node/selector", child)}.style`
                      const content = this.create("div/scrollable", overlay)
                      const preview = document.createElement("div")
                      preview.style.height = `${window.innerHeight * 0.4}px`
                      preview.style.overflow = "auto"
                      const clone = child.cloneNode(true)
                      clone.id = Date.now()
                      clone.name = `${Date.now()}`
                      preview.append(clone)
                      content.append(preview)
                      this.render("text/hr", "Vorschau", content)
                      const cssField = this.create("field/textarea", content)
                      cssField.label.textContent = "CSS Eigenschaften"
                      cssField.input.style.height = "233px"
                      cssField.input.style.fontFamily = "monospace"
                      cssField.input.style.fontSize = "13px"
                      cssField.input.placeholder = "color: blue;\nborder: 1px solid black;\n\n  ..\n\nkey: value;"
                      this.add("outline-hover", cssField.input)
                      if (child.hasAttribute("style")) {
                        cssField.input.value = this.convert("styles/text", child)
                      }
                      this.verify("input/value", cssField.input)
                      cssField.input.oninput = () => {
                        const css = cssField.input.value
                        clone.setAttribute("style", css)
                        child.setAttribute("style", css)
                      }
                    })
                  }

                }

                if (child.tagName === "BODY") {

                  const button = this.create("toolbox/left-right", buttons)
                  button.left.textContent = ".style"
                  button.right.textContent = "CSS Import"
                  button.addEventListener("click", () => {

                    this.overlay("toolbox", overlay => {
                      overlay.info.textContent = `${this.convert("element/alias", child).textContent}.style`
                      const content = this.create("div/scrollable", overlay)
                      const cssField = this.create("input/textarea", content)
                      cssField.input.style.height = "55vh"
                      cssField.input.style.fontFamily = "monospace"
                      cssField.input.style.fontSize = "13px"
                      cssField.input.placeholder = "color: blue;\nborder: 1px solid black;\n\n  ..\n\nkey: value;"
                      if (child.hasAttribute("style")) {
                        cssField.input.value = this.convert("styles/text", child)
                      }
                      this.verify("input/value", cssField.input)
                      cssField.input.oninput = async () => {

                        await this.verify("input/value", cssField.input)

                        const css = cssField.input.value

                        if (this.verifyIs("text/empty", css)) {
                          child.removeAttribute("style")
                        } else {
                          child.setAttribute("style", css)
                        }


                      }
                    })
                  })

                }

                if (!["SCRIPT", "HEAD"].includes(child.tagName)) {
                  const button = this.create("toolbox/left-right", buttons)
                  button.left.textContent = ".svg"
                  button.right.textContent = "Bringe deine Kreativität zum Ausdruck"
                  button.onclick = () => {
                    const svg = this.fn("svg")
                    this.overlay("toolbox", svgOptionsOverlay => {
                      svgOptionsOverlay.info.textContent = ".svg.options"
                      const buttons = this.create("div", svgOptionsOverlay)
                      {
                        const button = this.create("toolbox/left-right", buttons)
                        button.left.textContent = ".icons"
                        button.right.textContent = "Füge vorgefertigte Icons deinem Element hinzu"
                        button.onclick = () => {
                          this.overlay("toolbox", async svgIconsOverlay => {
                            svgIconsOverlay.info.textContent = ".svg.icons"
                            const container = this.create("div/flex-row", svgIconsOverlay)
                            container.style.overflow = "auto"
                            await svg.icons(container, (iconButton, svgIcon) => {
                              iconButton.onclick = () => {
                                child.appendChild(svgIcon.cloneNode(true))
                                window.alert(`SVG wurde erfolgreich im ${child.tagName} angehängt.`)
                                this.remove("overlays")
                              }
                            })
                          })
                        }
                      }

                      {
                        const button = this.create("toolbox/left-right", buttons)
                        button.left.textContent = ".upload"
                        button.right.textContent = "Lade dein eigenes SVG und füge es deinem Element hinzu"
                        button.onclick = () => {
                          this.overlay("popup", overlay => {
                            const inputField = this.create("input/file", overlay)
                            inputField.input.setAttribute("accept", "image/svg+xml")
                            this.add("style/not-valid", inputField.input)
                            inputField.input.oninput = async () => {
                              const file = inputField.input.files[0]
                              if (file.type === "image/svg+xml") {
                                this.add("style/valid", inputField.input)
                                const svg = await this.convert("file/svg", file)
                                child.appendChild(svg)
                                this.remove("overlays")
                              } else {
                                window.alert("Falsches Format. Es sind nur .svg Dateien erlaubt.")
                              }
                            }
                          })
                        }
                      }

                    })
                  }
                }

                if (child.tagName !== "BODY") {



                  {
                    const button = this.create("toolbox/left-right", buttons)
                    button.left.textContent = ".textContent"
                    button.right.textContent = "Text Inhalt aktualisieren"
                    button.onclick = () => {

                      const editors = [
                        { name: 'codepen.io', url: 'https://codepen.io/pen/?editors=1100' },
                        { name: 'jsfiddle.net', url: 'https://jsfiddle.net/' },
                        { name: 'codesandbox.io', url: 'https://codesandbox.io/s/new' },
                        { name: 'jsbin.com', url: 'https://jsbin.com/?js' },
                        { name: 'playcode.io', url: 'https://playcode.io/javascript' },
                        { name: 'blackbox.ai', url: 'https://blackbox.ai/' },
                        { name: 'beautifier.io', url: 'https://beautifier.io/' },
                      ]


                      this.overlay("toolbox", overlay => {
                        overlay.info.textContent = `<${this.convert("node/selector", child)}.textContent`
                        const content = this.create("div/scrollable", overlay)
                        const htmlField = this.create("input/textarea", content)
                        htmlField.input.style.height = "55vh"
                        htmlField.input.style.fontFamily = "monospace"
                        htmlField.input.style.fontSize = "13px"
                        htmlField.input.placeholder = "Mein Text Inhalt"
                        htmlField.input.value = child.textContent
                        this.add("outline-hover", htmlField.input)
                        this.verify("input/value", htmlField.input)
                        htmlField.input.oninput = () => {
                          child.textContent = htmlField.input.value
                        }

                        for (let i = 0; i < editors.length; i++) {
                          const editor = editors[i]
                          const button = this.create("toolbox/left-right", content)
                          button.left.textContent = `.${editor.name}`
                          button.right.textContent = "Öffnet einen Editor in einem neuen Fenster"
                          button.onclick = () => window.open(editor.url, "_blank")
                        }

                      })
                    }
                  }


                }

                if (child.tagName === "HEAD") {
                  const button = this.create("toolbox/left-right", buttons)
                  button.left.textContent = ".title"
                  button.right.textContent = "Dokument Titel definieren"
                  button.onclick = async () => {

                    this.overlay("toolbox", async overlay => {
                      overlay.info.textContent = `<${this.convert("node/selector", child)}.title`
                      const funnel = this.create("div/scrollable", overlay)
                      const titleField = this.create("input/text", funnel)
                      titleField.input.placeholder = "<title>..</title>"
                      titleField.input.addEventListener("input", ev => {
                        const text = ev.target.value
                        if (this.verifyIs("text/empty", text)) {
                          document.querySelector("title").remove()
                          return
                        }

                        let title = document.querySelector("title")
                        if (title) {
                          title.textContent = text
                        } else {
                          title = document.createElement("title")
                          title.textContent = text
                          document.head.appendChild(title)
                        }
                      })
                    })
                  }
                }

                if (child.tagName === "BODY") {
                  if (callback.type === "expert") {
                    const button = this.create("toolbox/left-right", buttons)
                    button.left.textContent = ".users-trees-open"
                    button.right.textContent = "Hol dir eine Liste mit Nutzern"
                    button.onclick = () => {
                      this.overlay("toolbox", overlay => {
                        const funnel = this.create("div/scrollable", overlay)
                        createIdTreesFunnel(funnel)
                        funnel.submit.onclick = async () => {
                          await this.verify("field-funnel", funnel)
                          const script = this.create("script", {id: funnel.idField.input.value, js: `await Helper.render("users-trees-open", ${funnel.treesField.input.value}, ".${funnel.idField.input.value}")`})
                          if (!this.verifyIs("id/unique", script.id)) {
                            this.add("style/not-valid", funnel.idField.input)
                          }
                          this.add("id-onbody", script)
                        }
                      })
                    }
                  }

                  function createIdTreesFunnel(node) {
                    const fragment = document.createDocumentFragment()
                    node.idField = Helper.create("field/tag", fragment)
                    node.idField.label.textContent = "Vordefiniertes Design mit einer Id finden"
                    node.idField.input.placeholder = "meine-element"
                    Helper.add("outline-hover", node.idField.input)
                    Helper.verify("input/value", node.idField.input)
                    node.idField.input.oninput = () => Helper.verify("input/value", node.idField.input)
                    node.treesField = Helper.create("field/trees", fragment)
                    node.treesField.label.textContent = "Liste mit Datenstrukturen eingeben"
                    node.treesField.input.placeholder = `[\n  "getyour.expert.name",\n  "platform.company.name",\n  "email"\n]`
                    node.treesField.input.style.height = "144px"
                    Helper.add("outline-hover", node.treesField.input)
                    Helper.verify("input/value", node.treesField.input)
                    node.treesField.input.oninput = () => Helper.verify("input/value", node.treesField.input)
                    node.submit = Helper.create("toolbox/action", fragment)
                    node.submit.textContent = "Skript jetzt anhängen"
                    node?.appendChild(fragment)
                    return node
                  }

                  if (callback.type === "expert") {
                    const button = this.create("toolbox/left-right", buttons)
                    button.left.textContent = ".user-trees-closed"
                    button.right.textContent = "Hol dir Datensätze vom Nutzer"
                    button.onclick = () => {
                      this.overlay("toolbox", overlay => {
                        overlay.info.textContent = "script.user-trees-closed"
                        const funnel = this.create("div/scrollable", overlay)
                        createIdTreesFunnel(funnel)
                        funnel.submit.onclick = async () => {
                          await this.verify("field-funnel", funnel)
                          const script = this.create("script", {id: funnel.idField.input.value, js: `await Helper.render("user-trees-closed", ${funnel.treesField.input.value}, ".${funnel.idField.input.value}")`})
                          if (!this.verifyIs("id/unique", script.id)) {
                            this.add("style/not-valid", funnel.idField.input)
                          }
                          this.add("id-onbody", script)
                        }
                      })
                    }
                  }
                }
              }

            })

          }

        }

      })



    }

    if (event === "community") {

      this.overlay("pop", communityOverlay => {
        communityOverlay.onlyClosedUser()
        const searchField = this.create("input/text", communityOverlay.content)
        searchField.input.placeholder = "Suche nach Alias"

        const flex = this.create("div/flex", communityOverlay.content)
        const allButton = this.render("text/link", "Alle", flex)
        allButton.onclick = () => send({type: "community"})

        const blockButton = this.render("text/link", "Blockiert", flex)
        blockButton.onclick = () => send({type: "blocked"})

        const communityDiv = this.create("info/loading", communityOverlay.content)

        let socket
        if (window.location.host === "localhost:9999") {
          socket = new WebSocket(`ws://${window.location.host}/`)
        } else {
          socket = new WebSocket(`wss://${window.location.host}/`)
        }
        communityOverlay.closeSocket(socket)
        function send(data) {
          socket.send(JSON.stringify(data))
        }
        socket.onopen = () => {
          send({type: "community"})
        }
        socket.onerror = (error) => {
          console.error('WebSocket error:', error)
          socket.close()
        }

        socket.addEventListener("message", ev => {
          const data = JSON.parse(ev.data)
          if (data.type === "blocked") {
            renderBlocked(data.blocked)
          }
          if (data.type === "community") {
            renderOpen(data.community)
          }
          if (data.type === "unblock") {
            renderBlocked(data.blocked)
          }
        })

        socket.addEventListener("close", () => {
          communityOverlay.remove()
        })

        function renderMessagesBox(community) {
          Helper.convert("parent/scrollable", communityDiv)
          communityDiv.style.padding = "8px"
          Helper.sort("flag-true", {flag: "highlight", array: community})
          for (let i = 0; i < community.length; i++) {
            const user = community[i]
            const box = Helper.render("user-box", user, communityDiv)
            box.onclick = () => {
              user.socket = socket
              Helper.overlay("messages", user)
            }
          }
        }

        function renderBlockedBox(community) {
          Helper.convert("parent/scrollable", communityDiv)
          communityDiv.style.padding = "8px"
          Helper.sort("flag-true", {flag: "highlight", array: community})
          for (let i = 0; i < community.length; i++) {
            const user = community[i]
            const box = Helper.render("user-box", user, communityDiv)
            box.created.textContent = `Blockiert seit: ${Helper.convert("millis/since", user.created)}`
            box.onclick = () => {
              Helper.overlay("pop", optionsOverlay => {
                {
                  const button = Helper.create("toolbox/left-right", optionsOverlay.content)
                  button.left.textContent = ".unblock"
                  button.right.textContent = "Entferne diesen Nutzer aus deiner Blockliste"
                  button.onclick = () => {
                    let message = "Möchtest du diesen Nutzer wirklich aus deiner Blockliste entfernen?"
                    if (user.alias) message = `Möchtest du ${user.alias} wirklich aus deiner Blockliste entfernen?`
                    const confirm = window.confirm(message)
                    if (confirm === true) {
                      send({type: "unblock", id: user.id})
                      let message = "Dieser Nutzer wurde erfolgreich aus deiner Blockliste entfernt."
                      if (user.alias) message = `${user.alias} wurde erfolgreich aus deiner Blockliste entfernt.`
                      window.alert(message)
                      optionsOverlay.remove()
                      send({type: "community-to", to: user.id})
                    }
                  }
                }
              })
            }
          }
        }

        function renderOpen(community) {
          if (Helper.verifyIs("array/empty", community)) {
            userNotFound()
            return
          }
          searchField.input.oninput = (ev) => {
            if (Helper.verifyIs("text/empty", ev.target.value)) {
              renderMessagesBox(community)
              return
            }
            const filtered = community.filter(it => it.alias && it.alias.toLowerCase().includes(ev.target.value.toLowerCase()))
            const highlighted = filtered.map(it => {
              const highlightedAlias = it.alias.replace(new RegExp(ev.target.value, 'i'), `<mark>${ev.target.value}</mark>`)
              return { ...it, alias: highlightedAlias }
            })
            renderMessagesBox(highlighted)
          }
          renderMessagesBox(community)
        }

        function renderBlocked(community) {
          if (Helper.verifyIs("array/empty", community)) {
            userNotFound()
            return
          }
          searchField.input.oninput = (ev) => {
            if (Helper.verifyIs("text/empty", ev.target.value)) {
              renderBlockedBox(community)
              return
            }
            const filtered = community.filter(it => it.alias && it.alias.toLowerCase().includes(ev.target.value.toLowerCase()))
            const highlighted = filtered.map(it => {
              const highlightedAlias = it.alias.replace(new RegExp(ev.target.value, 'i'), `<mark>${ev.target.value}</mark>`)
              return { ...it, alias: highlightedAlias }
            })
            renderBlockedBox(highlighted)
          }
          renderBlockedBox(community)
        }

        function userNotFound() {
          Helper.convert("parent/info", communityDiv)
          communityDiv.textContent = "Keine Mitglieder gefunden"
        }

      })
    }

    if (event === "conflicts") {

      return this.overlay("popup", overlay => {
        overlay.onlyClosedUser()
        overlay.appendChild(overlay.addButton)
        overlay.addButton.onclick = () => {
          this.overlay("popup", addOverlay => {
            const content = this.create("div/scrollable", addOverlay)
            const funnel = this.create("funnel/conflict", content)
            funnel.submit.onclick = () => {
              this.overlay("security", async securityOverlay => {
                const res = await this.request("/register/user/conflict/", {trigger: callback.created, environment: funnel.environment.input.value, reproduce: funnel.reproduce.input.value, expected: funnel.expected.input.value, actual: funnel.actual.input.value, visibility: funnel.visibility.input.value})
                if (res.status === 200) {
                  window.alert("Dein Konflikt wurde erfolgreich gespeichert.")
                  renderOpenConflicts()
                  overlay.remove()
                  addOverlay.remove()
                  securityOverlay.remove()
                } else {
                  window.alert("Fehler.. Bitte wiederholen.")
                  securityOverlay.remove()
                }
              })
            }
          })
        }
        const content = this.create("div/scrollable", overlay)

        this.render("text/h1", "Konflikte", content)
        const flexRow = this.create("div/flex", content)
        const allButton = this.render("text/link", "Alle", flexRow)
        const myButton = this.render("text/link", "Meine", flexRow)

        const conflictsDiv = this.create("div", content)

        function renderOpenConflicts() {
          Helper.request("/get/user/conflicts-open/").then(res => {
            if (res.status === 200) {
              const conflicts = JSON.parse(res.response)
              conflictsDiv.textContent = ""
              for (let i = 0; i < conflicts.length; i++) {
                const conflict = conflicts[i]
                const button = Helper.create("toolbox/left-right", conflictsDiv)
                button.left.textContent = Helper.convert("millis/dd.mm.yyyy hh:mm", conflict.created)
                button.right.textContent = conflict.visibility
              }
            }
          })
        }

        function renderClosedConflicts() {
          Helper.request("/get/user/conflicts-closed/").then(res => {
            if (res.status === 200) {
              const conflicts = JSON.parse(res.response)
              conflictsDiv.textContent = ""
              for (let i = 0; i < conflicts.length; i++) {
                const conflict = conflicts[i]
                const button = Helper.create("toolbox/left-right", conflictsDiv)
                button.left.textContent = Helper.convert("millis/dd.mm.yyyy hh:mm", conflict.created)
                button.right.textContent = conflict.visibility
              }
            }
          })
        }

        renderOpenConflicts()

        allButton.onclick = () => {
          renderOpenConflicts()
        }

        myButton.onclick = () => {
          renderClosedConflicts()
        }

      })
    }

    if (event === "contacts") {

      this.overlay("pop", async o1 => {
        o1.onlyClosedUser()
        o1.info.textContent = ".contacts"
        const content = o1.content
        const searchField = this.create("input/text", content)
        searchField.input.placeholder = "Filter nach E-Mail oder Notizen"
        const container = this.create("div/flex-row", content)
        container.style.justifyContent = "flex-start"
        const exportButton = this.render("text/link", "Exportieren", container)
        const importButton = this.render("text/link", "Importieren", container)
        importButton.onclick = () => {

          this.overlay("pop", o2 => {
            const funnel = o2.content
            const field = this.create("input/textarea", funnel)
            this.style(field.input, {fontFamily: "monospace", height: "55vh", fontSize: "8px"})
            field.input.setAttribute("required", "true")
            this.verify("input/value", field.input)
            field.input.placeholder = `[
  {
    email: "neuer@kontakt.de", // id
    alias: "Kontakt Name",  // optional
    birthday: "1999-03-21", // optional
    status: "kontakt status", // optional
    notes: "Kontakt Notizen", // optional
    phone: "+123456789", // optional
    website: "https://www.kontakt-webseite.de/" // optional
  },

  .
  .

]
            `
            const submit = this.create("toolbox/action", funnel)
            submit.textContent = "Kontakte jetzt importieren"
            submit.onclick = async () => {
              await this.verify("input/value", field.input)
              try {
                const contacts = JSON.parse(field.input.value)
                if (this.verifyIs("array/empty", contacts)) throw new Error("contacts is empty")
                for (let i = 0; i < contacts.length; i++) {
                  const contact = contacts[i]
                  if (!contact.email) {
                    throw new Error("'contact.email' is missing")
                  }
                }
                this.overlay("lock", async o3 => {
                  const res = await this.request("/register/contacts/import/", {contacts})
                  if (res.status === 200) {
                    window.alert("Deine Kontakte wurden erfolgreich importiert.")
                    await getAndRenderContactsClosed()
                    o2.remove()
                    o3.remove()
                  }
                })
              } catch (error) {
                console.error(error)
                window.alert("Deine Kontaktliste ist in einem ungültigen Format.")
                this.add("style/not-valid", field.input)
              }


            }
          })
        }
        const contactsDiv = this.create("info/loading", content)
        function concatEmailAndNotes(array, key) {
          return array.map(it => {
            if (it.email && it.notes) {
              return { ...it, [key]: `${it.email}<br>${it.notes}` }
            } else {
              return { ...it, [key]: it.email }
            }
          })
        }
        const websiteIcon = await this.convert("path/icon", "/public/website.svg")
        const phoneIcon = await this.convert("path/icon", "/public/phone-out.svg")
        const emailIcon = await this.convert("path/icon", "/public/email-out.svg")
        async function renderContactButtons(contacts, parent, query) {

          const numerology = Helper.fn("numerology")
          const fragment = document.createDocumentFragment()
          Helper.convert("parent/scrollable", parent)
          for (let i = 0; i < contacts.length; i++) {
            const contact = contacts[i]
            const contactButton = Helper.create("toolbox/left-right", fragment)
            Helper.style(contactButton.left, {width: "55%", margin: "21px"})
            if (contact.birthday){
              const birthdate = new Date(contact.birthday)
              const lifepath = numerology.dateToLifePath(birthdate)
              const div = Helper.div("flex align center circle bg-green w34 h34", contactButton.left)
              div.textContent = lifepath
            }
            if (contact.alias) {
              const alias = Helper.div("fs-21")
              alias.textContent = contact.alias
              Helper.render("node", alias, contactButton.left)
            }
            const query = Helper.div("fs-13 mtb8")
            Helper.render("node", query, contactButton.left)
            if (contact.query) {
              let text = await Helper.convert("text/purified", contact.query)
              query.innerHTML = text
            } else {
              query.textContent = contact.email
            }

            if (contact.website) {
              const clone = websiteIcon.cloneNode(true)
              clone.style.padding = "5px"
              contactButton.right.appendChild(clone)
              Helper.add("outline-hover", clone)
              clone.onclick = ev => {
                ev.stopPropagation()
                window.open(contact.website, "_blank")
                openNotes(contact)
              }
            }
            if (contact.phone) {
              const clone = phoneIcon.cloneNode(true)
              clone.style.padding = "5px"
              contactButton.right.appendChild(clone)
              Helper.add("outline-hover", clone)
              clone.onclick = ev => {
                ev.stopPropagation()
                window.location.href = `tel:${contact.phone}`
                openNotes(contact)
              }
            }
            if (contact.email) {
              const clone = emailIcon.cloneNode(true)
              clone.style.padding = "5px"
              contactButton.right.appendChild(clone)
              Helper.add("outline-hover", clone)
              clone.onclick = ev => {
                ev.stopPropagation()
                window.location.href = `mailto:${contact.email}`
                openNotes(contact)
              }
            }

            function openNotes(contact, o){

              Helper.overlay("pop", o1 => {
                o1.info.textContent = contact.email
                const funnel = o1.content
                const notes = Helper.create("input/textarea", funnel)
                notes.input.placeholder = `next:email(Meine Notizen)
next:tel(Meine Notizen)
next:webcall(Meine Notizen)
                `
                Helper.style(notes.input, {height: "55vh", fontSize: "13px"})
                notes.input.style.height = "55vh"
                if (contact.notes) {
                  notes.input.value = contact.notes
                }
                const submit = Helper.create("toolbox/action", funnel)
                submit.textContent = "Notizen jetzt speichern"
                submit.onclick = async () => {

                  await Helper.verify("input/value", notes.input)
                  Helper.overlay("lock", async o2 => {
                    const res = await Helper.request("/register/contacts/notes/", {created: contact.created, notes: notes.input.value})
                    if (res.status === 200) {
                      window.alert("Notizen erfolgreich gespeichert.")
                      await getAndRenderContactsClosed()
                      o1.remove()
                      if (o) o.remove()
                    } else {
                      window.alert("Fehler.. Bitte wiederholen.")
                    }
                    o2.remove()
                  })
                }
              })
            }

            contactButton.onclick = () => {
              Helper.overlay("pop", async o2 => {
                o2.info.textContent = contact.email
                const buttons = o2.content
                function createButton(left, right){

                  const button = Helper.create("toolbox/left-right", buttons)
                  button.left.textContent = left
                  button.right.textContent = right
                  return button
                }
                function registerKey(it, o, object){

                  const key = Object.keys(object)[0]
                  Helper.overlay("lock", async o4 => {
                    const res = await Helper.request(`/register/contacts/${key}/`, {created: it.created, [key]: object[key]})
                    if (res.status === 200) {
                      window.alert("Daten erfolgreich gespeichert.")
                      await getAndRenderContactsClosed()
                      o.remove()
                      o2.remove()
                    } else {
                      window.alert("Fehler.. Bitte wiederholen.")
                    }
                    o4.remove()
                  })
                }
                {
                  const button = createButton(".email", "Aktualisiere die E-Mail Adresse deines Kontakts")
                  button.onclick = () => {

                    Helper.overlay("pop", o3 => {
                      o3.info.textContent = contact.email
                      const funnel = o3.content
                      const email = Helper.create("input/email", funnel)
                      if (contact.email) {
                        email.input.value = contact.email
                      }
                      Helper.verify("input/value", email.input)
                      const submit = Helper.create("toolbox/action", funnel)
                      submit.textContent = "E-Mail jetzt speichern"
                      submit.onclick = async () => {
                        await Helper.verify("input/value", email.input)
                        registerKey(contact, o3, {email: email.input.value})
                      }
                    })
                  }
                }
                {
                  const button = createButton(".alias", "Gib deinem Kontakt einen alternativen Namen")
                  button.onclick = () => {

                    Helper.overlay("pop", o3 => {
                      o3.info.textContent = contact.email
                      const funnel = o3.content
                      const alias = Helper.create("input/alias", funnel)
                      if (contact.alias) {
                        alias.input.value = contact.alias
                      }
                      Helper.verify("input/value", alias.input)
                      const submit = Helper.create("toolbox/action", funnel)
                      submit.textContent = "Alias jetzt speichern"
                      submit.onclick = async () => {
                        await Helper.verify("input/value", alias.input)
                        registerKey(contact, o3, {alias: alias.input.value})
                      }

                    })
                  }
                }
                {
                  const button = createButton(".character", "Erfahre mehr über deinen Kontakt")
                  button.onclick = () => {

                    const dateField = Helper.create("field/date")
                    dateField.label.textContent = "Gebe das Geburtsdatum deines Kontakts ein"
                    dateField.input.placeholder = "yyyy-mm-dd"
                    Helper.add("outline-hover", dateField.input)
                    let birthday
                    if (contact.birthday) {
                      const split = contact.birthday.split("T")
                      dateField.input.value = split[0]
                      birthday = split[0]
                    }
                    dateField.input.setAttribute("required", "true")
                    Helper.verify("input/value", dateField.input)
                    Helper.overlay("popup", overlay => {
                      overlay.info.textContent = contact.email
                      dateField.input.oninput = async () => {
                        await Helper.verify("input/value", dateField.input)
                        const date = new Date(dateField.input.value)
                        Helper.overlay("security", async securityOverlay => {
                          const res = await Helper.request("/register/contacts/birthday/", {created: contact.created, birthday: date.toISOString()})
                          if (res.status === 200) {
                            window.alert("Geburtsdatum erfolgreich gespeichert.")
                            await getAndRenderContactsClosed(parent)
                            overlay.remove()
                            o2.remove()
                            securityOverlay.remove()
                          } else {
                            window.alert("Fehler.. Bitte wiederholen.")
                            securityOverlay.remove()
                          }
                        })
                      }
                      const content = Helper.create("div/scrollable", overlay)
                      content.style.marginTop = "21px"
                      if (!Helper.verifyIs("text/empty", birthday)) {
                        if (contact.alias) {
                          Helper.render("text/hr", `Numerologie von ${contact.alias}`, content)
                        } else {
                          Helper.render("text/hr", `Numerologie von ${contact.email}`, content)
                        }
                        const date = new Date(birthday)
                        numerology.renderBirthDate(date, content)
                        numerology.renderBirthName(contact.alias, content)
                        const toLoginButton = Helper.render("login-button", "https://www.get-your.de/entwicklung/numerologie/login/", content)
                        toLoginButton.left.textContent = ".login"
                        toLoginButton.right.textContent = "Jetzt schnell und einfach anmelden"
                        content.appendChild(dateField)
                        function removeFieldsAndButtons() {
                          dateField.remove()
                          shareButton.remove()
                          downloadHtmlButton.remove()
                        }
                        function addFieldsAndButtons() {
                          content.appendChild(dateField)
                          content.appendChild(shareButton)
                          content.appendChild(downloadHtmlButton)
                        }
                        const downloadHtmlButton = Helper.create("toolbox/left-right", content)
                        downloadHtmlButton.left.textContent = ".download"
                        downloadHtmlButton.right.textContent = "Lade die Numerologie Rechnung als .html Datei herunter"
                        downloadHtmlButton.onclick = () => {
                          removeFieldsAndButtons()
                          Helper.downloadFile(content.outerHTML, "text/html")
                          addFieldsAndButtons()
                        }
                        const shareButton = Helper.create("toolbox/left-right", content)
                        shareButton.left.textContent = ".share"
                        shareButton.right.textContent = "Sende die Numerologie Rechnung an dein Netzwerk"
                        shareButton.onclick = async () => {

                          if (navigator.share) {
                            removeFieldsAndButtons()
                            try {
                              const blob = new Blob([content.outerHTML], { type: 'text/html' })
                              const file = new File([blob], `numerologie-von-${contact.email}.html`, { type: 'text/html' })
                              await navigator.share({
                                files: [file]
                              })
                              console.log("Numerology share successfully")
                            } catch (err) {
                              console.error(err)
                            }
                            addFieldsAndButtons()
                          } else {
                            window.alert("Dein Browser unterstützt diese Funktion leider nicht. Versuche es mit einem anderen Browser.")
                          }
                        }
                      } else {
                        content.appendChild(dateField)
                      }
                    })
                  }
                }

                {
                  const button = createButton(".status", "Gib deinem Kontakt einen Status")
                  button.onclick = () => {

                    Helper.overlay("pop", o3 => {
                      o3.info.textContent = contact.email
                      const funnel = o3.content
                      const status = Helper.create("input/text", funnel)
                      status.input.placeholder = "Status"
                      status.input.setAttribute("required", "true")
                      if (contact.status) {
                        status.input.value = contact.status
                      }
                      Helper.verify("input/value", status.input)
                      const submit = Helper.create("toolbox/action", funnel)
                      submit.textContent = "Status jetzt speichern"
                      submit.onclick = async () => {
                        await Helper.verify("input/value", status.input)
                        registerKey(contact, o3, {status: status.input.value})
                      }
                    })
                  }
                }

                {
                  const button = createButton(".notes", "Mache dir Notizen zu deinem Kontakt")
                  button.onclick = () => {

                    openNotes(contact, o2)
                  }
                }

                {
                  const button = createButton(".phone", "Gib die Telefon Nummer deines Kontakts ein")
                  button.onclick = () => {

                    Helper.overlay("pop", o3 => {
                      o3.info.textContent = contact.email
                      const funnel = o3.content
                      const phone = Helper.create("input/phone", funnel)
                      if (contact.phone) {
                        phone.input.value = contact.phone
                      }
                      Helper.verify("input/value", phone.input)
                      const submit = Helper.create("toolbox/action", funnel)
                      submit.textContent = "Nummer jetzt speichern"
                      submit.onclick = async () => {
                        await Helper.verify("input/value", phone.input)
                        registerKey(contact, o3, {phone: phone.input.value})
                      }
                    })
                  }
                }

                {
                  const button = createButton(".website", "Gib die Webseite deines Kontakts ein")
                  button.onclick = () => {

                    Helper.overlay("pop", o3 => {
                      o3.info.textContent = contact.email
                      const funnel = o3.content
                      const website = Helper.create("input/url", funnel)
                      if (contact.website) {
                        website.input.value = contact.website
                      }
                      Helper.verify("input/value", website.input)
                      const submit = Helper.create("toolbox/action", funnel)
                      submit.textContent = "Webseite jetzt speichern"
                      submit.onclick = async () => {
                        await Helper.verify("input/value", website.input)
                        registerKey(contact, o3, {website: website.input.value})
                      }
                    })
                  }
                }

                {
                  const res = await Helper.request("/verify/user/expert/")
                  if (res.status === 200) {
                    const button = createButton(".promote", "Erhalte Zugang zu unendlich vielen Möglichkeiten")
                    button.onclick = () => {
                      Helper.overlay("popup", async overlay => {
                        if (contact.alias) {
                          Helper.render("text/h1", `Promote ${contact.email}`, overlay)
                        } else {
                          Helper.render("text/h1", `Promote ${contact.email}`, overlay)
                        }
                        const funnel = Helper.create("div/scrollable", overlay)
                        const searchField = Helper.create("field/text", funnel)
                        searchField.label.textContent = "Suche nach Text im Pfad"
                        searchField.input.placeholder = "/experte/plattform/pfad"
                        searchField.style.margin = "0 34px"
                        Helper.verify("input/value", searchField.input)
                        Helper.add("outline-hover", searchField.input)
                        const pathField = await Helper.create("field/open-expert-values-path-select", funnel)
                        const originalOptions = Array.from(pathField.input.options).map(option => option.cloneNode(true))
                        searchField.input.oninput = (ev) => {
                          const searchTerm = ev.target.value.toLowerCase()
                          const options = originalOptions.map(it => it.value)
                          const filtered = options.filter(it => it.toLowerCase().includes(searchTerm))
                          pathField.input.add(filtered)
                        }
                        pathField.input.style.height = "55vh"
                        pathField.input.setAttribute("multiple", "true")
                        for (let i = 0; i < pathField.input.options.length; i++) {
                          const option = pathField.input.options[i]
                          option.selected = false
                        }
                        pathField.input.oninput = async () => {
                          const fieldFunnel = await Helper.convert("path/field-funnel", pathField.input.value)
                          if (fieldFunnel.id) {
                            Helper.overlay("popup", async overlay => {
                              overlay.info.textContent = contact.email + "." + fieldFunnel.id
                              const create = Helper.create("button/left-right", overlay)
                              create.left.textContent = ".create"
                              create.right.textContent = Helper.convert("text/capital-first-letter", fieldFunnel.id) + " definieren"
                              create.onclick = () => {
                                Helper.overlay("popup", async overlay => {
                                  Helper.create("header/info", overlay).textContent = contact.email + "." + fieldFunnel.id + ".create"
                                  overlay.append(fieldFunnel)
                                  Helper.verifyIs("field-funnel/valid", fieldFunnel)
                                  Helper.add("outline-hover/field-funnel", fieldFunnel)
                                  const submitButton = fieldFunnel.querySelector(".submit-field-funnel-button")
                                  if (submitButton) {
                                    submitButton.textContent = `${Helper.convert("text/capital-first-letter", fieldFunnel.id)} jetzt speichern`
                                    submitButton.onclick = async () => {
                                      const path = pathField.input.value
                                      await Helper.verify("field-funnel", fieldFunnel)
                                      const map = await Helper.convert("field-funnel/map", fieldFunnel)
                                      Helper.overlay("security", async securityOverlay => {
                                        const register = {}
                                        register.email = contact.email
                                        register.map = map
                                        register.path = path
                                        register.id = fieldFunnel.id
                                        const res = await Helper.request("/register/location/email-expert", register)
                                        if (res.status === 200) {
                                          window.alert("Daten erfolgreich gespeichert.")
                                          await Helper.render("location-list/node/email-expert", {tag: fieldFunnel.id, email: contact.email, path: pathField.input.value}, locationList)
                                          securityOverlay.remove()
                                        } else {
                                          window.alert("Fehler.. Bitte wiederholen.")
                                          securityOverlay.remove()
                                        }
                                      })
                                    }
                                  } else {
                                    window.alert("Field Funnel besitzt keinen Button mit der Klasse 'submit-field-funnel-button'")
                                  }
                                })
                              }
                              if (contact.alias) {
                                Helper.render("text/hr", Helper.convert("text/capital-first-letter", fieldFunnel.id) + " von " + contact.alias, overlay)
                              } else {
                                Helper.render("text/hr", Helper.convert("text/capital-first-letter", fieldFunnel.id) + " von " + contact.email, overlay)
                              }
                              const locationList = Helper.create("info/loading", overlay)
                              await Helper.render("location-list/node/email-expert", {tag: fieldFunnel.id, email: contact.email, path: pathField.input.value}, locationList)
                            })
                          }
                        }
                      })
                    }
                  }
                }

                {
                  const button = createButton(".remove", "Kontakt entfernen")
                  button.onclick = () => {

                    const confirm = window.confirm("Möchtest du deinen Kontakt wirklich entfernen?")
                    if (confirm === true) {
                      Helper.overlay("lock", async o3 => {
                        const res = await Helper.request("/remove/user/contacts/", {created: contact.created})
                        if (res.status === 200) {
                          window.alert("Kontakt erfolgreich entfernt.")
                          await getAndRenderContactsClosed()
                          o2.remove()
                        } else {
                          window.alert("Fehler.. Bitte wiederholen.")
                        }
                        o3.remove()
                      })
                    }
                  }
                }
              })
            }
          }

          parent?.appendChild(fragment)
        }
        async function getAndRenderContactsClosed(){

          Helper.convert("parent/loading", contactsDiv)
          const res = await Helper.request("/get/user/contacts/")
          let filtered
          if (res.status === 200) {
            const contacts = JSON.parse(res.response)
            exportButton.onclick = () => {
              if (filtered) {
                Helper.convert("text/clipboard", JSON.stringify(filtered))
                .then(() => window.alert("JavaScript Kontaktliste wurde erfolgreich in die Zwischenablage gespeichert."))
              } else {
                Helper.convert("text/clipboard", JSON.stringify(contacts))
                .then(() => window.alert("JavaScript Kontaktliste wurde erfolgreich in die Zwischenablage gespeichert."))
              }
            }
            searchField.input.oninput = async ev => {
              const query = ev.target.value
              if (!Helper.verifyIs("text/empty", query)) {
                const prepared = concatEmailAndNotes(contacts, "query")
                const highlighted = Helper.sort("query", {array: prepared, query, filter: "query"})
                await renderContactButtons(highlighted, contactsDiv)
              } else {
                await renderContactButtons(contacts, contactsDiv)
              }
            }
            await renderContactButtons(contacts, contactsDiv)
          } else {
            Helper.convert("parent/info", contactsDiv)
            parent.textContent = "Keine Kontakte gefunden"
          }
        }
        getAndRenderContactsClosed()
        o1.append(o1.addButton)
        o1.addButton.onclick = () => {

          this.overlay("pop", o2 => {
            const funnel = o2.content
            this.render("text/h1", "Neuer Kontakt", funnel)
            const email = this.create("input/email", funnel)
            const submit = this.create("toolbox/action", funnel)
            submit.textContent = "Kontakt jetzt speichern"
            submit.onclick = async () => {
              await this.verify("input/value", email.input)
              this.overlay("lock", async o3 => {
                const res = await this.request("/register/contacts/email/", {email: email.input.value})
                if (res.status === 200) {
                  window.alert("Kontakt erfolgreich gespeichert.")
                  await getAndRenderContactsClosed()
                  o2.remove()
                } else {
                  window.alert("Fehler.. Bitte wiederholen.")
                }
                o3.remove()
              })
            }
          })
        }
      })
    }

    if (event === "html-creator") {

      const overlay = document.createElement("div")
      overlay.classList.add("overlay")
      overlay.style.height = "55vh"
      overlay.style.overscrollBehavior = "none"
      overlay.style.width = "100%"
      overlay.style.zIndex = "99999999999999"
      overlay.style.position = "fixed"
      overlay.style.bottom = "0"
      overlay.style.left = "0"
      overlay.style.background = this.colors.light.background
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        overlay.style.background = this.colors.dark.background
      }
      overlay.style.display = "flex"
      overlay.style.flexDirection = "column"
      overlay.style.opacity = 0
      this.removeOverlayButton(overlay)
      if (callback) callback(overlay)
      document.body.append(overlay)
      this.animate("fade-up", overlay)
      return overlay
    }

    if (event === "messages") {

      const user = callback

      this.overlay("pop", overlay => {
        overlay.onlyClosedUser()
        if (user.alias) overlay.info.textContent = user.alias
        const funnel = this.create("div/flex-between", overlay.content)
        funnel.style.margin = "0"
        const messageField = this.create("input/textarea", funnel)
        messageField.style.flex = "1 1 0"
        messageField.input.style.fontSize = "13px"
        messageField.input.style.height = "144px"
        messageField.input.placeholder = "Nachricht"
        messageField.input.setAttribute("required", "true")
        messageField.input.setAttribute("accept", "text/length")
        messageField.input.maxLength = "987"
        messageField.input.oninput = () => this.verify("input/value", messageField.input)
        this.verify("input/value", messageField.input)
        this.on("shift+enter", messageField.input, async () => await submitMessage())
        const submit = this.create("toolbox/action", funnel)
        submit.textContent = "↑"
        this.style(submit, {borderRadius: "50%", width: "55px", height: "34px", fontSize: "21px"})
        async function submitMessage() {
          await Helper.verify("input/value", messageField.input)
          send({type: "message", message: messageField.input.value, to: user.created})
          messageField.input.value = ""
          Helper.add("style/not-valid", messageField.input)
          await Helper.add("ms/timeout", 610)
          send({type: "community"})
          await Helper.add("ms/timeout", 610)
          send({type: "community-to", to: user.created})
        }
        submit.onclick = async () => await submitMessage()
        const flex = this.create("div/flex", overlay.content)
        flex.style.marginTop = "0"
        const blockButton = this.render("text/link", "Nutzer blockieren", flex)
        blockButton.onclick = async () => {
          let message = `Möchtest du wirklich diesen Nutzer blockieren?`
          if (user.alias) message = `Möchtest du wirklich ${user.alias} blockieren?`
          const confirm = window.confirm(message)
          if (confirm === true) {
            send({type: "block", id: user.created})
            await this.add("ms/timeout", 610)
            send({type: "community-to", to: user.created})
          }
        }
        const conflictButton = this.render("text/link", "Konflikt melden", flex)
        conflictButton.onclick = () => this.overlay("conflicts", user)
        const addTemplate = this.render("text/link", "Template einfügen", flex)
        addTemplate.onclick = () => {
          this.overlay("select-template", template => {
            messageField.input.value = template
            this.verify("input/value", messageField.input)
          })
        }
        const removeMessagesButton = this.render("text/link", "Meine Nachrichten entfernen", flex)
        removeMessagesButton.onclick = () => {
          send({type: "remove-messages", to: user.created})
        }

        const chatDiv = this.create("div", overlay.content)

        let socket
        if (user.socket) {
          socket = user.socket
          send({type: "chat", id: user.created})
        } else {
          if (window.location.host === "localhost:9999") {
            socket = new WebSocket(`ws://${window.location.host}/`)
          } else {
            socket = new WebSocket(`wss://${window.location.host}/`)
          }
          overlay.closeSocket(socket)
          socket.onopen = () => {
            send({type: "chat", id: user.created})
          }
          socket.onerror = (error) => {
            console.error('WebSocket error:', error)
            socket.close()
          }
        }

        socket.addEventListener("close", () => {
          overlay.remove()
        })

        socket.addEventListener("message", async ev => {
          const data = JSON.parse(ev.data)
          if (data.type === "block") {
            send({type: "community"})
            let message = `Der Nutzer wurde erfolgreich blockiert.`
            if (user.alias) message = `Der Nutzer ${user.alias} wurde erfolgreich blockiert.`
            window.alert(message)
            overlay.remove()
          }
          if (data.type === "chat") {
            chatDiv.textContent = ""
            chatDiv.removeAttribute("style")
            chatDiv.style.display = "flex"
            chatDiv.style.flexDirection = "column"
            this.style(chatDiv, {display: "flex", flexDirection: "column", fontFamily: "sans-serif", wordBreak: "break-word", margin: "0 34px"})
            for (let i = 0; i < data.chat.length; i++) {
              const message = data.chat[i]
              const box = this.create("box", chatDiv)
              this.on("click", box, () => {
                messageField.input.value = message.body
                messageField.scrollIntoView({behavior: "smooth"})
                this.add("style/valid", messageField.input)
                messageField.input.focus()
              })
              box.style.whiteSpace = 'pre-wrap'
              box.textContent = message.body
              this.style(box, {width: "auto", maxWidth: "55%", flexShrink: "0", margin: "8px 0"})
              if (message.to === user.created) {
                box.style.alignSelf = "flex-end"
                this.convert("parent/light", box)
              } else {
                box.style.alignSelf = "flex-start"
              }
            }
          }
          if (data.type === "message") {
            send({type: "chat", id: user.created})
          }
          if (data.type === "remove-messages") {
            send({type: "chat", id: user.created})
          }
        })

        function send(data) {
          socket.send(JSON.stringify(data))
        }
      })
    }

    if (event === "toolbox") {

      const overlay = this.create("div/overlay")
      overlay.removeOverlayButton = this.removeOverlayButton(overlay)
      overlay.removeOverlayButton.removeAttribute("class")
      overlay.removeOverlayButton.onclick = () => overlay.remove()
      this.add("outline-hover", overlay.removeOverlayButton)
      overlay.info = this.create("header/info", overlay)
      overlay.style.opacity = 0
      if (callback) callback(overlay)
      document.body.append(overlay)
      this.animate("fade-up", overlay)
      return overlay
    }

    if (event === "tools") {

      if (!callback) callback = {}
      return this.overlay("toolbox", async overlay => {
        if (callback.save === true) overlay.registerHtmlButton = this.registerHtmlButton(overlay)

        const buttons = this.create("div/scrollable", overlay)

        {
          const button = this.create("toolbox/left-right", buttons)
          button.left.textContent = "convert.text"
          button.right.textContent = "Mehr Infos"
          this.add("outline-hover", button.right)
          button.right.onclick = (ev) => {
            ev.stopPropagation()
            this.overlay("popup", overlay => {
              const content = this.create("div/scrollable", overlay)
              this.render("text/h3", "Konvertiere Texte schnell und einfach", content)
            })
          }
          button.onclick = () => {
            this.overlay("popup", overlay => {
              const content = this.create("div/scrollable", overlay)

              function createInputField(placeholder) {
                const field = Helper.create("input/textarea", content)
                field.input.style.fontSize = "13px"
                field.input.placeholder = placeholder
                field.input.setAttribute("required", "true")
                Helper.verify("input/value", field.input)
                return field
              }
              {
                const inputField = createInputField("Entferne alle JavaScript Kommentare (//)")
                inputField.input.oninput = () => {
                  inputField.input.value = this.remove("//", inputField.input.value)
                  this.verify("input/value", inputField.input)
                }
              }
              {
                const inputField = createInputField("Entferne alle leeren Zeilen (\\n)")
                inputField.input.oninput = () => {
                  inputField.input.value = this.remove("\n", inputField.input.value)
                  this.verify("input/value", inputField.input)
                }
              }
              {
                const inputField = createInputField("Entferne alle Semicolon (;)")
                inputField.input.oninput = () => {
                  inputField.input.value = this.remove(";", inputField.input.value)
                  this.verify("input/value", inputField.input)
                }
              }
              {
                const field = createInputField("Konvertiere (text/line)")
                field.input.oninput = () => {
                  field.input.value = this.convert("text/line", field.input.value)
                  this.verify("input/value", field.input)
                }
              }
              {
                const inputField = createInputField("Konvertiere (tag/Text)")
                inputField.input.oninput = () => {
                  inputField.input.value = this.convert("tag/capital-first-letter", inputField.input.value)
                  this.verify("input/value", inputField.input)
                }
              }
              {
                const inputField = createInputField("Konvertiere (text/tag)")
                inputField.input.oninput = () => {
                  inputField.input.value = this.convert("text/tag", inputField.input.value)
                  this.verify("input/value", inputField.input)
                }
              }
              {
                const inputField = createInputField("Konvertiere (millis/since)")
                inputField.input.oninput = () => {
                  inputField.input.value = this.convert("millis/since", inputField.input.value)
                  this.verify("input/value", inputField.input)
                }
              }
              {
                const field = createInputField("Konvertiere HTML Dokumente zu Inline CSS (doc/inline)")
                field.input.oninput = async () => {
                  const doc = this.convert("text/doc", field.input.value)
                  const inline = this.convert("doc/inline", doc)
                  field.input.value = inline.documentElement.outerHTML
                  this.verify("input/value", field.input)
                }
              }
            })
          }
        }

        {
          const button = this.create("toolbox/left-right", buttons)
          button.left.textContent = "document.backup"
          button.right.textContent = "Lade dein HTML Dokument herunter"
          button.onclick = async ev => await this.downloadFile(document.documentElement.outerHTML, "text/html")
        }

        {
          const button = this.create("toolbox/left-right", buttons)
          button.left.textContent = "document.children"
          button.right.textContent = "Dokumenten Inhalt"
          button.addEventListener("click", () => {
            this.overlay("children", {node: document.documentElement, type: callback.type, info: ".children"})
          })
        }

        {
          const button = this.create("toolbox/left-right", buttons)
          button.left.textContent = "document.copy"
          button.right.textContent = "Aktuelles Dokument kopieren"
          button.onclick = () => {
            this.convert("text/clipboard", document.documentElement.outerHTML)
            .then(() => window.alert("Dokument erfolgreich in die Zwischenablage kopiert."))
          }
        }

        {
          const button = this.create("toolbox/left-right", buttons)
          button.left.textContent = "document.designMode"
          if (document.designMode === "on") {
            const green = this.create("div/green-flag", button.right)
            green.textContent = "on"
          } else {
            const red = this.create("div/red-flag", button.right)
            red.textContent = "off"
          }
          button.onclick = () => {
            this.convert("doc/design-mode")
            overlay.remove()
          }
        }

        if (callback.type === "expert") {
          const button = this.create("toolbox/left-right", buttons)
          button.left.textContent = "document.write"
          button.right.textContent = "Aktuelles Dokument ersetzen"
          button.right.textContent = "Mehr Infos"
          this.add("outline-hover", button.right)
          button.right.addEventListener("click", ev => {
            ev.stopPropagation()
            this.overlay("popup", overlay => {
              const content = this.create("div/scrollable", overlay)
              this.render("text/h3", "Aktuelles Dokument ersetzen", content)
              const a = document.createElement("a")
              a.style.margin = "0 34px"
              a.href = "https://developer.mozilla.org/en-US/docs/Web/API/Document/write"
              a.textContent = "Mozilla Developer Network write() Methode"
              a.target = "_blank"
              this.add("outline-hover", a)
              this.convert("dark-light", a)
              content.appendChild(a)
            })
          })
          button.addEventListener("click", () => {

            this.overlay("toolbox", overlay => {
              const funnel = this.create("div/scrollable", overlay)
              const htmlField = this.create("input/textarea", funnel)
              htmlField.input.style.fontFamily = "monospace"
              htmlField.input.style.fontSize = "13px"
              htmlField.input.style.height = "55vh"
              htmlField.input.placeholder = `<html>..</html>`
              this.verify("input/value", htmlField.input)
              const button = this.create("toolbox/action", funnel)
              button.textContent = "Dokument jetzt ersetzen"
              button.addEventListener("click", async () => {
                const text = await this.convert("text/purified", htmlField.input.value)
                const confirm = window.confirm("Achtung! Diese Funktion wird dein aktuelles HTML Dokument mit deinem neuen HTML Import ersetzen. Der Inhalt deines aktuellen Dokuments wird unwideruflich gelöscht, sobald du deine Werteinheit abspeicherst.\n\nMöchtest du dein aktuelles HTML Dokument wirklich ersetzen?")
                if (confirm === true) {
                  document.open()
                  document.write(text)
                  document.close()
                  await this.add("script/toolbox-getter")
                  this.remove("overlays")
                }
              })
            })
          })
        }

        {
          const button = this.create("toolbox/left-right", buttons)
          button.left.textContent = "navigator.share"
          button.right.textContent = "Sende diese URL an dein Netzwerk"
          button.onclick = async () => {
            try {
              await navigator.share({
                url: window.location.href
              })
              console.log("URL share successfully");
            } catch (err) {
              console.error(err)
            }
          }
        }

        {
          const button = this.create("toolbox/left-right", buttons)
          button.left.textContent = ".open"
          button.right.textContent = "Ein Platz für Open Innovation"
          button.onclick = () => {

            this.overlay("pop", o2 => {

              function createIntegration(type, integrations) {

                const button = Helper.create("toolbox/left-right", o2.content)
                button.left.textContent = type
                button.addEventListener("click", () => {
                  integrations.sort((a, b) => a.name.localeCompare(b.name))
                  Helper.overlay("pop", o3 => {
                    const content = o3.content
                    for (let i = 0; i < integrations.length; i++) {
                      const integration = integrations[i]
                      const button = Helper.create("toolbox/left-right", content)
                      button.left.textContent = integration.name
                      button.right.remove()
                      button.onclick = () => window.open(integration.url, "_blank")
                    }
                  })
                })
              }

              const aiIntegrations = [
                {name: "blackbox.ai", url: "https://www.blackbox.ai/"},
                {name: "deepai.org", url: "https://www.deepai.org/chat/text-generator"},
                {name: "futurepedia.io", url: "https://www.futurepedia.io"},
                {name: "textsynth.com", url: "https://www.textsynth.com/completion.html"},
              ]
              createIntegration(".ai", aiIntegrations)

              const mailIntegrations = [
                {name: "yopmail.com", url: "https://www.yopmail.com/"},
              ]
              createIntegration(".mail", mailIntegrations)

              const mathIntegrations = [
                {name: "wolframalpha.com", url: "https://www.wolframalpha.com/"},
                {name: "integral-calculator.com", url: "https://www.integral-calculator.com/"},
                {name: "gamma.sympy.org", url: "https://gamma.sympy.org/"},
                {name: "calculatorsoup.com", url: "https://www.calculatorsoup.com/"},
                {name: "mathway.com", url: "https://www.mathway.com/"},
              ]
              createIntegration(".math", mathIntegrations)

              const musicIntegrations = [
                {name: "web-audio-api", url: "https://webaudio.github.io/web-audio-api/"},
                {name: "hydrogen-music.org", url: "http://hydrogen-music.org/"},
                {name: "freesound.org", url: "https://freesound.org/"},
                {name: "tidalcycles.org", url: "https://tidalcycles.org/"},
              ]
              createIntegration(".music", musicIntegrations)

              const regexIntegrations = [
                { name: "debuggex.com", url: "https://www.debuggex.com/" },
                { name: "regex101.com", url: "https://regex101.com/" },
                { name: "regexr.com", url: "https://regexr.com/" },
                { name: "regextester.com", url: "https://www.regextester.com/" },
              ]
              createIntegration(".regex", regexIntegrations)

              const svgIntegrations = [
                {name: "svgviewer.dev", url: "https://www.svgviewer.dev/"},
                {name: "svg-path-editor", url: "https://yqnn.github.io/svg-path-editor/"},
              ]
              createIntegration(".svg", svgIntegrations)

              const uxIntegrations = [
                {name: "figma.com", url: "https://www.figma.com/"},
                {name: "penpot.app", url: "https://penpot.app/"},
                {name: "mockflow.com", url: "https://www.mockflow.com/"},
                {name: "canva.com", url: "https://www.canva.com/"},
                {name: "draw.io", url: "https://app.diagrams.net/"},
                {name: "uizard.io", url: "https://uizard.io/"},
                {name: "excalidraw.com", url: "https://excalidraw.com/"},
                {name: "figjam.com", url: "https://www.figma.com/figjam/"},
                {name: "moqups.com", url: "https://moqups.com/"},
                {name: "uxpin.com", url: "https://www.uxpin.com/"},
                {name: "wireframe.cc", url: "https://wireframe.cc/"},
              ]
              createIntegration(".ux", uxIntegrations)
            })
          }
        }

        {
          async function recordAudioScreen() {

            try {
              let mediaRecorder
              let chunks = []
              let timerInterval
              let seconds = 0
              const controls = Helper.create("div")
              controls.className = "controls"
              Helper.style(controls, { position: "fixed", top: "0", right: "0" })
              if (!document.querySelector("div.controls")) document.body.appendChild(controls)
              const timerDisplay = Helper.render("text/link", "Aufnahmezeit: 0s", controls)
              function updateTimer() {
                seconds++
                timerDisplay.textContent = `Aufnahmezeit: ${seconds}s`
              }
              const pauseBtn = Helper.render("text/link", "Pause", controls)
              const stopBtn = Helper.render("text/link", "Stop", controls)
              pauseBtn.addEventListener("click", () => {
                if (mediaRecorder.state === "recording") {
                  mediaRecorder.pause()
                  clearInterval(timerInterval)
                  Helper.add("style/green", pauseBtn)
                  return
                }
                if (mediaRecorder.state === "paused") {
                  mediaRecorder.resume()
                  timerInterval = setInterval(updateTimer, 1000)
                  Helper.add("style/dark-light", pauseBtn)
                  return
                }
              })
              stopBtn.addEventListener('click', () => {
                mediaRecorder.stop()
              })
              Helper.remove("overlays")
              async function startRecording() {

                const screenStream = await navigator.mediaDevices.getDisplayMedia({video: true})
                const audioStream = await navigator.mediaDevices.getUserMedia({audio: true})
                const combinedStream = new MediaStream([
                  ...screenStream.getVideoTracks(),
                  ...audioStream.getAudioTracks(),
                ])
                mediaRecorder = new MediaRecorder(combinedStream)
                chunks = []
                mediaRecorder.ondataavailable = function (event) {
                  if (event.data.size > 0) {
                    chunks.push(event.data)
                  }
                }
                mediaRecorder.onstop = async () => {
                  clearInterval(timerInterval)
                  const blob = new Blob(chunks, { type: 'video/webm' })
                  const hashHex = await Helper.digest(blob)
                  const url = URL.createObjectURL(blob)
                  const a = document.createElement('a')
                  a.href = url
                  a.download = `${hashHex}.webm`
                  document.body.appendChild(a)
                  a.click()
                  setTimeout(() => {
                    document.body.removeChild(a)
                    URL.revokeObjectURL(url)
                    combinedStream.getTracks().forEach(track => track.stop())
                    controls.remove()
                  }, 100)
                }
                mediaRecorder.start()
                timerInterval = setInterval(updateTimer, 1000)
                Helper.add("style/red", timerDisplay)
              }
              await startRecording()
            } catch (error) {
              console.error(error)
              window.alert("Fehler.. Bitte wiederholen.")
            }
          }
          async function recordScreen() {

            try {


              let mediaRecorder
              let chunks = []
              let timerInterval
              let seconds = 0
              const controls = Helper.create("div")
              controls.className = "controls"
              Helper.style(controls, {position: "fixed", top: "0", right: "0"})
              if (!document.querySelector("div.controls")) document.body.appendChild(controls)
              const timerDisplay = Helper.render("text/link", "Aufnahmezeit: 0s", controls)
              const pauseBtn = Helper.render("text/link", "Pause", controls)
              const stopBtn = Helper.render("text/link", "Stop", controls)
              function updateTimer() {
                seconds++
                timerDisplay.textContent = `Aufnahmezeit: ${seconds}s`
              }
              async function startRecording() {
                const stream = await navigator.mediaDevices.getDisplayMedia({ video: true })
                mediaRecorder = new MediaRecorder(stream)
                chunks = []
                mediaRecorder.ondataavailable = (event) => {
                  if (event.data.size > 0) {
                    chunks.push(event.data)
                  }
                }
                mediaRecorder.onstop = async () => {
                  clearInterval(timerInterval)
                  const blob = new Blob(chunks, { type: 'video/webm' })
                  const hashHex = await Helper.digest(blob)
                  const url = URL.createObjectURL(blob)
                  const a = document.createElement('a')
                  a.href = url
                  a.download = `${hashHex}.webm`
                  document.body.appendChild(a)
                  a.click()
                  setTimeout(() => {
                    document.body.removeChild(a)
                    URL.revokeObjectURL(url)
                    stream.getTracks().forEach(track => track.stop())
                    controls.remove()
                  }, 100)
                }
                mediaRecorder.start()
                timerInterval = setInterval(updateTimer, 1000)
                Helper.add("style/red", timerDisplay)
              }
              pauseBtn.addEventListener('click', () => {
                if (mediaRecorder.state === 'recording') {
                  mediaRecorder.pause()
                  clearInterval(timerInterval)
                  Helper.add("style/green", pauseBtn)
                  return
                }

                if (mediaRecorder.state === 'paused') {
                  mediaRecorder.resume()
                  timerInterval = setInterval(updateTimer, 1000)
                  Helper.add("style/dark-light", pauseBtn)
                  return
                }

              })
              stopBtn.addEventListener('click', () => {
                mediaRecorder.stop()
              })



              Helper.remove("overlays")
              await startRecording()
            } catch (error) {
              console.error(error)
              window.alert("Fehler.. Bitte wiederholen.")
            }
          }
          const button = this.create("toolbox/left-right", buttons)
          button.left.textContent = ".record-screen"
          button.right.textContent = "Beginne eine Bildschirmaufnahme"
          button.addEventListener("click", ev => {
            this.overlay("pop", o => {
              {
                const button = this.create("toolbox/left-right", o.content)
                button.left.textContent = ".with-mic"
                button.right.textContent = "Mit Ton"
                button.onclick = async () => await recordAudioScreen()
              }
              {
                const button = this.create("toolbox/left-right", o.content)
                button.left.textContent = ".without-mic"
                button.right.textContent = "Ohne Ton"
                button.onclick = async () => await recordScreen()
              }
            })
          })
        }

        {
          const button = this.create("toolbox/left-right", buttons)
          button.left.textContent = ".start"
          button.right.textContent = "Schnell zum Start zurück"
          button.addEventListener("click", async () => window.open("/", "_blank"))
        }

        if (callback.updateToolbox === true) {
          const button = this.create("toolbox/left-right", buttons)
          button.left.textContent = "update.toolbox"
          button.right.textContent = "Mit nur einem Klick erhälst du die aktuellste Version unserer Toolbox"
          button.addEventListener("click", async () => {
            await this.update("toolbox-getter", document.body)
            window.alert("Deine Toolbox ist jetzt auf dem neuesten Stand.\n\nUm sicherzustellen, dass Deine wertvollen Änderungen nicht verloren gehen und dauerhaft im Dokument gespeichert werden, vergiss bitte nicht, den Speichervorgang durchzuführen. Das Speichern Deiner Arbeit ist wie das Bewahren eines Kunstwerks. Denke daran, auf die 'Speichern'-Schaltfläche in Deiner Anwendungssoftware zu klicken. Andernfalls könnten Deine Anpassungen beim Schließen des Fensters verschwinden.")
          })
        }



      })
    }

    if (event === "pop") {

      const overlay = this.create("div/overlay")
      overlay.addButton = this.create("toolbox/add")
      overlay.aliasIt = (it, o) => {
        const fragment = document.createDocumentFragment()
        const button = this.create("toolbox/left-right", fragment)
        button.left.textContent = ".alias"
        button.right.textContent = "Verwende einen alternativen Namen"
        button.onclick = () => {
          this.overlay("pop", o1 => {
            if (it.alias) o1.info.textContent = it.alias
            const funnel = o1.content
            const aliasField = this.create("input/text", funnel)
            aliasField.input.placeholder = "Alternativer Name"
            aliasField.input.setAttribute("required", "true")
            aliasField.input.setAttribute("accept", "text/length")
            aliasField.input.maxLength = "55"
            if (it.alias !== undefined) {
              aliasField.input.value = it.alias
            }
            this.verify("input/value", aliasField.input)
            aliasField.input.oninput = () => this.verify("input/value", aliasField.input)
            const submit = this.create("button/action", funnel)
            this.add("outline-hover", submit)
            submit.textContent = "Alias jetzt speichern"
            submit.onclick = async () => {
              await this.verify("input/value", aliasField.input)
              overlay.registerKey(it, {alias: aliasField.input.value})
              overlay.tabs.meine.click()
              o1.remove()
              o.remove()
            }
          })
        }
        o.content.appendChild(fragment)
        return button
      }
      overlay.appendHtml = (it, node, o) => {
        const fragment = document.createDocumentFragment()
        const button = this.create("toolbox/left-right", fragment)
        button.left.textContent = ".append"
        button.right.textContent = "HTML anhängen"
        button.onclick = async () => {
          const parser = document.createElement("div")
          parser.innerHTML = await this.convert("text/purified", it.html)
          parser.firstChild.textContent = this.convert("text/prompt", parser.firstChild.textContent)
          node.appendChild(parser.firstChild)
          o.remove()
          overlay.remove()
        }
        o.content.appendChild(fragment)
        return button
      }
      overlay.appendPdf = (it, node, o) => {
        const fragment = document.createDocumentFragment()
        const button = this.create("toolbox/left-right", fragment)
        button.left.textContent = ".append"
        button.right.textContent = "PDF anhängen"
        button.onclick = async () => {
          const fragment = document.createDocumentFragment()
          const pdf = await this.render("pdf", it.url, fragment)
          node.appendChild(fragment)
          o.remove()
          overlay.remove()
        }
        o.content.appendChild(fragment)
        return button
      }
      overlay.appendText = (it, node, o) => {
        const fragment = document.createDocumentFragment()
        const button = this.create("toolbox/left-right", fragment)
        button.left.textContent = ".appendTextContent"
        button.right.textContent = "Inhalt anhängen"
        button.onclick = async () => {
          const parser = document.createElement("div")
          parser.innerHTML = await this.convert("text/purified", it.html)
          parser.firstChild.textContent = this.convert("text/prompt", parser.firstChild.textContent)
          node.append(parser.firstChild.textContent)
          o.remove()
          overlay.remove()
        }
        o.content.appendChild(fragment)
        return button
      }
      overlay.appendScript = (it, node, o) => {

        const button = this.create("toolbox/left-right", o.content)
        button.left.textContent = ".append-once"
        button.right.textContent = "Element wird überschrieben oder angehängt"
        button.addEventListener("click", async ev => {
          const html = await this.convert("text/script", it.html)
          html.id = it.id
          this.add("onbody-once", html)
          o.remove()
          overlay.remove()
        })
        return button
      }
      overlay.content = this.create("div/scrollable", overlay)
      overlay.append = node => {

        const fragment = document.createDocumentFragment()
        fragment.appendChild(node)
        overlay.content.appendChild(fragment)
      }
      overlay.appendButton = (it, node, o) => {

        const fragment = document.createDocumentFragment()
        const button = this.create("toolbox/left-right", fragment)
        button.left.textContent = ".append"
        button.right.textContent = "Daten anhängen"
        button.onclick = async ev => {
          const button = await overlay.createItButton(it)
          node.appendChild(button)
          overlay.remove()
          o.remove()
        }
        o.append(fragment)
        return button
      }
      overlay.appendImage = (it, node, o) => {

        const fragment = document.createDocumentFragment()
        const button = this.create("toolbox/left-right", fragment)
        button.left.textContent = ".append"
        button.right.textContent = "Image anhängen"
        button.onclick = async () => {

          this.render("img/div", it.url, node)
          o.remove()
          overlay.remove()
        }
        o.content.appendChild(fragment)
        return button
      }
      overlay.appendIt = (it, node, o, ok) => {

        const button = this.create("toolbox/left-right")
        o.append(button)
        button.left.textContent = ".append"
        button.right.textContent = "Datei anhängen"
        button.onclick = () => {

          this.render("node", it, node)
          o.remove()
          if (ok) ok()
        }
        return button
      }
      overlay.closeStream = stream => {

        if (stream) {
          const tracks = stream.getTracks()
          tracks.forEach(track => track.stop())
        }
      }
      overlay.closeVideoStream = video => {

        overlay.closeStream(video.srcObject)
      }
      overlay.copyHtml = (it, o) => {
        const fragment = document.createDocumentFragment()
        const button = this.create("toolbox/left-right", fragment)
        button.left.textContent = ".copy"
        button.right.textContent = "HTML in deiner Zwischenablage speichern"
        button.onclick = async () => {
          const parser = document.createElement("div")
          parser.innerHTML = await this.convert("text/purified", it.html)
          parser.firstChild.textContent = this.convert("text/prompt", parser.firstChild.textContent)
          navigator.clipboard.writeText(parser.firstChild.outerHTML).then(() => window.alert("Dein Template wurde erfolgreich in deine Zwischablage gespeichert."))
        }
        o.content.appendChild(fragment)
        return button
      }
      overlay.copyText = (it, o) => {
        const fragment = document.createDocumentFragment()
        const button = this.create("toolbox/left-right", fragment)
        button.left.textContent = ".copyTextContent"
        button.right.textContent = "Inhalt in deiner Zwischenablage speichern"
        button.onclick = async () => {
          const parser = document.createElement("div")
          parser.innerHTML = await this.convert("text/purified", it.html)
          parser.firstChild.textContent = this.convert("text/prompt", parser.firstChild.textContent)
          navigator.clipboard.writeText(parser.firstChild.textContent).then(() => window.alert("Dein Template wurde erfolgreich in deine Zwischablage gespeichert."))
        }
        o.content.appendChild(fragment)
        return button
      }
      overlay.download = (file, o, ok) => {

        const button = this.create("toolbox/left-right", o.content)
        button.right.textContent = "Speicher auf deinem Gerät"
        button.left.textContent = ".download"
        button.onclick = () => {

          const url = URL.createObjectURL(file)
          const link = document.createElement('a')
          link.href = url
          link.download = file.name
          document.body.appendChild(link)
          link.click()
          document.body.removeChild(link)
          URL.revokeObjectURL(url)
          o.remove()
          if (ok) ok()
        }
      }
      overlay.emailHtml = (it, o) => {

        const fragment = document.createDocumentFragment()
        const button = this.create("toolbox/left-right", fragment)
        button.left.textContent = ".email"
        button.right.textContent = "Versende HTML per E-Mail"
        button.onclick = async () => {
          const parser = document.createElement("div")
          parser.innerHTML = await this.convert("text/purified", it.html)
          parser.firstChild.textContent = this.convert("text/prompt", parser.firstChild.textContent)
          const mailtoLink = `mailto:?body=${parser.firstChild.outerHTML}`
          const a = document.createElement("a")
          a.href = mailtoLink
          a.click()
        }
        o.content.appendChild(fragment)
        return button
      }
      overlay.emailText = (it, o) => {

        const fragment = document.createDocumentFragment()
        const button = Helper.create("toolbox/left-right", fragment)
        button.left.textContent = ".emailTextContent"
        button.right.textContent = "Versende den Text Inhalt per E-Mail"
        button.onclick = async () => {
          const parser = document.createElement("div")
          parser.innerHTML = await Helper.convert("text/purified", it.html)
          parser.firstChild.textContent = this.convert("text/prompt", parser.firstChild.textContent)
          const mailtoLink = `mailto:?body=${parser.firstChild.textContent}`
          const a = document.createElement("a")
          a.href = mailtoLink
          a.click()
        }
        o.content.appendChild(fragment)
        return button
      }
      overlay.loading = () => {

        this.convert("parent/loading", overlay.content)
      }
      overlay.ocr = (canvas, node, o, ok) => {

        async function convertCanvasToText(canvas) {
          try {
            const prompt = window.prompt("Gebe die Sprachen ein: (z.B., deu, eng, ..) - Drücke einfach Enter für Deutsch")
            let worker
            if (!Helper.verifyIs("text/empty", prompt)) {
              worker = await Tesseract.createWorker(prompt)
            } else {
              worker = await Tesseract.createWorker("deu")
            }
            const res = await worker.recognize(canvas)
            await worker.terminate()
            return res.data.text
          } catch (error) {
            window.alert(`Fehler bei der Texterkennung:\n\n${error}`)
          }
        }
        const button = Helper.create("toolbox/left-right")
        o.append(button)
        button.right.textContent = "Exportiere Text aus deinem Bild in dein ausgewähltes Element"
        button.left.textContent = ".tesseract-ocr"
        button.onclick = async () => {
          await Helper.dynamicImport("https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js", async() => {
            const text = await convertCanvasToText(canvas)
            const purified = await Helper.convert("text/purified", text)
            node.append(purified)
            o.remove()
            if (ok) ok()
          })
        }
      }
      overlay.openCam = (node, o) => {

        const button = this.create("toolbox/left-right")
        o.append(button)
        button.left.textContent = ".camera"
        button.right.textContent = "Erschaffe einzigartige Bilder"
        button.onclick = ev => {

          this.overlay("pop", async o1 => {
            o1.removeOverlayButton.addEventListener("click", ev => {
              o1.closeVideoStream(video)
            })
            o1.info.textContent = `.choose.cam`
            const select = await this.create("select/cam")
            o1.append(select)
            select.input.oninput = ev => {
              o1.closeVideoStream(video)
              this.add("stream/cam", {deviceId: ev.target.value, video})
            }
            const preview = this.create("div", o1.content)
            this.style(preview, {margin: "21px 34px", borderRadius: "13px", overflow: "hidden"})
            const video = this.create("video", preview)
            o1.append(o1.addButton)
            o1.addButton.onclick = async ev => {
              if (video.srcObject) {
                const canvas = this.convert("video/canvas", video)
                const file = await this.convert("canvas/image", canvas)
                this.overlay("pop", o2 => {
                  overlay.appendIt(canvas, node, o2, () => {
                    o1.remove()
                    o.remove()
                    overlay.remove()
                  })
                  overlay.download(file, o2, () => {
                    o1.remove()
                    o.remove()
                  })
                  overlay.ocr(canvas, node, o2, () => {
                    overlay.remove()
                    o1.remove()
                    o.remove()
                  })
                })
                o1.closeVideoStream(video)
              }
            }
          })
        }
        return button
      }
      overlay.openMic = (node, o) => {

        const button = this.create("toolbox/left-right")
        o.append(button)
        button.left.textContent = ".microfon"
        button.right.textContent = "Web Audio Recorder"
        button.onclick = ev => {

          this.overlay("pop", async o1 => {
            o1.removeOverlayButton.addEventListener("click", ev => {
              recorder.stop()
            })
            o1.info.textContent = `.record.audio`
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true })
            const recorder = this.add("recorder", {type: "audio/ogg"})
            this.style(recorder.controls, {position: "fixed", top: "0", right: "0"})
            o1.append(recorder.controls)
            recorder.start(stream, o1)
          })
        }
        return button
      }
      overlay.openVid = (node, o) => {

        const button = this.create("toolbox/left-right")
        o.append(button)
        button.left.textContent = ".video"
        button.right.textContent = "Nehme den Moment auf"
        button.onclick = ev => {

          this.overlay("pop", async o1 => {
            o1.removeOverlayButton.addEventListener("click", ev => {
              o1.closeVideoStream(video)
            })
            o1.info.textContent = `.choose.cam`
            const select = await this.create("select/cam")
            o1.append(select)
            select.input.oninput = async ev => {
              o1.closeVideoStream(video)
              const stream = await this.add("stream/vid", {deviceId: ev.target.value, video})
              recorder.start(stream, o1)
            }
            const recorder = this.add("recorder", {type: "video/ogg"})
            this.style(recorder.controls, {position: "fixed", bottom: "0", right: "0"})
            const preview = this.create("div", o1.content)
            this.style(preview, {margin: "21px 34px", borderRadius: "13px", overflow: "hidden"})
            const video = this.create("video", preview)
          })
        }
        return button
      }
      overlay.openWindow = (it, o) => {

        const button = this.create("toolbox/left-right")
        o.append(button)
        button.left.textContent = ".open"
        button.right.textContent = "Im neuen Tab öffnen"
        button.onclick = ev => {
          window.open(it.url, "_blank")
        }
        return button
      }
      async function renderBasedOnTab(array, node) {
        node.textContent = ""
        if (overlay.tabs && overlay.tabs.meine.style.borderRadius === "50%") {
          await renderItClosed(array, node)
        } else {
          await renderItOpen(array, node)
        }
      }
      overlay.titleIt = (it, o) => {
        const fragment = document.createDocumentFragment()
        const button = this.create("toolbox/left-right", fragment)
        button.left.textContent = ".title"
        button.right.textContent = "Titel eingeben"
        button.onclick = () => {
          this.overlay("pop", o1 => {
            if (it.title) o1.info.textContent = it.title
            const funnel = o1.content
            const titleField = this.create("input/text", funnel)
            titleField.input.placeholder = "Titel"
            titleField.input.setAttribute("required", "true")
            titleField.input.setAttribute("accept", "text/length")
            titleField.input.maxLength = "89"
            if (it.title !== undefined) {
              titleField.input.value = it.title
            }
            this.verify("input/value", titleField.input)
            titleField.input.oninput = () => this.verify("input/value", titleField.input)
            const submit = this.create("toolbox/action", funnel)
            submit.textContent = "Titel jetzt speichern"
            submit.onclick = async () => {
              await this.verify("input/value", titleField.input)
              overlay.registerKey(it, {title: titleField.input.value})
              overlay.tabs.meine.click()
              o1.remove()
              o.remove()
            }
          })
        }
        o.content.appendChild(fragment)
        return button
      }
      overlay.translateText = (it, o) => {

        const fragment = document.createDocumentFragment()
        const button = this.create("toolbox/left-right", fragment)
        button.left.textContent = ".translate"
        button.right.textContent = "Sende deinen Inhalt an eine Übersetzungsmaschine"
        button.onclick = async () => {
          const parser = document.createElement("div")
          parser.innerHTML = await this.convert("text/purified", it.html)
          const textContent = this.convert("text/prompt", parser.firstChild.textContent)
          this.overlay("pop", o1 => {
            o1.info.textContent = `${textContent}.translate`
            const translations = [
              { name: "Google Translate", url: `https://translate.google.com/?sl=auto&tl=auto&text=${encodeURIComponent(textContent)}` },
              { name: "DeepL Translate", url: `https://www.deepl.com/translator#auto/auto/${encodeURIComponent(textContent)}` },
              { name: "Bing Translator", url: `https://www.bing.com/translator?from=auto&to=auto&text=${encodeURIComponent(textContent)}` },
              { name: "Yandex Translate", url: `https://translate.yandex.com/?lang=auto-auto&text=${encodeURIComponent(textContent)}` }
            ]
            for (let i = 0; i < translations.length; i++) {
              const it = translations[i]
              const button = this.create("toolbox/left-right", o1.content)
              button.left.textContent = it.name
              button.onclick = () => {
                window.open(it.url, "_blank")
              }
            }
          })
        }
        o.content.appendChild(fragment)
        return button
      }
      overlay.shebang = (it, o) => {

        const fragment = document.createDocumentFragment()
        const button = this.create("toolbox/left-right", fragment)
        button.left.textContent = "#!/bin/bash"
        button.right.textContent = "Lade eine .sh Datei herunter"
        button.onclick = async () => {
          const parser = document.createElement("div")
          parser.innerHTML = await this.convert("text/purified", it.html)
          const shebang = "#!/bin/bash\n"
          const scriptContent = shebang + this.convert("text/prompt", parser.firstChild.textContent)
          await this.downloadFile(scriptContent, "text/x-sh")
        }
        o.content.appendChild(fragment)
        return button
      }
      overlay.sharePdf = (it, o) => {

        const fragment = document.createDocumentFragment()
        function extractCid(url) {
          const cidPattern = /ipfs\/([^/]+)/
          const match = url.match(cidPattern)
          if (match && match[1]) {
            return match[1]
          }
        }
        const button = this.create("toolbox/left-right", fragment)
        button.left.textContent = ".share"
        button.right.textContent = "Teile dein PDF mit deinem Netzwerk"
        button.onclick = async () => {
          if (navigator.share) {
            const cid = extractCid(it.url)
            await navigator.share({text: `${window.location.protocol}//${window.location.host}/ipfs/${cid}/`})
          } else {
            window.alert("Brower wird nicht unterstützt.")
          }
        }
        o.content.appendChild(fragment)
        return button
      }
      function updateSearchField(array, node){

        if (overlay.input && overlay.filter) {
          let filtered
          overlay.input.oninput = async ev => {
            const query = ev.target.value
            if (!Helper.verifyIs("text/empty", query)) {
              const highlighted = Helper.sort("query", {array, query, filter: overlay.filter})
              await renderBasedOnTab(highlighted, node)
            } else {
              await renderBasedOnTab(array, node)
            }
          }
        }
      }
      overlay.updateItOpen = async () => {
        if (overlay.it && overlay.rerender) {
          Helper.convert("parent/loading", overlay.rerender)
          const res = await Helper.request(`/get/open/${overlay.it}/`)
          if (res.status === 200) {
            const it = JSON.parse(res.response)
            updateSearchField(it, overlay.rerender)
            renderItOpen(it, overlay.rerender)
          } else {
            Helper.convert("parent/note", overlay.rerender)
            overlay.rerender.textContent = "Keine Daten gefunden"
          }
        }
      }
      function styleDefaultList(node) {
        node.textContent = ""
        node.removeAttribute("style")
        node.removeAttribute("class")
        node.style.margin = "21px 34px"
      }
      async function renderItOpen(array, node) {
        styleDefaultList(node)
        if (overlay.rerenderStyle) overlay.rerenderStyle(node)
        node.style.wordBreak = "break-word"
        for (let i = 0; i < array.length; i++) {
          const it = array[i]
          const button = await overlay.createItButton(it)
          node.appendChild(button)
          button.onclick = async () => {
            await overlay.openOptions(it)
          }
        }
      }
      overlay.style.opacity = 0
      overlay.info = this.create("header/info", overlay)
      overlay.closeSocket = (socket) => {
        overlay.removeOverlayButton.addEventListener("click", () => {
          socket.close()
        })
      }
      overlay.onlyClosedUser = () => {
        this.request("/verify/user/closed/").then(res => {
          if (res.status !== 200) {
            const confirm = window.confirm("Um die folgenden Funktionen nutzen zu können, musst du dich anmelden.\n\nMöchtest du dich jetzt anmelden?")
            if (confirm === true) {
              overlay.remove()
              window.open("/login/", "_blank")
            } else {
              overlay.remove()
            }
          }
        })
      }
      overlay.registerIt = (update) => {

        return new Promise(async(resolve, reject) => {
          try {
            this.overlay("security", async securityOverlay => {
              const res = await this.request(`/register/user/${overlay.it}/`, {[overlay.it]: update})
              if (res.status === 200) {
                window.alert("Daten erfolgreich gespeichert.")
                overlay.tabs.meine.click()
                securityOverlay.remove()
              } else {
                window.alert("Fehler.. Bitte wiederholen.")
                securityOverlay.remove()
              }
              resolve(res)
            })
          } catch (error) {
            reject(error)
          }
        })
      }
      overlay.registerKey = (it, key) => {

        return new Promise(async(resolve, reject) => {
          try {
            this.overlay("security", async securityOverlay => {
              const keyName = Object.keys(key)[0]
              const keyValue = key[keyName]
              const res = await this.request(`/register/${overlay.it}/${keyName}/`, {created: it.created, [keyName]: keyValue})
              if (res.status === 200) {
                window.alert("Daten erfolgreich gespeichert.")
                overlay.tabs.meine.click()
                securityOverlay.remove()
              } else {
                window.alert("Fehler.. Bitte wiederholen.")
                securityOverlay.remove()
              }
              resolve(res)
            })
          } catch (error) {
            reject(error)
          }
        })
      }
      overlay.removeIt = (it, o) => {

        const fragment = document.createDocumentFragment()
        const button = this.create("toolbox/left-right", fragment)
        button.left.textContent = ".remove"
        button.right.textContent = "Daten entfernen"
        button.onclick = ev => {
          const confirm = window.confirm("Möchtest du deine Daten wirklich entfernen?")
          if (confirm === true) {
            this.overlay("security", async securityOverlay => {
              const res = await this.request(`/remove/user/${overlay.it}/`, {created: it.created})
              if (res.status === 200) {
                window.alert("Deine Daten wurden erfolgreich entfernt.")
                overlay.tabs.meine.click()
                o.remove()
                securityOverlay.remove()
              } else {
                window.alert("Fehler.. Bitte wiederholen.")
                securityOverlay.remove()
              }
            })
          }
        }
        o.content.appendChild(fragment)
        return button
      }
      overlay.removeOverlayButton = this.removeOverlayButton(overlay)
      overlay.renderTabs = () => {
        overlay.tabs = this.render("tabs", "Alle Meine", overlay.content)
      }
      overlay.visibility = (it, o) => {

        const button = this.create("visibility-button", o.content)
        button.addEventListener("click", ev => {

          this.overlay("pop", o1 => {
            o1.info.textContent = `${it.id}.${it.visibility}`
            const content = o1.content
            const field = this.create("input/select", content)
            field.input.add(["closed", "open"])
            if (it.visibility) {
              field.input.value = it.visibility
            }
            this.add("style/valid", field.input)
            field.input.addEventListener("input", ev => {
              const visibility = field.input.value
              this.overlay("security", async securityOverlay => {
                const res = await this.request(`/register/${overlay.it}/visibility/`, {created: it.created, visibility})
                if (res.status === 200) {
                  window.alert("Sichtbarkeit wurde erfolgreich gespeichert.")
                  if (it.visibility === "closed") {
                    overlay.tabs.alle.click()
                  } else {
                    overlay.tabs.meine.click()
                  }
                  o1.remove()
                  o.remove()
                } else {
                  window.alert("Fehler.. Bitte wiederholen.")
                }
                securityOverlay.remove()
              })

            })
            this.render("text/h3", "Mehr Info:", content)
            this.render("text/p", "open - Sichtbar für alle", content)
            this.render("text/p", "closed - Sichtbar nur für dich", content)
          })
        })
      }
      callback(overlay)
      document.body.appendChild(overlay)
      this.animate("fade-up", overlay)
      if (overlay.tabs) {
        overlay.tabs.meine.addEventListener("click", () => {
          overlay.updateItClosed()
          Helper.remove("style/selected", overlay.tabs.alle)
          Helper.add("style/selected", overlay.tabs.meine)
        })
        overlay.tabs.alle.addEventListener("click", () => {
          overlay.updateItOpen()
          Helper.remove("style/selected", overlay.tabs.meine)
          Helper.add("style/selected", overlay.tabs.alle)
        })
        Helper.add("style/selected", overlay.tabs.alle)
      }
      async function renderItClosed(array, node) {
        styleDefaultList(node)
        if (overlay.rerenderStyle) overlay.rerenderStyle(node)
        node.style.wordBreak = "break-word"
        for (let i = 0; i < array.length; i++) {
          const it = array[i]
          const button = await overlay.createItButton(it)
          node.appendChild(button)
          button.onclick = async () => {
            await overlay.closedOptions(it)
          }
        }
      }
      overlay.updateIt = (it, update) => {

        return new Promise(async(resolve, reject) => {
          try {
            this.overlay("security", async securityOverlay => {
              const res = await this.request(`/update/user/${overlay.it}/`, {created: it.created, [overlay.it]: update})
              if (res.status === 200) {
                window.alert("Daten erfolgreich gespeichert.")
                overlay.tabs.meine.click()
                securityOverlay.remove()
              } else {
                window.alert("Fehler.. Bitte wiederholen.")
                securityOverlay.remove()
              }
              resolve(res)
            })
          } catch (error) {
            reject(error)
          }
        })
      }
      overlay.updateItOpen()
      overlay.updateItClosed = async () => {
        if (overlay.it && overlay.rerender) {
          Helper.convert("parent/loading", overlay.rerender)
          const res = await Helper.request(`/get/user/${overlay.it}/`)
          if (res.status === 200) {
            const it = JSON.parse(res.response)
            updateSearchField(it, overlay.rerender)
            await renderItClosed(it, overlay.rerender)
          } else {
            Helper.convert("parent/note", overlay.rerender)
            overlay.rerender.textContent = "Keine Daten gefunden"
          }
        }
      }
      overlay.upload = (type, o) => {

        const button = this.create("toolbox/left-right")
        o.append(button)
        button.left.textContent = ".upload"
        button.right.textContent = "Lade eine URL-Datei hoch"
        button.onclick = ev => {

          this.overlay("pop", async o1 => {
            o1.info.textContent = `.upload`
            const funnel = this.render("upload", type, o1)
            funnel.submit.onclick = async () => {
              await this.verify("input/value", funnel.url.input)
              const res = await overlay.registerIt({url: funnel.url.input.value})
              if (res.status === 200) {
                o1.remove()
                o.remove()
              }
            }
          })
        }
        return button
      }
      return overlay
    }

    if (event === "popup") {

      const overlay = this.create("div/overlay")
      overlay.style.opacity = 0
      overlay.info = this.create("header/info", overlay)
      overlay.addButton = this.create("toolbox/add")
      overlay.onlyClosedUser = () => {
        this.request("/verify/user/closed/").then(res => {
          if (res.status !== 200) {
            const confirm = window.confirm("Um die folgenden Funktionen nutzen zu können, musst du dich anmelden.\n\nMöchtest du dich jetzt anmelden?")
            if (confirm === true) {
              overlay.remove()
              window.open("/login/", "_blank")
            } else {
              overlay.remove()
            }
          }
        })
      }
      overlay.removeOverlayButton = this.removeOverlayButton(overlay)
      callback(overlay)
      document.body.appendChild(overlay)
      this.animate("fade-up", overlay)
      return overlay
    }

    if (event === "info") {

      const overlay = document.createElement("div")
      overlay.classList.add("overlay")
      overlay.style.height = "100%"
      overlay.style.overscrollBehavior = "none"
      overlay.style.width = "100%"
      overlay.style.zIndex = "99999999999999"
      overlay.style.position = "fixed"
      overlay.style.top = "0"
      overlay.style.left = "0"
      overlay.style.background = this.colors.light.background
      overlay.style.display = "flex"
      overlay.style.flexDirection = "column"
      overlay.style.opacity = 0

      this.removeOverlayButton(overlay)

      if (callback) callback(overlay)

      document.body.append(overlay)

      this.animate("fade-up", overlay)

      // const animation = overlay.animate([
      //   { opacity: 0, transform: 'translateY(13px)' },
      //   { opacity: 1, transform: 'translateY(0)' },
      // ], {
      //   duration: 344,
      //   easing: 'ease-in-out',
      //   fill: "forwards"
      // })

      return overlay

    }

    if (event === "lock") {

      return this.overlay("pop", async o1 => {
        o1.removeOverlayButton.remove()
        o1.className = "overlay flex align center"
        this.create("info/loading", o1.content)
        if (callback) await callback(o1)
      })
    }

    if (event === "security") {

      const overlay = this.create("div/overlay")
      overlay.info = this.create("info/loading", overlay)
      if (callback) callback(overlay)
      document.body.append(overlay)
      return overlay

    }

    if (event === "select-template") {

      this.overlay("popup", async overlay => {
        async function renderTemplates(templates, node) {
          Helper.convert("parent/scrollable", node)
          for (let i = 0; i < templates.length; i++) {
            const template = templates[i]
            const fragment = document.createDocumentFragment()
            const templateButton = Helper.create("button/left-right", fragment)
            templateButton.left.innerHTML = await Helper.convert("text/purified", template.html)
            templateButton.right.style.fontSize = "21px"
            templateButton.onclick = () => {
              const textContent = Helper.convert("text/prompt", templateButton.left.textContent)
              callback(textContent)
              overlay.remove()
            }
            node.appendChild(fragment)
          }
        }
        const searchField = this.create("input/text", overlay)
        searchField.input.placeholder = "Suche nach Text in deinem Template"
        searchField.style.margin = "21px 34px"
        this.verify("input/value", searchField.input)
        this.add("outline-hover", searchField.input)
        const contactsDiv = this.create("div/scrollable", overlay)
        const res = await this.request("/get/templates/closed/")
        if (res.status === 200) {
          const templates = JSON.parse(res.response)
          let filtered
          searchField.input.oninput = async (ev) => {
            filtered = templates.filter(it => it.html.toLowerCase().includes(ev.target.value.toLowerCase()))
            const highlighted = filtered.map(it => {
              const highlightedHtml = it.html.replace(new RegExp(ev.target.value, 'i'), `<mark>${ev.target.value}</mark>`)
              return { ...it, html: highlightedHtml }
            })
            await renderTemplates(highlighted, contactsDiv)
          }
          await renderTemplates(templates, contactsDiv)
        } else {
          this.convert("parent/info", contactsDiv)
          contactsDiv.textContent = "Keine Templates gefunden"
        }
      })
    }

  }

  static render(event, input, parent) {

    if (event === "audio") {

      const audio = document.createElement("audio")
      this.render("node", audio, parent)
      audio.width = "100%"
      audio.controls = true
      audio.src = input
      return audio
    }

    if (event === "upload") {

      const fragment = document.createDocumentFragment()
      const funnel = this.create("div", fragment)
      funnel.url = this.create("input/text", funnel)
      funnel.url.input.setAttribute("required", "true")
      funnel.url.input.setAttribute("accept", "text/url")
      funnel.url.input.placeholder = "https://www.meine-domain.de/mein/pfad.."
      funnel.url.input.oninput = () => this.verify("input/value", funnel.url.input)
      this.verify("input/value", funnel.url.input)
      funnel.submit = this.create("toolbox/action", funnel)
      funnel.submit.textContent = "Datei jetzt speichern"
      funnel.file = this.create("input/file", funnel)
      funnel.file.input.setAttribute("accept", input)
      this.add("style/not-valid", funnel.file.input)
      funnel.file.input.onclick = () => {
        window.alert(`Achtung! Wenn du eine Datei hochlädst, werden deine Daten auf unserem IPFS-Node gespeichert und durch einen öffentlichen Link verfügbar gemacht. Auf diesen Link haben dann alle Zugriff. Bitte überlege dir genau, ob du deine Datei veröffentlichen möchtest. Mehr Infos über IPFS findest du unter: https://www.ipfs.tech/`)
      }
      funnel.file.input.oninput = async ev => {
        const file = ev.target.files[0]
        const formdata = new FormData()
        formdata.append("file", file, file.name)
        this.add("style/valid", funnel.file.input)
        fetch('/upload/ipfs/file/', {
          method: 'POST',
          body: formdata,
        })
        .then(response => response.text())
        .then(async data => {
          console.log('Successfully uploaded:', data)
          funnel.url.input.value = data
          this.verify("input/value", funnel.url.input)
          if (input === "application/pdf") {
            preparePreview()
            this.style(funnel.preview, {margin: "21px 34px"})
            await this.render("pdf", data, funnel.preview)
            return
          }
          if (input.startsWith("image/")) {
            const img = document.createElement("img")
            img.src = data
            img.style.width = "100%"
            preparePreview()
            funnel.preview.appendChild(img)
            return
          }
        })
        .catch(error => {
          this.render("style/not-valid", funnel.file.input)
          console.error('Error uploading file:', error)
        })
        function preparePreview() {
          funnel.preview.textContent = ""
          funnel.preview.style.margin = "21px 34px"
        }
      }
      funnel.preview = this.create("div", funnel)
      if (parent) {
        if (parent.content) {
          parent.content.appendChild(fragment)
        } else {
          parent.appendChild(fragment)
        }
      }
      return funnel
    }

    if (event === "text/node/action-button") {
      const button = this.create("button/action")
      button.textContent = input
      parent?.append(button)
      return button
    }

    if (event === "left-right/local-script-toggle") {

      const scripts = JSON.parse(window.localStorage.getItem("scripts")) || []

      for (let i = 0; i < scripts.length; i++) {
        const script = scripts[i]

        if (script.id === input) {
          if (script.disabled) {
            parent.right.textContent = ""
            const red = this.create("div/red-flag", parent.right)
            red.textContent = "Disabled"
            return parent
          }
        }
      }

      parent.right.textContent = ""
      const green = this.create("div/green-flag", parent.right)
      green.textContent = "OK"

      return parent
    }

    if (event === "left-right/disable-script-local") {
      parent.left.textContent = ".disable"
      parent.right.textContent = "Schalte dein Skript aus"
      parent.onclick = () => {
        this.convert("script/disabled", input.script)
        this.render("left-right/enable-script-local", {script: input.script}, parent)
        input?.ok()
      }
      return parent
    }

    if (event === "left-right/enable-script-local") {
      parent.left.textContent = ".enable"
      parent.right.textContent = "Schalte dein Skript an"
      parent.onclick = () => {
        this.convert("script/enabled", input.script)
        this.render("left-right/disable-script-local", {script: input.script}, parent)
        input?.ok()
      }
      return parent
    }

    if (event === "location-list/node/closed") {

      this.convert("parent/scrollable", parent)
      for (let i = 0; i < input.list.length; i++) {
        const item = input.list[i]

        const itemButton = this.create("button/left-right", parent)
        itemButton.left.textContent = item.titel
        itemButton.right.textContent = item.created
        itemButton.addEventListener("click", () => {

          this.overlay("toolbox", overlay => {

            this.removeOverlayButton(overlay)

            const buttons = this.create("div/scrollable", overlay)

            {
              const button = this.create("button/left-right", buttons)
              button.left.textContent = ".update"
              button.onclick = () => {

                this.overlay("toolbox", async overlay => {
                  this.removeOverlayButton(overlay)

                  this.render("text/title", `${this.convert("text/capital-first-letter", input.tag)}-${i + 1}`, overlay)

                  const fieldFunnel = await this.convert("path/field-funnel", input.path)
                  overlay.append(fieldFunnel)

                  fieldFunnel.querySelectorAll(".field").forEach(field => {
                    Object.entries(item).forEach(([key, value]) => {
                      if (field.id === key) {
                        field.querySelector(".field-input").value = value
                      }
                    })
                  })

                  this.verify("field-funnel", fieldFunnel)

                  const submitButton = fieldFunnel.querySelector(".submit-field-funnel-button")
                  submitButton.textContent = `${this.convert("text/capital-first-letter", input.tag)} jetzt speichern`
                  submitButton.onclick = async () => {

                    await this.verify("field-funnel", fieldFunnel)

                    const map = await this.convert("field-funnel/map", fieldFunnel)

                    this.overlay("security", async securityOverlay => {

                      const res = await this.request("/update/location/list-self/", {id: item.created, tag: input.tag, map})
                      if (res.status === 200) {
                        window.alert("Daten erfolgreich gespeichert.")

                        const res = await this.request("/get/location/tag-self/", {tag: input.tag})
                        if (res.status === 200) {
                          const tag = JSON.parse(res.response)
                          this.render("location-list/node/closed", {list: tag[input.tag], tag: input.tag, path: input.path}, parent)
                        }
                        if (res.status !== 200) {
                          this.convert("parent/info", parent)
                          parent.textContent = `Keine ${this.comvert("text/capital-first-letter", input.tag)} gefunden`
                        }

                        securityOverlay.remove()
                      }

                      if (res.status !== 200) {
                        window.alert("Fehler.. Bitte wiederholen.")
                        securityOverlay.remove()
                      }

                    })

                  }


                })
              }
            }

            {
              const button = this.create("button/left-right", buttons)
              button.left.textContent = ".delete"
              button.onclick = () => {
                this.overlay("security", async securityOverlay => {

                  const res = await this.request("/remove/location/tag-self/", {id: item.created, tag: input.tag})
                  if (res.status === 200) {
                    window.alert("Daten erfolgreich entfernt.")
                    itemButton.remove()
                    overlay.remove()
                    securityOverlay.remove()
                  }
                  if (res.status !== 200) {
                    window.alert("Fehler.. Bitte wiederholen.")
                    securityOverlay.remove()
                  }

                })
              }
            }


          })

        })

      }

    }

    if (event === "location-list/node/email-expert") {

      return new Promise(async(resolve, reject) => {
        try {
          const res = await this.request("/get/location/tag-expert/", {tag: input.tag, email: input.email, path: input.path})
          if (res.status === 200) {
            const tag = JSON.parse(res.response)
            this.convert("parent/scrollable", parent)
            for (let i = 0; i < tag[input.tag].length; i++) {
              const item = tag[input.tag][i]
              const itemButton = this.create("button/left-right", parent)
              itemButton.left.textContent = `${input.tag}-${i + 1}`
              itemButton.right.textContent = item.created
              itemButton.onclick = () => {
                this.overlay("popup", updateButtonsOverlay => {
                  const buttons = this.create("div/scrollable", updateButtonsOverlay)
                  {
                    const button = this.create("button/left-right", buttons)
                    button.left.textContent = ".update"
                    button.onclick = () => {
                      this.overlay("popup", async overlay => {
                        this.render("text/title", `${this.convert("text/capital-first-letter", input.tag)}-${i + 1}`, overlay)
                        const fieldFunnel = await this.convert("path/field-funnel", input.path)
                        overlay.append(fieldFunnel)
                        fieldFunnel.querySelectorAll(".field").forEach(field => {
                          Object.entries(item).forEach(([key, value]) => {
                            if (field.id === key) {
                              field.querySelector(".field-input").value = value
                            }
                          })
                        })
                        this.verify("field-funnel", fieldFunnel)
                        const submitButton = fieldFunnel.querySelector(".submit-field-funnel-button")
                        submitButton.textContent = `${this.convert("text/capital-first-letter", input.tag)} jetzt speichern`
                        submitButton.onclick = async () => {
                          await this.verify("field-funnel", fieldFunnel)
                          const map = await this.convert("field-funnel/map", fieldFunnel)
                          this.overlay("security", async securityOverlay => {
                            const update = {}
                            update.email = input.email
                            update.id = item.created
                            update.map = map
                            update.path = input.path
                            update.tag = input.tag
                            const res = await this.request("/update/location/list-email-expert/", update)
                            if (res.status === 200) {
                              window.alert("Daten erfolgreich gespeichert.")
                              await this.render(event, input, parent)
                              overlay.remove()
                              updateButtonsOverlay.remove()
                              securityOverlay.remove()
                            } else {
                              window.alert("Fehler.. Bitte wiederholen.")
                              securityOverlay.remove()
                            }
                          })
                        }
                      })
                    }
                  }
                  {
                    const button = this.create("button/left-right", buttons)
                    button.left.textContent = ".delete"
                    button.onclick = () => {
                      this.overlay("security", async securityOverlay => {
                        const res = await this.request("/remove/location/email-expert/", {id: item.created, tag: input.tag, path: input.path, email: input.email})
                        if (res.status === 200) {
                          window.alert("Daten erfolgreich entfernt.")
                          this.render(event, input, parent).catch(error => {
                            this.convert("parent/info", parent)
                            parent.textContent = `Keine ${this.convert("text/capital-first-letter", input.tag)} gefunden`
                          })
                          itemButton.remove()
                          updateButtonsOverlay.remove()
                          securityOverlay.remove()
                        }
                        if (res.status !== 200) {
                          window.alert("Fehler.. Bitte wiederholen.")
                          securityOverlay.remove()
                        }
                      })
                    }
                  }
                })
              }
            }
            resolve()
          } else {
            this.convert("parent/info", parent)
            parent.textContent = `Keine ${this.convert("text/capital-first-letter", input.tag)} gefunden`
          }
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "color/node/foreground") {

      parent.style.position = "relative"

      const foreground = parent.cloneNode("true")
      foreground.classList.add("foreground")
      foreground.textContent = ""
      foreground.style.position = "absolute"
      foreground.style.background = input
      parent.querySelectorAll(".foreground").forEach(it => it.remove())
      parent.appendChild(foreground)

      return foreground
    }

    if (event === "color/node/border") {

      parent.style.position = "relative"

      const border = parent.cloneNode("true")
      border.classList.add("border")
      border.textContent = ""
      border.style.position = "absolute"
      border.style.background = "transparent"
      border.style.border = `8px solid ${input}`
      parent.querySelectorAll(".border").forEach(it => it.remove())
      parent.appendChild(border)

    }

    if (event === "cart/node/open") {

      const cart = this.create("div/scrollable")
      cart.className = "cart"
      parent?.append(cart)

      for (let i = 0; i < input.length; i++) {
        const item = input[i]

        const container = this.create("div", cart)

        const itemDiv = this.create("div", container)
        itemDiv.className = "item"
        itemDiv.style.display = "flex"
        itemDiv.style.margin = "21px 34px"
        itemDiv.style.justifyContent = "space-between"

        const left = this.create("div", itemDiv)
        left.style.width = "144px"
        const img = document.createElement("img")
        img.src = item.image
        img.style.width = "100%"
        left.appendChild(img)
        const middle = this.create("div", itemDiv)
        middle.style.flex = "1 1 0"
        this.render("text/h2", item.titel, middle)

        if (Number(item.stocked) > 21) {
          const text = this.create("div", middle)
          text.textContent = "Auf Lager"
          text.style.fontFamily = "sans-serif"
          text.style.color = this.colors.light.success
          text.style.margin = "0 34px"
        } else if (Number(item.stocked) === 0) {
          const text = this.create("div", middle)
          text.textContent = "Ausverkauft"
          text.style.fontFamily = "sans-serif"
          text.style.color = this.colors.light.error
          text.style.margin = "0 34px"
        } else if (Number(item.stocked) < 21) {
          const text = this.create("div", middle)
          text.textContent = `Nur noch ${item.stocked} Artikel vorhanden`
          text.style.fontFamily = "sans-serif"
          text.style.color = this.colors.matte.orange
          text.style.margin = "0 34px"
        }

        if (Number(item.shipping) === 0) {
          const text = this.create("div", middle)
          text.textContent = "Dieser Hersteller bietet KOSTENLOSEN Versand"
          text.style.fontFamily = "sans-serif"
          text.style.color = "#999"
          text.style.margin = "0 34px"

        } else if (Number(item.shipping) > 0) {
          const text = this.create("div", middle)
          text.textContent = `Versandkosten: ${Number(item.shipping).toFixed(2).replace(".", ",")} €`
          text.style.fontFamily = "sans-serif"
          text.style.color = "#999"
          text.style.margin = "0 34px"
        }

        const tools = this.create("div", middle)
        tools.style.display = "flex"

        const quantity = this.create("div", tools)

        const select = this.create("input/select", quantity)
        this.add("outline-hover", select)


        if (Number(item.quantity) >= 10) {
          select.add(["0 - Löschen", "1", "2", "3", "4", "5", "6", "7", "8", "9", `${item.quantity}`, `${item.quantity}+`])
        } else {
          select.add(["0 - Löschen", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10+"])
        }

        if (Number(item.quantity) > Number(item.stocked)) {
          select.add(["0 - Löschen", "1", "2", "3", "4", "5", "6", "7", "8", "9", `${item.stocked}`, `${item.stocked}+`])
        }

        if (Number(item.quantity) > Number(item.stocked)) {
          select.value = item.stocked
        } else {
          select.value = item.quantity
        }

        select.style.margin = "21px 34px"
        select.style.fontSize = "21px"
        select.style.padding = "21px 34px"
        select.oninput = (ev) => {

          if (ev.target.value.startsWith("0")) {
            const cart = JSON.parse(window.localStorage.getItem("cart"))
            for (let i = 0; i < cart.length; i++) {
              const cartItem = cart[i]
              if (item.id === cartItem.id) {
                cart.splice(i, 1)
                window.localStorage.setItem("cart", JSON.stringify(cart))
                container.remove()

                const localCart = JSON.parse(window.localStorage.getItem("cart"))
                if (localCart.length <= 0) {
                  rightHr.remove()
                  parent.remove()
                }

                if (localCart.length > 0) {
                  const totalQuantity = localCart.reduce((acc, cur) => acc + cur.quantity, 0)

                  let totalPrice = 0
                  for (let i = 0; i < localCart.length; i++) {
                    const cartItem = localCart[i]
                    totalPrice = totalPrice + (cartItem.quantity * Number(cartItem.price))
                  }

                  rightHr.text.textContent = `Zusammenfassung (${totalQuantity} Artikel): ${totalPrice.toFixed(2).replace(".", ",")} €`
                }


              }

            }
          }

          if (ev.target.value.includes("+")) {
            quantity.textContent = ""
            quantity.style.display = "flex"
            quantity.style.justifyContent = "center"
            quantity.style.alignItems = "center"
            const tel = this.create("input/tel", quantity)
            this.add("outline-hover", tel)

            const cart = JSON.parse(window.localStorage.getItem("cart"))
            for (let i = 0; i < cart.length; i++) {
              const cartItem = cart[i]
              if (item.id === cartItem.id) {
                tel.value = cartItem.quantity
              }
            }
            tel.style.borderRadius = "8px"
            tel.style.border = "none"
            tel.style.margin = "21px 34px"
            tel.style.width = "89px"
            tel.style.fontSize = "34px"
            const submit = this.render("text/link", "Aktualisieren", quantity)
            submit.style.margin = "0"
            submit.textContent = "Aktualisieren"
            submit.onclick = () => {

              const cart = JSON.parse(window.localStorage.getItem("cart"))
              for (let i = 0; i < cart.length; i++) {
                const cartItem = cart[i]
                if (item.id === cartItem.id) {
                  if (this.verifyIs("text/+int", tel.value)) {

                    if (Number(tel.value) > Number(item.stocked)) {
                      cartItem.quantity = Number(item.stocked)
                    } else {
                      cartItem.quantity = Number(tel.value)
                    }
                    window.localStorage.setItem("cart", JSON.stringify(cart))
                  }
                }
              }


              quantity.textContent = ""
              quantity.append(select)
              select.textContent = ""
              if (this.verifyIs("text/+int", tel.value)) {

                if (tel.value >= 10) {
                  if (Number(tel.value) > Number(item.stocked)) {
                    select.add(["0 - Löschen", "1", "2", "3", "4", "5", "6", "7", "8", "9", `${item.stocked}`, `${item.stocked}+`])
                  } else {
                    select.add(["0 - Löschen", "1", "2", "3", "4", "5", "6", "7", "8", "9", `${tel.value}`, `${tel.value}+`])
                  }

                } else {
                  select.add(["0 - Löschen", "1", "2", "3", "4", "5", "6", "7", "8", "9", `10+`])
                }

              } else {
                const cart = JSON.parse(window.localStorage.getItem("cart"))
                for (let i = 0; i < cart.length; i++) {
                  const cartItem = cart[i]
                  if (item.id === cartItem.id) {
                    select.add(["0 - Löschen", "1", "2", "3", "4", "5", "6", "7", "8", "9", `${cartItem.quantity}`, `${cartItem.quantity}+`])
                  }
                }
              }

              let result = 0
              if (Number(tel.value) > Number(item.stocked)) {
                result = Number(item.stocked)
              } else {
                result = Number(tel.value)
              }
              select.value = result



              const localCart = JSON.parse(window.localStorage.getItem("cart"))
              if (localCart.length > 0) {
                const totalQuantity = localCart.reduce((acc, cur) => acc + Number(cur.quantity), 0)

                let totalPrice = 0
                for (let i = 0; i < localCart.length; i++) {
                  const cartItem = localCart[i]
                  totalPrice = totalPrice + (cartItem.quantity * Number(cartItem.price))
                }

                rightHr.text.textContent = `Zusammenfassung (${totalQuantity} Artikel): ${totalPrice.toFixed(2).replace(".", ",")} €`
              }



            }

          }

          if (Number(ev.target.value) > 0 && Number(ev.target.value) < 10) {

            let result = 0
            if (Number(ev.target.value) > Number(item.stocked)) {
              result = Number(item.stocked)
            } else {
              result = Number(ev.target.value)
            }
            select.value = result


            let cart = JSON.parse(window.localStorage.getItem("cart"))
            for (let i = 0; i < cart.length; i++) {
              const cartItem = cart[i]
              if (item.id === cartItem.id) {
                if (this.verifyIs("text/+int", Number(ev.target.value))) {
                  if (Number(ev.target.value) > Number(item.stocked)) {
                    cartItem.quantity = Number(item.stocked)
                  } else {
                    cartItem.quantity = Number(ev.target.value)
                  }
                  window.localStorage.setItem("cart", JSON.stringify(cart))
                }
              }
            }

            cart = JSON.parse(window.localStorage.getItem("cart"))
            if (cart.length > 0) {
              const totalQuantity = cart.reduce((acc, cur) => acc + Number(cur.quantity), 0)
              let totalPrice = 0
              for (let i = 0; i < cart.length; i++) {
                const cartItem = cart[i]
                totalPrice = totalPrice + (Number(cartItem.quantity) * Number(cartItem.price))
              }
              rightHr.text.textContent = `Zusammenfassung (${totalQuantity} Artikel): ${totalPrice.toFixed(2).replace(".", ",")} €`
            }
          }

        }

        if (Number(item.quantity) > Number(item.stocked)) {
          const cart = JSON.parse(window.localStorage.getItem("cart"))
          for (let i = 0; i < cart.length; i++) {
            const cartItem = cart[i]
            if (item.id === cartItem.id) {
              cartItem.quantity = Number(item.stocked)
              window.localStorage.setItem("cart", JSON.stringify(cart))
            }
          }
        }

        const del = this.render("text/link", "Löschen", tools)
        del.onclick = () => {
          const cart = JSON.parse(window.localStorage.getItem("cart"))
          for (let i = 0; i < cart.length; i++) {
            const cartItem = cart[i]
            if (item.id === cartItem.id) {
              cart.splice(i, 1)
              window.localStorage.setItem("cart", JSON.stringify(cart))
              container.remove()

              const localCart = JSON.parse(window.localStorage.getItem("cart"))
              if (localCart.length <= 0) {
                rightHr.remove()
                parent.remove()
              }

              if (localCart.length > 0) {
                const totalQuantity = localCart.reduce((acc, cur) => acc + Number(cur.quantity), 0)

                let totalPrice = 0
                for (let i = 0; i < localCart.length; i++) {
                  const cartItem = localCart[i]
                  totalPrice = totalPrice + (cartItem.quantity * Number(cartItem.price))
                }

                rightHr.text.textContent = `Zusammenfassung (${totalQuantity} Artikel): ${totalPrice.toFixed(2).replace(".", ",")} €`
              }


            }

          }
        }
        const more = this.render("text/link", "Weitere Artikel wie dieser", tools)

        const right = this.create("div", itemDiv)
        right.style.display = "flex"
        right.style.justifyContent = "flex-end"
        const title = this.render("text/title", `${Number(item.price).toFixed(2).replace(".", ",")} €`, right)
        title.style.margin = "21px 0"

      }


      const localCart = JSON.parse(window.localStorage.getItem("cart"))
      let rightHr
      if (localCart.length > 0) {
        const totalQuantity = localCart.reduce((acc, cur) => acc + Number(cur.quantity), 0)

        let totalPrice = 0
        for (let i = 0; i < localCart.length; i++) {
          const cartItem = localCart[i]
          totalPrice = totalPrice + (cartItem.quantity * Number(cartItem.price))
        }

        rightHr = this.render("text/right-hr", `Zusammenfassung (${totalQuantity} Artikel): ${totalPrice.toFixed(2).replace(".", ",")} €`, cart)
      }

    }

    if (event === "contacts/node/next-list") {
      if (arguments.length === 2) {
        parent = input
      }

      return new Promise(async(resolve, reject) => {
        try {

          const res = await this.request("/get/contacts/self/")
          if (res.status === 200) {
            const contacts = JSON.parse(res.response)

            parent.textContent = ""

            for (let i = 0; i < contacts.length; i++) {
              const contact = contacts[i]

              if (contact.notes) {
                const regex = /next:(\w+)(?:\+(\d+[dm]))?\(([^)]+)\)/g
                let match

                while ((match = regex.exec(contact.notes)) !== null) {
                  const action = match[1]
                  const duration = match[2] || ''
                  const content = match[3]

                  const button = this.create("button/left-right", parent)

                  if (contact.status === "lead-new") {
                    button.style.border = `3px solid ${this.colors.matte.green}`
                    this.animate("node/border-ripple-out", button)
                    this.render("text/node/bottom-right-onhover", "Neuer Kontakt", button)
                  }

                  if (contact.status === "lead-update") {
                    button.style.border = `3px solid ${this.colors.matte.sunflower}`
                    this.animate("node/border-ripple-out", button)
                    this.render("text/node/bottom-right-onhover", "Neue Kontaktanfrage", button)
                  }


                  if (action === "tel" || action === "webcall") {
                    let title
                    if (contact.alias) {
                      title = this.render("text/div", `${contact.alias} anrufen.`, button.left)
                    } else {
                      title = this.render("text/div", `${contact.email} anrufen.`, button.left)
                    }

                    if (contact.phone) {
                      this.render("icon/node/path", "/public/phone-out.svg", button.right).then(icon => {
                        icon.style.width = "34px"
                        icon.style.padding = "0 13px"
                      })
                      button.onclick = () => {
                        window.location.href = `tel:${contact.phone}`
                      }
                    }

                  }

                  if (action === "email") {
                    let title
                    if (contact.alias) {
                      title = this.render("text/div", `${contact.alias} schreiben.`, button.left)
                    } else {
                      title = this.render("text/div", `${contact.email} schreiben.`, button.left)
                    }

                    if (contact.email) {
                      this.render("icon/node/path", "/public/email-out.svg", button.right).then(icon => {
                        icon.style.width = "34px"
                        icon.style.padding = "0 13px"
                      })
                      button.onclick = () => {
                        window.location.href = `mailto:${contact.email}`
                      }
                    }
                  }

                  const contentDiv = this.create("div")
                  contentDiv.textContent = content
                  contentDiv.style.fontSize = "13px"
                  button.left.appendChild(contentDiv)


                }
              }
            }
            resolve(parent)
          }

        } catch (error) {
          reject(error)
        }
      })




    }

    if (event === "html/h1") {

      const fragment = document.createDocumentFragment()
      const h1 = document.createElement("h1")
      fragment.appendChild(h1)
      this.convert("text/purified", input).then(purified => {
        h1.innerHTML = purified
      })
      parent?.appendChild(fragment)
      return h1
    }

    if (event === "html/p") {

      const fragment = document.createDocumentFragment()
      const p = document.createElement("p")
      fragment.appendChild(p)
      this.convert("text/purified", input).then(purified => {
        p.innerHTML = purified
      })
      parent?.appendChild(fragment)
      return p
    }

    if (event === "icon/path") {

      return new Promise(async(resolve, reject) => {
        try {
          const icon = await this.convert("path/icon", input)
          parent?.append(icon)
          resolve(icon)
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "icon/node/path") {

      return new Promise(async(resolve, reject) => {
        try {
          const icon = await this.convert("path/icon", input)
          parent?.append(icon)
          resolve(icon)
        } catch (error) {
          reject(error)
        }
      })

    }

    if (event === "img/box") {

      const fragment = document.createDocumentFragment()
      const box = this.create("div", fragment)
      this.style(box, {width: "233px", height: "144px", margin: "21px"})
      this.convert("parent/box", box)
      const img = this.render("img", input, box)
      this.style(img, {borderRadius: "5px", width: "100%"})
      parent?.appendChild(fragment)
      return box
    }

    if (event === "img") {

      const img = document.createElement("img")
      if (parent) this.render("node", img, parent)
      img.src = input
      img.style.width = "100%"
      return img
    }

    if (event === "img/div") {

      const fragment = document.createDocumentFragment()
      const box = this.create("div", fragment)
      this.style(box, {margin: "21px 34px"})
      const img = this.render("img", input, box)
      this.style(img, {borderRadius: "5px", width: "100%"})
      parent?.appendChild(fragment)
      return box
    }

    if (event === "image-url/selector/self") {

      return new Promise(async(resolve, reject) => {
        try {
          const parentNode = document.querySelector(parent)
          if (parentNode === null) throw new Error("selector not found")
          const res = await this.request("/get/user/tree-closed/", {tree: input})
          if (res.status === 200) {
            const oldHtml = parentNode.innerHTML
            parentNode.innerHTML = ""
            parentNode.style.display = "flex"
            parentNode.style.justifyContent = "center"
            parentNode.style.alignItems = "center"
            const image = document.createElement("img")
            parentNode.append(image)
            image.src = res.response
            image.style.width = "300px"
            image.style.margin = "34px"
            parentNode.onclick = async () => {
              parentNode.innerHTML = await Helper.convert("text/purified", oldHtml)
              parentNode.onclick = null
              const urlInput = parentNode.querySelector(".field-input")
              urlInput.oninput = () => this.verify("input/value", urlInput)
              const submitButton = parentNode.querySelector(".submit-field-funnel-button")
              submitButton.addEventListener("click", async () => {
                await this.verify("input/value", urlInput)
                const res = await this.request("/register/user/text-tree-self", {text: urlInput.value, tree: input})
                if (res.status === 200) {
                  window.alert("Daten erfolgreich gespeichert.")
                  if (submitButton.hasAttribute("next-path")) {
                    window.location.assign(submitButton.getAttribute("next-path"))
                  } else {
                    window.location.reload()
                  }
                }
              })
            }
          } else {
            const urlInput = parentNode.querySelector(".field-input")
            urlInput.oninput = () => this.verify("input/value", urlInput)
            const submitButton = parentNode.querySelector(".submit-field-funnel-button")
            submitButton.addEventListener("click", async () => {
              await this.verify("input/value", urlInput)
              const res = await this.request("/register/user/text-tree-self", {text: urlInput.value, tree: input})
              if (res.status === 200) {
                window.alert("Daten erfolgreich gespeichert.")
                window.location.reload()
              }
            })
          }
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "field-funnel/owner") {

      const funnel = this.create("div/scrollable", parent)

      const firstnameField = this.create("field/text", funnel)
      if (input.firstname) firstnameField.input.value = input.firstname
      firstnameField.label.textContent = "Vorname"
      firstnameField.input.placeholder = "Max"
      firstnameField.input.setAttribute("required", "true")
      firstnameField.input.maxLength = "55"
      firstnameField.input.addEventListener("input", () => this.verify("input/value", firstnameField.input))
      this.verify("input/value", firstnameField.input)

      const lastnameField = this.create("field/text", funnel)
      if (input.lastname) lastnameField.input.value = input.lastname
      lastnameField.label.textContent = "Nachname"
      lastnameField.input.placeholder = "Muster"
      lastnameField.input.setAttribute("required", "true")
      lastnameField.input.maxLength = "55"
      lastnameField.input.addEventListener("input", () => this.verify("input/value", lastnameField.input))
      this.verify("input/value", lastnameField.input)

      const streetField = this.create("field/text", funnel)
      if (input.street) streetField.input.value = input.street
      streetField.label.textContent = "Straße und Hausnummer"
      streetField.input.setAttribute("required", "true")
      streetField.input.placeholder = "Wiesentalstr. 21"
      streetField.input.maxLength = "55"
      streetField.input.addEventListener("input", () => this.verify("input/value", streetField.input))
      this.verify("input/value", streetField.input)

      const zipField = this.create("field/text", funnel)
      if (input.zip) zipField.input.value = input.zip
      zipField.label.textContent = "Postleitzahl und Ort"
      zipField.input.placeholder = "70184 Stuttgart"
      zipField.input.setAttribute("required", "true")
      zipField.input.maxLength = "55"
      zipField.input.addEventListener("input", () => this.verify("input/value", zipField.input))
      this.verify("input/value", zipField.input)

      const stateField = this.create("field/select", funnel)
      stateField.label.textContent = "Bundesland oder Kanton"

      const countryField = this.create("field/select", funnel)
      countryField.label.textContent = "Land"
      countryField.input.add(["Deutschland", "Österreich", "Schweiz"])
      if (input.country) countryField.input.select([input.country])
      if (countryField.input.value === "Deutschland") stateField.input.add(["Baden-Württemberg", "Bayern", "Berlin", "Brandenburg", "Bremen", "Hamburg", "Hessen", "Mecklenburg-Vorpommern", "Niedersachsen", "Nordrhein Westfalen", "Rheinland-Pfalz", "Saarland", "Sachsen", "Sachsen-Anhalt", "Schleswig-Holstein", "Thüringen"])
      if (countryField.input.value === "Österreich") stateField.input.add(["Burgenland", "Kärnten", "Niederösterreich", "Oberösterreich", "Salzburg", "Steiermark", "Tirol", "Vorarlberg", "Wien"])
      if (countryField.input.value === "Schweiz") stateField.input.add(["Aargau", "Appenzell Ausserrhoden", "Appenzell Innerrhoden", "Basel-Land", "Basel-Stadt", "Bern", "Fribourg Freiburg", "Genève Geneva", "Glarus", "Graubünden Grischuns Grigioni", "Jura", "Luzern Lucerne", "Neuchâtel", "Nidwalden", "Obwalden", "St.Gallen", "Schaffhausen", "Schwyz", "Solothurn", "Thurgau", "Ticino", "Uri", "Vaud", "Valais Wallis", "Zug", "Zürich"])
      if (input.state) stateField.input.select([input.state])
      countryField.input.addEventListener("input", () => {

        if (countryField.input.value === "Deutschland") stateField.input.add(["Baden-Württemberg", "Bayern", "Berlin", "Brandenburg", "Bremen", "Hamburg", "Hessen", "Mecklenburg-Vorpommern", "Niedersachsen", "Nordrhein Westfalen", "Rheinland-Pfalz", "Saarland", "Sachsen", "Sachsen-Anhalt", "Schleswig-Holstein", "Thüringen"])
        if (countryField.input.value === "Österreich") stateField.input.add(["Burgenland", "Kärnten", "Niederösterreich", "Oberösterreich", "Salzburg", "Steiermark", "Tirol", "Vorarlberg", "Wien"])
        if (countryField.input.value === "Schweiz") stateField.input.add(["Aargau", "Appenzell Ausserrhoden", "Appenzell Innerrhoden", "Basel-Land", "Basel-Stadt", "Bern", "Fribourg Freiburg", "Genève Geneva", "Glarus", "Graubünden Grischuns Grigioni", "Jura", "Luzern Lucerne", "Neuchâtel", "Nidwalden", "Obwalden", "St.Gallen", "Schaffhausen", "Schwyz", "Solothurn", "Thurgau", "Ticino", "Uri", "Vaud", "Valais Wallis", "Zug", "Zürich"])

      })
      this.verify("input/value", stateField.input)
      this.verify("input/value", countryField.input)

      const phoneField = this.create("field/tel", funnel)
      if (input.phone) phoneField.input.value = input.phone
      phoneField.label.textContent = "Telefon"
      phoneField.input.setAttribute("required", "true")
      phoneField.input.maxLength = "21"
      phoneField.input.accept = "text/tel"
      phoneField.input.placeholder = "+49.."
      phoneField.input.addEventListener("input", () => this.verify("input/value", phoneField.input))
      this.verify("input/value", phoneField.input)

      const submit = this.create("button/action", funnel)
      submit.textContent = "Besitzerdaten jetzt speichern"
      submit.addEventListener("click", async () => {

        await this.verify("field-funnel", funnel)

        this.overlay("security", async securityOverlay => {

          const map = {}
          map.firstname = firstnameField.input.value
          map.lastname = lastnameField.input.value
          map.street = streetField.input.value
          map.zip = zipField.input.value
          map.country = countryField.input.value
          map.state = stateField.input.value
          map.phone = phoneField.input.value
          const res = await this.request("/register/owner/closed/", map)

          if (res.status === 200) {
            window.alert("Besitzerdaten erfolgreich gespeichert.")
            securityOverlay.remove()
            parent.remove()
          }

          if (res.status !== 200) {
            window.alert("Fehler.. Bitte wiederholen.")
            securityOverlay.remove()
          }


        })

      })

    }

    if (event === "image/node/src") {
      const image = this.create("div/image", input)
      parent?.appendChild(image)
      return image
    }

    if (event === "object-node") {

      function getNodeWithClass(name, node) {
        if (node.classList && node.classList.contains(name)) {
          return node
        }
        for (let i = 0; i < node.children.length; i++) {
          const result = getNodeWithClass(name, node.children[i])
          if (result) {
            return result
          }
        }
        return null
      }

      function renderObjectInNode(object, node) {
        Object.entries(object).forEach(([key, value]) => {
          for (let i = 0; i < node.querySelectorAll("*").length; i++) {
            const child = node.querySelectorAll("*")[i]

            if (key === "website") {
              const websiteNode = getNodeWithClass(key, node)
              if (websiteNode) {
                websiteNode.style.cursor = "pointer"
                websiteNode.onclick = () => window.open(value, "_blank")
                Helper.add("outline-hover", websiteNode)
              }
            }

            if (key === "logo" || key === "image") {
              const imageNode = getNodeWithClass(key, node)
              if (imageNode) {
                imageNode.src = "#"
                imageNode.dataset.src = value
                imageNode.loading = "lazy"
                Helper.add("lazy-loading", imageNode)
                imageNode.onerror = () => imageNode.src = "/public/image.svg"
              }
            }

            if (key === "name") {
              const nameNode = getNodeWithClass(key, node)
              if (nameNode) {
                nameNode.textContent = value
              }
            }
          }
        })
      }
      renderObjectInNode(input, parent)
      Object.entries(input).forEach(([key, value]) => {
        renderObjectInNode(value, parent)
      })
      return parent

    }

    if (event === "user-keys/update-buttons") {


      parent.textContent = ""
      for (let i = 0; i < input.keys.length; i++) {
        const key = input.keys[i]

        const keysButton = this.create("button/left-right", parent)
        keysButton.left.textContent = `.${key}`

        keysButton.onclick = () => {
          this.overlay("popup", overlay => {

            const info = this.create("header/info", overlay)
            info.textContent = input.user.email
            info.append(this.convert("text/span", `/keys/${key}`))

            const content = this.create("div/scrollable", overlay)

            {

              const button = this.create("button/left-right", content)
              button.left.textContent = ".body"
              button.right.textContent = "Datensatz Inhalt"
              button.onclick = () => {


                this.overlay("popup", async overlay => {

                  const info = this.create("header/info", overlay)
                  info.textContent = input.user.email
                  info.append(this.convert("text/span", `/keys/${key}/body`))

                  const content = this.create("info/loading", overlay)

                  const res = await this.request("/get/user/key-admin/", {id: input.user.id, key})

                  if (res.status === 200) {

                    let body
                    try {
                      body = JSON.parse(res.response)
                    } catch (error) {
                      body = res.response
                    }



                    if (typeof body === "number") {

                      this.convert("parent/scrollable", content)

                      const numberField = this.create("field/tel", content)
                      numberField.label.textContent = "Dieser Datensatz enthält eine Nummer"
                      numberField.input.style.fontFamily = "monospace"
                      numberField.input.style.fontSize = "13px"
                      numberField.input.setAttribute("required", "true")
                      numberField.input.setAttribute("accept", "text/number")
                      numberField.input.value = body
                      this.verify("input/value", numberField.input)
                      numberField.oninput = () => this.verify("input/value", numberField.input)

                      const submit = this.create("button/action", content)
                      submit.textContent = "Zeichenkette jetzt speichern"
                      submit.onclick = async () => {

                        await this.verify("input/value", numberField.input)

                        const number = numberField.input.value

                        this.overlay("security", async securityOverlay => {

                          const res = await this.request("/update/user/number-tree-admin/", {number, id: input.user.id, tree: key})

                          if (res.status === 200) {
                            window.alert("Datensatz erfolgreich gespeichert.")
                            overlay.remove()
                            securityOverlay.remove()
                          }

                          if (res.status !== 200) {
                            window.alert("Fehler.. Bitte wiederholen.")
                            securityOverlay.remove()
                          }

                        })


                      }
                    }

                    if (typeof body === "string") {

                      this.convert("parent/scrollable", content)

                      const textField = this.create("field/textarea", content)
                      textField.label.textContent = "Dieser Datensatz enthält eine Zeichenkette"
                      textField.input.style.height = "55vh"
                      textField.input.style.fontFamily = "monospace"
                      textField.input.style.fontSize = "13px"
                      textField.input.value = body
                      this.verify("input/value", textField.input)

                      const submit = this.create("button/action", content)
                      submit.textContent = "Zeichenkette jetzt speichern"
                      submit.onclick = () => {

                        const text = textField.input.value

                        this.overlay("security", async securityOverlay => {

                          const res = await this.request("/update/user/text-tree-admin/", {text, id: input.user.id, tree: key})
                          if (res.status === 200) {
                            window.alert("Datensatz erfolgreich gespeichert.")
                            overlay.remove()
                            securityOverlay.remove()
                          }

                          if (res.status !== 200) {
                            window.alert("Fehler.. Bitte wiederholen.")
                            securityOverlay.remove()
                          }

                        })


                      }
                    }

                    if (typeof body === "object") {

                      this.convert("parent/scrollable", content)

                      const keys = []
                      for (let i = 0; i < Object.keys(body).length; i++) {
                        const item = Object.keys(body)[i]
                        keys.push(`${key}.${item}`)
                      }

                      this.render(event, {user: input.user, keys}, content)

                    }

                  }

                  if (res.status !== 200) {
                    this.convert("parent/info", content)
                    content.textContent = "Dieser Datensatz ist leer."
                  }

                })




              }

            }

            {

              const button = this.create("button/left-right", content)
              button.left.textContent = ".key"
              button.right.textContent = "Schlüssel Name ändern"
              button.onclick = () => {

                this.overlay("popup", async keyOverlay => {

                  const info = this.create("header/info", keyOverlay)
                  info.textContent = input.user.email
                  info.append(this.convert("text/span", `/${key}`))

                  const content = this.create("div/scrollable", keyOverlay)

                  const textField = this.create("field/text", content)
                  textField.label.textContent = "Schlüssel Name"
                  textField.input.style.fontFamily = "monospace"
                  textField.input.style.fontSize = "13px"
                  textField.input.setAttribute("required", "true")
                  textField.input.setAttribute("accept", "text/tag")
                  textField.input.value = key.split(".")[key.split(".").length - 1]
                  this.verify("input/value", textField.input)

                  const submit = this.create("button/action", content)
                  submit.textContent = "Name jetzt speichern"
                  submit.onclick = async () => {

                    await this.verify("input/value", textField.input)

                    this.overlay("security", async securityOverlay => {

                      const res = await this.request("/update/user/key-name-tree-admin/", {name: textField.input.value, id: input.user.id, tree: key})

                      if (res.status === 200) {
                        window.alert("Datensatz erfolgreich gespeichert.")
                        overlay.previousSibling.remove()
                        overlay.remove()
                        keyOverlay.remove()
                        securityOverlay.remove()
                      }

                      if (res.status !== 200) {
                        window.alert("Fehler.. Bitte wiederholen.")
                        securityOverlay.remove()
                      }

                    })


                  }

                })

              }

            }

            {

              const button = this.create("button/left-right", content)
              button.left.textContent = ".delete"
              button.right.textContent = "Datensatz entfernen"

              button.onclick = () => {

                const confirm = window.confirm("Du bist gerade dabei einen Datensatz aus der persönlichen Datenbank des Nuzters zu löschen. Diese Daten werden gelöscht und können nicht mehr wiederhergestellt werden.\n\nMöchtest du diesen Datensatz wirklich löschen?")
                if (confirm === true) {

                  this.overlay("security", async securityOverlay => {

                    const res = await this.request("/remove/user/tree-admin/", {tree: key, id: input.user.id})
                    if (res.status === 200) {
                      alert("Datensatz erfolgreich gelöscht.")
                      keysButton.remove()
                      overlay.remove()
                      securityOverlay.remove()
                    } else {
                      alert("Fehler.. Bitte wiederholen.")
                      overlay.remove()
                      securityOverlay.remove()
                    }

                  })

                }

              }

            }


          })
        }

      }



    }

    if (event === "role/role-apps-button-onbody") {

      const button = this.create("button/left-right")
      button.classList.add("role-button")
      button.left.textContent = input.name
      button.left.classList.add("left")
      button.right.textContent = "Rolle"
      button.right.classList.add("right")
      button.onclick = () => {

        parent.querySelectorAll(".role-button").forEach(button => {

          const right = button.querySelector(".right")
          this.convert("element/button-right", right)
          right.textContent = "Rolle"

        })

        this.convert("element/checked", button.right)

        this.create("button/role-apps", document.body)

        this.render("script/role-apps-event", input, document.body)

      }

      if (parent) parent.append(button)
      return button

    }

    if (event === "script/role-apps-event") {

      if (input !== undefined) {

        const text = /*html*/`
        <script id="role-apps-event" type="module">
          import {Helper} from "/js/Helper.js"

          await Helper.add("event/role-apps", {id: ${input.id}, tag: "${input.name}"})
        </script>
        `

        const script = this.convert("text/first-child", text)

        const create = document.createElement("script")
        create.id = script.id
        create.type = script.type
        create.textContent = script.textContent

        if (parent !== undefined) {

          if (parent.querySelector(`#${create.id}`) !== null) {
            parent.querySelector(`#${create.id}`).remove()
          }

          if (parent.querySelector(`#${create.id}`) === null) {
            parent.append(create)
          }

        }

        return create
      }

    }

    if (event === "login-button") {

      const fragment = document.createDocumentFragment()
      const it = this.create("toolbox/left-right")
      fragment.appendChild(it)
      it.left.textContent = ".login"
      it.right.textContent = "Dein Zugang zur personalisierten Erfahrung"
      it.addEventListener("click", () => {
        window.open(input, "_blank")
      })
      parent?.appendChild(fragment)
      return it
    }

    if (event === "match-maker/buttons") {

      parent.textContent = ""
      for (let i = 0; i < input.length; i++) {
        const matchMaker = input[i]

        const button = this.create("button/left-right", parent)
        button.right.textContent = matchMaker.id
        button.left.textContent = matchMaker.name

        button.onclick = () => {

          this.overlay("toolbox", async overlay => {
            overlay.info.textContent = `.match-maker.${matchMaker.name}`

            {
              const button = this.create("button/left-right", overlay)
              button.left.textContent = ".action"
              button.right.textContent = "Optimiere deinen Match Maker"

              button.onclick = () => {
                this.overlay("toolbox", overlay => {
                  overlay.info.textContent = `.${matchMaker.name}.action`

                  const content = this.create("div/scrollable", overlay)
                  const actionField = this.create("field/select", content)
                  actionField.label.textContent = "Wenn alle Bedingungen erfüllt sind dann .."
                  actionField.input.add(["get users", "remove", "show", "onclick", "onload", "get list", "get keys"])
                  this.verify("input/value", actionField.input)

                  const dataMirrorField = this.create("field/trees", content)
                  dataMirrorField.label.textContent = "Gebe eine JavaScript Liste mit Datenstrukturen ein und spiegel deine Nutzerliste mit den angefragten Daten"
                  dataMirrorField.input.style.fontSize = "13px"
                  dataMirrorField.input.placeholder = `["getyour.expert.name", "getyour.funnel.name"]`
                  dataMirrorField.input.oninput = () => this.verify("input/value", dataMirrorField.input)
                  this.verify("input/value", dataMirrorField.input)

                  const jsField = this.create("field/js")
                  jsField.label.textContent = "JavaScript Browser Funktionen + Plattform Helper Funktionen (javascript)"
                  jsField.input.oninput = () => this.verify("input/value", jsField.input)

                  const treeField = this.create("field/tree")
                  treeField.input.placeholder = "getyour.expert.platforms"
                  treeField.label.textContent = "Welche Liste möchtest du anzeigen lassen (text/tree)"
                  treeField.input.oninput = () => this.verify("input/value", treeField.input)


                  actionField.input.oninput = (event) => {
                    const selected = this.convert("select/selected", event.target)

                    dataMirrorField.remove()
                    jsField.remove()
                    treeField.remove()


                    if (selected === "get users") {
                      actionField.after(dataMirrorField)
                      this.verify("input/value", dataMirrorField.input)
                    }

                    if (selected === "onclick") {
                      actionField.after(jsField)
                      this.verify("input/value", jsField.input)
                    }

                    if (selected === "onload") {
                      actionField.after(jsField)
                      this.verify("input/value", jsField.input)
                    }

                    if (selected === "get keys") {
                      actionField.after(dataMirrorField)
                      this.verify("input/value", dataMirrorField.input)
                    }

                    if (selected === "get list") {
                      actionField.after(treeField)
                      this.verify("input/value", treeField.input)
                    }
                  }


                  const submit = this.create("button/action", content)
                  submit.textContent = "Match Maker jetzt anhängen"
                  submit.onclick = async () => {

                    const selected = this.convert("select/selected", actionField.input)

                    if (selected === "onload") {

                      await this.verify("input/value", jsField.input)

                      const map = {}
                      map.name = matchMaker.name
                      map.conditions = conditions
                      map.js = jsField.input.value

                      const onloadScript = this.create("script/match-maker-onload", map)

                      this.add("script-onbody", onloadScript)

                    }

                    if (selected === "onclick") {

                      await this.verify("input/value", jsField.input)

                      const map = {}
                      map.name = matchMaker.name
                      map.conditions = conditions
                      map.js = jsField.input.value

                      const onclickScript = this.create("script/match-maker-onclick", map)

                      this.add("script-onbody", onclickScript)

                    }


                    if (selected === "show") {

                      const map = {}
                      map.name = matchMaker.name
                      map.conditions = conditions

                      const showScript = this.create("script/match-maker-show", map)

                      this.add("script-onbody", showScript)

                    }

                    if (selected === "remove") {

                      const map = {}
                      map.name = matchMaker.name
                      map.conditions = conditions

                      const removeScript = this.create("script/match-maker-remove", map)

                      this.add("script-onbody", removeScript)

                    }

                    if (selected === "get list") {

                      await this.verify("input/value", treeField.input)

                      const map = {}
                      map.name = matchMaker.name
                      map.conditions = conditions
                      map.tree = treeField.input.value

                      const getterScript = this.create("script/match-maker-get-list", map)

                      this.add("script-onbody", getterScript)

                    }

                    if (selected === "get keys") {

                      await this.verify("input/value", dataMirrorField.input)

                      const map = {}
                      map.name = matchMaker.name
                      map.conditions = conditions

                      try {
                        map.mirror = JSON.parse(dataMirrorField.input.value)
                        if (map.mirror.length === 0) throw new Error("mirror is empty")
                      } catch (error) {
                        this.add("style/not-valid", dataMirrorField.input)
                        throw error
                      }

                      const getterScript = this.create("script/match-maker-get-keys", map)

                      this.add("script-onbody", getterScript)

                    }

                    if (selected === "get users") {

                      await this.verify("input/value", dataMirrorField.input)

                      const map = {}
                      map.name = matchMaker.name
                      map.conditions = conditions

                      try {
                        map.mirror = JSON.parse(dataMirrorField.input.value)
                        if (map.mirror.length === 0) throw new Error("mirror is empty")
                      } catch (error) {
                        this.add("style/not-valid", dataMirrorField.input)
                        throw error
                      }

                      const getterScript = this.create("script/match-maker-get-users", map)

                      this.add("script-onbody", getterScript)

                    }

                    window.alert("Skript wurde erfolgreich angehängt.")

                  }

                })
              }


            }

            const conditionsContainer = this.create("info/loading", overlay)

            const res = await this.request("/get/match-maker/conditions-expert/", {id: matchMaker.created})

            let conditions
            if (res.status === 200) {
              conditions = JSON.parse(res.response)

              this.convert("element/reset", conditionsContainer)
              this.render("text/hr", `Bedingungen von ${matchMaker.name}`, conditionsContainer)
              for (let i = 0; i < conditions.length; i++) {
                const condition = conditions[i]
                this.render("text/code", `(${condition.left} ${condition.operator} ${condition.right})`, conditionsContainer)
              }

            }

            if (res.status !== 200) {
              const res = await this.request("/get/match-maker/conditions-writable/", {id: matchMaker.id})

              if (res.status === 200) {
                conditions = JSON.parse(res.response)

                this.convert("element/reset", conditionsContainer)
                this.render("text/hr", `Bedingungen von ${matchMaker.name}`, conditionsContainer)
                for (let i = 0; i < conditions.length; i++) {
                  const condition = conditions[i]
                  this.render("text/code", `(${condition.left} ${condition.operator} ${condition.right})`, conditionsContainer)
                }

              }

              if (res.status !== 200) {
                this.convert("parent/info", conditionsContainer)
                conditionsContainer.textContent = "Keine Bedingungen definiert."
                throw new Error("conditions not found")
              }
            }




          })

        }


      }

    }

    if (event === "match-maker/conditions-expert") {

      return new Promise(async(resolve, reject) => {
        try {
          this.convert("element/reset", parent)
          const res = await this.request("/get/match-maker/conditions-expert/", {id: input})
          if (res.status === 200) {
            const array = JSON.parse(res.response)
            for (let i = 0; i < array.length; i++) {
              const condition = array[i]
              const conditionButton = this.create("button/left-right", parent)
              conditionButton.left.textContent = `condition-${array.length - i}`
              conditionButton.right.textContent = condition.created
              conditionButton.onclick = () => {
                this.overlay("popup", buttonsOverlay => {
                  buttonsOverlay.info.textContent = `.condition.${condition.created}`
                  const buttons = this.create("div/scrollable", buttonsOverlay)
                  {
                    const button = this.create("button/left-right", buttons)
                    button.left.textContent = ".update"
                    button.right.textContent = "Bedingungen ändern"
                    button.onclick = () => {
                      this.overlay("popup", async overlay => {
                        overlay.info.textContent = `.update.${condition.created}`
                        const funnel = this.create("funnel/condition", overlay)
                        funnel.leftField.input.value = condition.left
                        funnel.operatorField.input.value = condition.operator
                        funnel.rightField.input.value = condition.right
                        this.verifyIs("field-funnel/valid", funnel)
                        funnel.submit.onclick = async () => {
                          await this.verify("field-funnel", funnel)
                          this.overlay("security", async securityOverlay => {
                            const res = await this.request("/update/match-maker/condition/", {id: condition.created, left: funnel.leftField.input.value, operator: funnel.operatorField.input.value, right: funnel.rightField.input.value})
                            if (res.status === 200) {
                              window.alert("Bedingung erfolgreich gespeichert.")
                              await this.render(event, input, parent)
                              buttonsOverlay.remove()
                              overlay.remove()
                              securityOverlay.remove()
                            } else {
                              window.alert("Fehler.. Bitte wiederholen.")
                              securityOverlay.remove()
                            }
                          })
                        }
                      })
                    }
                  }
                  {
                    const button = this.create("button/left-right", buttons)
                    button.left.textContent = ".delete"
                    button.right.textContent = "Bedingung entfernen"
                    button.onclick = () => {
                      this.overlay("security", async securityOverlay => {
                        const res = await this.request("/remove/match-maker/condition/", {id: condition.created})
                        if (res.status === 200) {
                          window.alert("Bedingung erfolgreich entfernt.")
                          await this.render(event, input, parent)
                          buttonsOverlay.remove()
                          securityOverlay.remove()
                        }
                        if (res.status !== 200) {
                          window.alert("Fehler.. Bitte wiederholen.")
                          securityOverlay.remove()
                        }
                      })
                    }
                  }
                })
              }
            }
          } else {
            this.convert("parent/info", parent)
            parent.textContent = "Keine Bedingungen gefunden"
          }
          resolve()
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "match-maker/expert") {

      return new Promise(async(resolve, reject) => {
        try {
          this.convert("element/reset", parent)
          const res = await this.request("/get/match-maker/expert-self/", {platform: input})
          if (res.status === 200) {
            const array = JSON.parse(res.response)
            for (let i = 0; i < array.length; i++) {
              const matchMaker = array[i]
              const matchMakerButton = this.create("button/left-right", parent)
              matchMakerButton.right.textContent = `match-maker-${array.length - i}`
              matchMakerButton.left.textContent = matchMaker.name
              matchMakerButton.onclick = () => {
                this.overlay("popup", overlay => {
                  overlay.info.textContent = `.${matchMaker.name}`
                  const buttons = this.create("div/scrollable", overlay)
                  {
                    const button = this.create("button/left-right", buttons)
                    button.left.textContent = ".conditions"
                    button.right.textContent = "Bedingungen hinzufügen"
                    button.onclick = () => {
                      this.overlay("popup", async overlay => {
                        overlay.info.textContent = `.conditions`
                        const create = this.create("button/left-right", overlay)
                        create.left.textContent = ".create"
                        create.right.textContent = "Neue Bedingung definieren"
                        create.onclick = () => {
                          this.overlay("popup", async overlay => {
                            overlay.info.textContent = ".condition"
                            const funnel = this.create("funnel/condition", overlay)
                            funnel.submit.onclick = async () => {
                              await this.verify("field-funnel", funnel)
                              this.overlay("security", async securityOverlay => {
                                const res = await this.request("/register/match-maker/condition/", {id: matchMaker.created, left: funnel.leftField.input.value, operator: funnel.operatorField.input.value, right: funnel.rightField.input.value})
                                if (res.status === 200) {
                                  window.alert("Deine Bedingung wurde erfolgreich gespeichert.")
                                  await this.render("match-maker/conditions-expert",  matchMaker.created, conditionsContainer)
                                  overlay.remove()
                                  securityOverlay.remove()
                                } else {
                                  window.alert("Fehler.. Bitte wiederholen.")
                                  securityOverlay.remove()
                                }
                              })
                            }
                          })
                        }
                        this.render("text/hr", "Meine Bedingungen", overlay)
                        const conditionsContainer = this.create("div/scrollable", overlay)
                        await this.render("match-maker/conditions-expert",  matchMaker.created, conditionsContainer)
                      })
                    }
                  }
                  {
                    const button = this.create("button/left-right", buttons)
                    button.left.textContent = ".delete"
                    button.right.textContent = "Match Maker entfernen"
                    button.onclick = () => {
                      this.overlay("security", async securityOverlay => {
                        const res = await this.request("/remove/match-maker/expert/", {id: matchMaker.created})
                        if (res.status === 200) {
                          window.alert("Match Maker erfolgreich entfernt.")
                          matchMakerButton.remove()
                          overlay.remove()
                          securityOverlay.remove()
                        } else {
                          window.alert("Fehler.. Bitte wiederholen.")
                          securityOverlay.remove()
                        }
                      })
                    }
                  }
                })
              }
            }
          } else {
            this.convert("parent/info", parent)
            parent.textContent = "Keine Match Maker gefunden"
          }
          resolve()
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "value/input") {

      if (parent.tagName === "INPUT") {

        if (parent.type === "text") {
          parent.value = input
        }

        if (parent.type === "email") {
          parent.value = input
        }

        if (parent.type === "tel") {
          parent.value = input
        }

        if (parent.type === "range") {
          parent.value = input
        }

        if (parent.type === "password") {
          parent.value = input
        }

        if (parent.type === "number") {
          parent.value = input
        }

        if (parent.type === "date") {
          parent.value = input
        }

        if (parent.type === "checkbox") {
          parent.checked = input
        }

      }

      if (parent.tagName === "TEXTAREA") {
        parent.value = input
      }

      if (parent.tagName === "SELECT") {
        for (let i = 0; i < input.length; i++) {
          const text = input[i]

          for (let i = 0; i < parent.options.length; i++) {
            const option = parent.options[i]

            if (option.value === text) option.selected = true
          }

        }
      }

    }

    if (event === "mirror/match-maker-get-keys") {

      return new Promise(async(resolve, reject) => {

        try {

          document.querySelectorAll(`[match-maker="${parent}"]`).forEach(matchMaker => {

            Object.entries(input).forEach(([key, value]) => {
              matchMaker.querySelectorAll(`.${key}`).forEach(element => {

                if (element.classList.contains(key)) {
                  element.textContent = value
                }

              })

            })

          })

          resolve()

        } catch (error) {
          reject(error)
        }

      })

    }

    if (event === "mirror/match-maker-get-list") {

      return new Promise(async(resolve, reject) => {

        try {

          const map = {}
          map.list = input
          map.name = parent
          const mirror = await this.create("div/match-maker-list", map)

          // add events to the mirror
          for (let i = 0; i < mirror.children.length; i++) {
            const child = mirror.children[i]

            // default events
            const quantityInput = child.querySelector("input.quantity")
            this.add("oninput/verify-positive-integer", quantityInput)

            // search and find events
            child.querySelectorAll("*").forEach(element => {

              if (element.hasAttribute("write-details")) {

                const funnel = input.filter(it => `${it.id}` === child.id)[0].funnel

                this.render("object/node/write-details", funnel, element)

              }

              if (element.hasAttribute("popup-details")) {

                const design = document.querySelector(`[popup-details-design="${parent}"]`)
                if (design !== null) design.style.display = "none"

                element.style.cursor = "pointer"
                element.onclick = () => {

                  const funnel = input.filter(it => `${it.id}` === child.id)[0].funnel

                  if (design === null) {

                    this.overlay("toolbox", overlay => {

                      this.removeOverlayButton(overlay)

                      this.render("text/title", "Detailansicht", overlay)

                      const content = this.create("div/scrollable", overlay)
                      content.style.display = "grid"
                      content.style.gridTemplateColumns = "repeat(auto-fit, minmax(300px, 1fr))"
                      content.style.gap = "21px"
                      content.style.margin = "21px 34px"

                      Object.entries(funnel).forEach(([key, value]) => {

                        const keyValuePair = document.createElement("div")
                        keyValuePair.classList.add("key-value-pair")

                        keyValuePair.style.backgroundColor = this.colors.gray[0]
                        keyValuePair.style.border = this.colors.light.border
                        keyValuePair.style.color = this.colors.light.text
                        keyValuePair.style.boxShadow = this.colors.light.boxShadow
                        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                          keyValuePair.style.backgroundColor = this.colors.matte.black
                          keyValuePair.style.border = this.colors.dark.border
                          keyValuePair.style.boxShadow = this.colors.dark.boxShadow
                          keyValuePair.style.color = this.colors.dark.text
                        }
                        keyValuePair.style.display = "flex"
                        keyValuePair.style.flexDirection = "column"
                        keyValuePair.style.padding = "1rem"
                        keyValuePair.style.borderRadius = "5px"
                        content.append(keyValuePair)

                        const keyDiv = document.createElement("key")
                        keyDiv.classList.add("key")
                        keyDiv.style.fontWeight = "bold"
                        keyDiv.style.marginBottom = "0.5rem"
                        keyDiv.textContent = key
                        keyDiv.style.color = this.colors.key
                        keyValuePair.append(keyDiv)

                        const valueDiv = document.createElement("div")
                        valueDiv.textContent = value
                        valueDiv.classList.add("value")
                        valueDiv.style.color = this.colors.value
                        keyValuePair.append(valueDiv)


                      })


                    })

                  }

                  if (design !== null) {

                    this.overlay("popup", overlay => {

                      this.removeOverlayButton(overlay)

                      const content = this.create("div/scrollable", overlay)

                      const clone = design.cloneNode(true)

                      clone.style.display = null

                      content.append(clone)

                      Object.entries(funnel).forEach(([key, value]) => {
                        content.querySelectorAll(`.${key}`).forEach(element => {

                          if (element.tagName === "IMG") {
                            element.src = value
                          } else {
                            element.textContent = value
                          }

                        })

                      })


                    })

                  }

                }

              }

              if (element.hasAttribute("add-to-cart")) {

                element.style.cursor = "pointer"
                element.onclick = () => {

                  const quantityInput = child.querySelector("input.quantity")

                  const quantity = quantityInput.value

                  if (this.verifyIs("text/+int", quantity)) {

                    this.add("style/valid", quantityInput)

                  } else {
                    this.add("style/not-valid", quantityInput)
                  }


                }

              }

            })
          }

          resolve(mirror)

        } catch (error) {
          reject(error)
        }

      })

    }

    if (event === "mirror/match-maker-get-users") {

      return new Promise(async(resolve, reject) => {

        try {

          const sortedUsers = input
          sortedUsers.sort((a, b) => {
            return b.reputation - a.reputation // Descending order, for ascending use: a.reputation - b.reputation
          })

          const userList = this.create("div/scrollable")
          userList.setAttribute("id", `user-list-${parent}`)

          document.querySelectorAll(`[match-maker="${parent}"]`).forEach(matchMaker => {

            for (let i = 0; i < sortedUsers.length; i++) {
              const user = sortedUsers[i]

              const clone = document.createElement("div")
              clone.textContent = matchMaker.textContent
              clone.setAttribute("id", `user-${i + 1}`)
              clone.style.marginBottom = "34px"

              for (let i = 0; i < user.treeValues.length; i++) {
                const treeValuePair = user.treeValues[i]

                const className = treeValuePair.tree.replace(/\./g, "-")

                for (let i = 0; i < clone.children.length; i++) {
                  const child = clone.children[i]
                  if (child.classList.contains(className)) {
                    child.textContent = treeValuePair.value
                  }
                }

              }

              userList.append(clone)

            }

            const userLists = document.querySelectorAll(`#user-list-${parent}`)

            if (userLists.length === 0) {
              matchMaker.before(userList)
              matchMaker.style.display = "none"
            }

            userLists.forEach(list => {
              this.convert("parent/scrollable", list)
              list.textContent = userList.textContent
              matchMaker.style.display = "none"
            })


          })

          resolve(userList)

        } catch (error) {
          reject(error)
        }

      })





    }

    if (event === "object/node/svg") {
      const object = document.createElement("object")
      object.type = "image/svg+xml"
      object.data = input
      parent?.appendChild(object)
      return object
    }

    if (event === "open-profiles") {

      parent.textContent = ""
      this.convert("parent/flex-row", parent)
      parent.style.paddingBottom = "144px"
      for (let i = 0; i < input.length; i++) {
        const profile = input[i]
        const button = this.create("toolbox/left-right", parent)
        button.style.maxWidth = "610px"
        button.right.remove()

        const questions = [
          {question: "Erzähl etwas über dich ?", answer: profile.aboutYou},
          {question: "Was kannst du besonders gut ?", answer: profile.whyThis},
          {question: "Warum sollten wir dich wählen ?", answer: profile.whyYou},
          {question: "Wie motivierst du dich ?", answer: profile.motivation},
        ]

        for (let i = 0; i < questions.length; i++) {
          const it = questions[i]
          const h2 = this.render("text/h2", it.question, button.left)
          h2.style.margin = "0"
          const content = this.render("html/p", it.answer, button.left)
          content.style.height = "144px"
          content.style.overflow = "auto"
        }

        button.onclick = () => {
          this.overlay("popup", overlay => {
            const content = this.create("div/scrollable", overlay)
            {
              const button = this.create("toolbox/left-right", content)
              button.left.textContent = ".message"
              button.right.textContent = "Sende eine Nachricht an dieses Profil"
              button.onclick = () => {

                this.overlay("popup", htmlOverlay => {
                  const content = this.create("div/scrollable", htmlOverlay)
                  const htmlField = this.create("input/textarea", content)
                  htmlField.input.placeholder = `Text oder HTML Nachricht hier rein kopieren

Bitte beachte, dass der Empfänger der Nachricht, keine Möglichkeit hat dich zu kontaktieren.
                  `
                  htmlField.input.style.height = "233px"
                  htmlField.input.setAttribute("required", "true")
                  this.verify("input/value", htmlField.input)
                  htmlField.input.oninput = () => this.verify("input/value", htmlField.input)
                  const submit = this.create("toolbox/action", content)
                  submit.textContent = "Nachricht jetzt senden"
                  submit.onclick = async () => {
                    await this.verify("input/value", htmlField.input)
                    const message = await this.convert("text/purified", htmlField.input.value)
                    if (this.verifyIs("text/empty", message)) {
                      window.alert("Fehler.. Bitte wiederholen.")
                      this.add("style/not-valid", htmlField.input)
                      return
                    }
                    this.overlay("security", async securityOverlay => {
                      const res = await this.request("/register/user/profile-message/", {id: profile.created, message})
                      if (res.status === 200) {
                        window.alert("Deine Nachricht wurde erfolgreich gesendet.")
                        htmlOverlay.remove()
                        overlay.remove()
                        securityOverlay.remove()
                      } else {
                        window.alert("Fehler.. Bitte wiederholen.")
                        securityOverlay.remove()
                      }
                    })
                  }
                })
              }
            }
            {
              const button = this.create("toolbox/left-right", content)
              button.left.textContent = ".conflicts"
              button.right.textContent = "Melde einen Konflikt"
              button.onclick = () => {
                this.overlay("conflicts", profile)
              }
            }

          })
        }

      }
    }

    if (event === "id-map/field-funnel") {

      return new Promise(async(resolve, reject) => {

        try {

          Object.entries(input).forEach(([key, value]) => {
            parent.querySelectorAll(`#${key}`).forEach(async field => {

              const input = field.querySelector(".field-input")

              this.render("value/input", value, input)

            })

          })

          this.verifyIs("field-funnel/valid", parent)

          resolve()

        } catch (error) {
          reject(error)
        }

      })

    }

    if (event === "tree-map/field-funnel") {

      return new Promise(async(resolve, reject) => {
        try {
          Object.entries(input).forEach(([key, value]) => {
            const fieldId = key.split(".")[2]
            parent.querySelectorAll(`#${fieldId}`).forEach(async field => {
              const input = field.querySelector(".field-input")
              this.render("value/input", value, input)
            })
          })
          this.verifyIs("field-funnel/valid", parent)
          resolve()
        } catch (error) {
          reject(error)
        }
      })

    }

    if (event === "tree/node") {

      const container = this.create("info/loading", parent)
      this.request("/get/users/tree-open/", {tree: input}).then(res => {
        if (res.status === 200) {
          const users = JSON.parse(res.response)
          this.convert("style/flex-row", container)
          container.style.paddingBottom = "144px"
          container.style.justifyContent = "space-around"
          for (let i = 0; i < users.length; i++) {
            const user = users[i]
            if (user.verified === true) {
              render(user, container)
            }
          }
        } else {
          this.convert("dark-light", container)
          this.style(container, {margin: "21px 34px", fontFamily: "sans-serif", background: "transparent"})
          container.textContent = `Keine Ergebnisse gefunden`
          container.style.paddingBottom = "144px"
        }
      })

      function render(user, node) {

        const box = Helper.create("button/left-right", node)
        Helper.style(box, {width: "610px", margin: "8px", wordBreak: "break-word"})

        const treeObj = Helper.convert("user-tree", {user, tree: input})

        if (!Helper.verifyIs("text/empty", user.alias)) {
          const h1 = document.createElement("h1")
          h1.textContent = user.alias
          box.left.appendChild(h1)
        }

        if (!Helper.verifyIs("text/empty", user.status)) {
          const p = document.createElement("p")
          p.textContent = user.status
          box.left.appendChild(p)
        }

        if (!Helper.verifyIs("text/empty", user.image)) {
          const image = document.createElement("img")
          image.src = user.image
          image.style.width = "100%"
          image.style.borderRadius = "5px"
          box.left.appendChild(image)
        }

        if (!Helper.verifyIs("text/empty", treeObj.description)) {
          const p = document.createElement("p")
          p.textContent = treeObj.description
          box.left.appendChild(p)
        }

        if (!Helper.verifyIs("text/empty", treeObj.platforms)) {
          const container = Helper.create("div", box.left)
          Helper.style(container, {fontFamily: "sans-serif", display: "flex"})
          const platformDiv = document.createElement("div")
          Helper.style(platformDiv, {display: "flex", justifyContent: "center", alignItems: "center"})
          platformDiv.textContent = `Plattformen:`
          container.appendChild(platformDiv)
          const platformLengthDiv = document.createElement("div")
          Helper.style(platformLengthDiv, {marginLeft: "8px", fontSize: "32px"})
          if (!Helper.verifyIs("number/empty", treeObj.platforms.length)) {
            platformLengthDiv.textContent = treeObj.platforms.length
          }
          container.appendChild(platformLengthDiv)
        }

        if (!Helper.verifyIs("text/empty", treeObj.platforms)) {
          const container = Helper.create("div", box.left)
          Helper.style(container, {fontFamily: "sans-serif", display: "flex"})
          const platformDiv = document.createElement("div")
          Helper.style(platformDiv, {display: "flex", justifyContent: "center", alignItems: "center"})
          platformDiv.textContent = `Werteinheiten:`
          container.appendChild(platformDiv)
          const platformLengthDiv = document.createElement("div")
          Helper.style(platformLengthDiv, {marginLeft: "8px", fontSize: "32px"})
          let counter = 0
          try {
            for (let i = 0; i < treeObj.platforms.length; i++) {
              const platform = treeObj.platforms[i]
              if (platform.values) {
                for (let i = 0; i < platform.values.length; i++) {
                  const value = platform.values[i]
                  counter++
                }
              }
            }
            platformLengthDiv.textContent = counter
          } catch (error) {
            console.log(error)
            platformLengthDiv.textContent = 0
          }
          container.appendChild(platformLengthDiv)
        }

        {
          const container = Helper.create("div", box.left)
          Helper.style(container, {fontFamily: "sans-serif", display: "flex", margin: "21px 0"})
          const platformDiv = document.createElement("div")
          Helper.style(platformDiv, {display: "flex", justifyContent: "center", alignItems: "center"})
          platformDiv.textContent = `Erfahrung:`
          container.appendChild(platformDiv)
          const platformLengthDiv = document.createElement("div")
          Helper.style(platformLengthDiv, {marginLeft: "8px", fontSize: "32px"})
          if (!Helper.verifyIs("number/empty", user.xp)) {
            platformLengthDiv.textContent = user.xp
          }
          if (user.xp === undefined) {
            platformLengthDiv.textContent = "Keine"
            platformLengthDiv.style.color = "red"
          }

          if (user.xp > 0) {
            platformLengthDiv.textContent = "Beginner"
            platformLengthDiv.style.color = "orange"
          }

          if (user.xp > 89) {
            platformLengthDiv.textContent = "Fortgeschritten"
            platformLengthDiv.style.color = "green"
          }
          container.appendChild(platformLengthDiv)
        }

        const reputation = Helper.render("user-reputation", user.reputation, box.left)
        Helper.style(reputation, {fontSize: "21px", margin: "21px 0"})

        return box
      }

    }

    if (event === "map/field-funnel") {

      Object.entries(input).forEach(([key, value]) => {
        for (let i = 0; i < parent.querySelectorAll("*").length; i++) {
          const field = parent.querySelectorAll("*")[i]
          if (field.id === key) {
            const input = field.querySelector(".field-input")
            input.value = value
          }
        }
      })
      this.verifyIs("field-funnel/valid", parent)
    }

    if (event === "map/div") {

      return new Promise(async(resolve, reject) => {

        const div = this.create("div", parent)
        div.classList.add("json")
        div.style.margin = "21px 34px"

        const buttons = document.createElement("div")
        buttons.classList.add("buttons")
        buttons.style.display = "flex"
        buttons.style.justifyContent = "space-between"
        buttons.style.alignItems = "center"
        div.append(buttons)

        const foldAllButton = this.create("div/action", buttons)
        foldAllButton.textContent = "fold"

        foldAllButton.addEventListener("click", function() {
          toggleAllValues("none");
        });

        const unfoldAllButton = this.create("div/action", buttons)
        unfoldAllButton.textContent = "unfold"
        unfoldAllButton.addEventListener("click", function() {
          toggleAllValues("block");
        });

        function toggleAllValues(displayValue) {
          const valueElements = div.querySelectorAll(".key-value");
          valueElements.forEach(element => {
            element.style.display = displayValue;
          });
        }

        function toggleValue(event) {
          const element = event.target.nextSibling
          if (element !== null) {
            element.style.display = element.style.display === "none" ? "block" : "none";
          }
        }

        function processObject(container, obj) {
          for (const key in obj) {
            const value = obj[key];

            const keyElement = Helper.convert("key/div", key)
            const valueElement = Helper.convert("value/div", value)


            if (Helper.verifyIs("string", value)) {
              valueElement.setAttribute("value-type", "string")
            }


            if (Helper.verifyIs("boolean", value)) {
              valueElement.setAttribute("value-type", "boolean")
            }

            const keyName = document.createElement("div")
            keyName.classList.add("key-name")
            keyName.textContent = key

            keyElement.appendChild(keyName)
            container.appendChild(keyElement);
            keyElement.appendChild(valueElement);

            keyElement.addEventListener("click", toggleValue);

            if (typeof value === "object") {
              processObject(valueElement, value);
              valueElement.addEventListener("click", toggleValue);

            } else {
              valueElement.textContent = JSON.stringify(value);
            }
          }
        }


        try {

          processObject(div, input);

          return resolve(div)
        } catch (error) {
          await this.add("ms/timeout", 3000)
          await this.render(event, input, parent)
        }

      })


    }

    if (event === "nav/open") {

      this.create("start-button", input)
      Helper.render("login-button", "/login/", input)
      {
        const button = this.create("button/left-right", input)
        button.left.textContent = ".user-agreement"
        button.right.textContent = "Für Klarheit und Fairness im Umgang miteinander"
        button.addEventListener("click", () => window.open("/nutzervereinbarung/", "_blank"))
      }
      {
        const button = this.create("button/left-right", input)
        button.left.textContent = ".data-protection"
        button.right.textContent = "Fördert Vertrauen in digitale Interaktionen"
        button.addEventListener("click", () => window.open("/datenschutz/", "_blank"))
      }
    }

    if (event === "next/path") {

      let path = input.getAttribute("next")
      const fragment = document.createDocumentFragment()
      const field = this.create("input/path", fragment)
      if (path) field.input.value = path
      this.verify("input/value", field.input)
      field.input.oninput = ev => {
        const value = ev.target.value
        if (this.verifyIs("text/path", value)) {
          this.add("style/valid", field.input)
          input.setAttribute("next", value)
        } else {
          this.add("style/not-valid", field.input)
          input.removeAttribute("next")
        }
      }
      parent?.appendChild(fragment)
      return field
    }

    if (event === "script-onbody") {

      return new Promise(async resolve => {

        if (document.body) {
          document.querySelectorAll(`#${input.id}`).forEach(script => script.remove())
          if (document.getElementById(`#${input.id}`) === null) {
            document.body.append(input)
            return resolve(input)
          }
        } else {
          await this.add("ms/timeout", 3000)
          await this.add(event, input)
        }


      })

    }

    if (event === "checklist/items") {
      const checklist = this.create("div/scrollable", parent)
      checklist.id = "checklist"

      for (let i = 0; i < input.length; i++) {
        const item = input[i]

        item.index = i + 1
        this.render("checklist/item", item, checklist)

      }


      return checklist
    }

    if (event === "checklist/item") {

      const item = document.createElement("div")
      item.classList.add("item")
      item.style.margin = "34px"

      item.header = document.createElement("div")
      item.header.classList.add("header")
      item.header.style.display = "flex"
      item.header.style.borderTopRightRadius = "21px"
      item.header.style.borderTopLeftRadius = "21px"
      item.header.style.borderBottomLeftRadius = "21px"
      item.header.style.backgroundColor = "#d1d0d0"
      item.append(item.header)

      item.header.state = document.createElement("div")
      item.header.state.classList.add("state")
      item.header.state.style.display = "flex"
      item.header.state.style.justifyContent = "center"
      item.header.state.style.alignItems = "center"
      item.header.state.style.width = "89px"
      item.header.state.style.height = "89px"
      item.header.state.style.backgroundColor = "#c6c6c6"
      item.header.state.style.fontSize = "34px"
      item.header.state.style.borderTopLeftRadius = "21px"
      item.header.state.style.borderBottomLeftRadius = "21px"
      item.header.append(item.header.state)

      item.header.state.index = document.createElement("div")
      item.header.state.index.classList.add("index")
      item.header.state.index.textContent = input.index
      item.header.state.append(item.header.state.index)

      item.header.text = document.createElement("div")
      item.header.text.classList.add("title")
      item.header.text.style.alignSelf = "center"
      item.header.text.style.marginLeft = "13px"
      item.header.text.textContent = input.title
      item.header.text.style.fontSize = "21px"
      item.header.append(item.header.text)

      item.body = document.createElement("div")
      item.body.classList.add("body")
      item.body.style.marginLeft = "8%"
      item.body.style.backgroundColor = "#dbdbdb"
      item.body.style.borderBottomRightRadius = "21px"
      item.body.style.borderBottomLeftRadius = "21px"
      item.body.style.padding = "21px"
      item.body.style.display = "flex"
      item.body.style.flexDirection = "column"
      item.body.style.boxShadow = "0 3px 5px rgba(0, 0, 0, 0.13)"
      item.append(item.body)

      item.body.text = document.createElement("div")
      item.body.text.classList.add("description")
      item.body.text.textContent = input.description
      item.body.text.style.marginBottom = "34px"
      item.body.append(item.body.text)

      item.body.button = document.createElement("div")
      item.body.button.classList.add("button")
      item.body.button.textContent = "Zur Übersicht"
      item.body.button.style.borderRadius = "13px"
      item.body.button.style.width = "233px"
      item.body.button.style.height = "55px"
      item.body.button.style.display = "flex"
      item.body.button.style.justifyContent = "center"
      item.body.button.style.alignItems = "center"
      item.body.button.style.alignSelf = "flex-end"
      item.body.button.style.backgroundColor = "#f7aa20"
      item.body.button.style.fontSize = "21px"
      item.body.button.style.margin = "8px"
      item.body.button.style.cursor = "pointer"
      item.body.append(item.body.button)

      parent?.append(item)
      return item
    }

    if (event === "scripts/update-buttons") {

      if (arguments.length === 2) {
        parent = input
      }

      return new Promise(async(resolve, reject) => {
        try {
          const res = await this.request("/get/scripts/closed/")
          if (res.status === 200) {
            const scripts = JSON.parse(res.response)
            this.convert("parent/scrollable", parent)
            for (let i = 0; i < scripts.length; i++) {
              const script = scripts[i]
              const scriptButton = this.create("toolbox/left-right", parent)
              scriptButton.right.textContent = script.name
              scriptButton.left.textContent = `Skript ${scripts.length - i}`
              scriptButton.onclick = () => {
                this.overlay("popup", overlay => {
                  overlay.info.textContent = `.${script.name}`
                  const content = this.create("div/scrollable", overlay)
                  {
                    const button = this.create("toolbox/left-right", content)
                    button.left.textContent = ".update"
                    button.right.textContent = "Skript bearbeiten"
                    button.onclick = () => {
                      this.overlay("popup", overlay => {
                        overlay.info.textContent = `.${script.name}.update`
                        const funnel = this.create("div/scrollable", overlay)
                        const nameField = this.create("field/tag", funnel)
                        nameField.input.placeholder = "mein-skript"
                        nameField.input.value = script.name
                        this.verify("input/value", nameField.input)
                        nameField.input.oninput = () => this.verify("input/value", nameField.input)
                        const scriptField = this.create("field/script", funnel)
                        scriptField.input.style.height = "100vh"
                        scriptField.input.value = script.html
                        this.verify("input/value", scriptField.input)
                        scriptField.input.oninput = () => this.verify("input/value", scriptField.input)
                        const button = this.create("toolbox/action", funnel)
                        button.textContent = "Skript jetzt speichern"
                        button.onclick = async () => {
                          await this.verify("field-funnel", funnel)
                          this.overlay("security", async securityOverlay => {
                            const res = await this.request("/update/scripts/closed", {id: script.created, html: scriptField.input.value, name: nameField.input.value})
                            if (res.status === 200) {
                              window.alert("Skript erfolgreich gespeichert.")
                              this.convert("parent/loading", parent)
                              await this.render(event, parent)
                              securityOverlay.remove()
                              overlay.previousSibling.remove()
                              overlay.remove()
                            } else {
                              window.alert("Fehler.. Bitte wiederholen.")
                              securityOverlay.remove()
                            }
                          })
                        }
                      })
                    }
                  }
                  {
                    const button = this.create("toolbox/left-right", content)
                    button.left.textContent = ".remove"
                    button.right.textContent = "Skript entfernen"
                    button.onclick = () => {
                      this.overlay("security", async securityOverlay => {
                        const res = await this.request("/remove/scripts/closed/", {id: script.created})
                        if (res.status === 200) {
                          window.alert("Skript erfolgreich entfernt.")
                          scriptButton.remove()
                          securityOverlay.remove()
                          overlay.remove()
                        } else {
                          window.alert("Fehler.. Bitte wiederholen.")
                          securityOverlay.remove()
                        }
                      })
                    }
                  }
                })
              }
            }
          } else {
            this.convert("parent/info", parent)
            parent.textContent = "Keine Skripte gefunden."
          }
          resolve()
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "toolbox-scripts") {

      return new Promise(async(resolve, reject) => {
        try {
          const executeOnceIcon = await this.convert("path/icon", "/public/arrow-repeat-1.svg")
          executeOnceIcon.style.width = "55px"
          const executeAlwaysIcon = await this.convert("path/icon", "/public/arrow-repeat.svg")
          executeAlwaysIcon.style.width = "55px"
          const feedback = this.fn("feedback")
          const feedbackIcon = await feedback.icon()
          const fragment = document.createDocumentFragment()
          this.convert("parent/scrollable", parent)
          for (let i = 0; i < input.length; i++) {
            const script = input[i]
            const scriptButton = this.create("toolbox/left-right", fragment)
            scriptButton.left.textContent = script.name
            if (document.getElementById(script.name) !== null) {
              scriptButton.style.border = `3px solid ${Helper.colors.matte.orange}`
            }
            const buttons = document.createElement("div")
            scriptButton.right.appendChild(buttons)
            buttons.style.display = "flex"
            buttons.style.alignItems = "center"
            buttons.style.justifyContent = "space-around"
            {
              const button = executeOnceIcon.cloneNode(true)
              buttons.appendChild(button)
              this.add("outline-hover", button)
              button.onclick = () => {
                const executer = document.createElement("script")
                const clone = this.convert("text/script", script.html)
                executer.id = script.name
                executer.type = "module"
                executer.textContent = clone.textContent
                document.body.appendChild(executer)
                setTimeout(() => executer.remove(), 34)
              }
            }
            {
              const button = executeAlwaysIcon.cloneNode(true)
              buttons.appendChild(button)
              this.add("outline-hover", button)
              button.onclick = async () => {
                if (document.getElementById(script.name) !== null) {
                  window.alert("Skript existiert bereits.")
                  return
                }
                const clone = this.convert("text/script", script.html)
                const executer = this.create("script", {id: script.name, js: clone.textContent})
                document.body.appendChild(executer)
                updateBorder(scriptButton)
                scriptButton.style.border = `3px solid ${Helper.colors.matte.orange}`
              }
            }
            {
              const button = feedbackIcon.cloneNode(true)
              button.style.position = "relative"
              Helper.create("counter", button)
              feedback.initScriptCounter(script.created, button)
              buttons.appendChild(button)
              this.add("outline-hover", button)
              button.onclick = () => feedback.openScriptOverlay(button, script)
            }
          }
          parent.appendChild(fragment)
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "select/options") {

      if (parent === undefined) {
        document.querySelectorAll(".select-options").forEach(div => {
          this.render(event, input, div)
        })
      }

      if (parent !== undefined) {
        if (!parent.classList.contains("select-options")) {
          parent.classList.add("select-options")
        }
      }

      if (parent !== undefined) {
        parent.textContent = ""
      }

      for (let i = 0; i < input.children.length; i++) {
        const option = input.children[i]

        const button = this.create("button/left-right", parent)
        button.left.textContent = `Option ${i + 1}`
        button.right.textContent = option.value

        button.addEventListener("click", () => {
          this.overlay("toolbox", overlay => {
            overlay.info.append(this.convert("element/alias", option))

            option.ok = () => {
              this.render("select/options", input)
              overlay.remove()
            }

            this.get("funnel/select-option", overlay, option)

          })
        })

      }


    }

    if (event === "tabs") {

      const tabs = input.split(" ")
      const flexRow = Helper.create("div/flex-row", parent)
      flexRow.style.justifyContent = "flex-start"
      const tabButtons = {}
      tabs.forEach(tab => {
        const button = Helper.render("text/link", tab, flexRow)
        const tag = Helper.convert("text/tag", tab)
        tabButtons[tag] = button
        button.addEventListener("click", () => {
          tabs.forEach(tab => {
            Helper.remove("style/selected", tabButtons[Helper.convert("text/tag", tab)])
          })
          Helper.add("style/selected", button)
        })
      })
      return tabButtons
    }

    if (event === "text/a") {

      const fragment = document.createDocumentFragment()
      const a = document.createElement("a")
      a.textContent = input.textContent
      a.href = input.href
      a.style.margin = "0 34px"
      a.style.fontFamily = "sans-serif"
      a.style.display = "inline-block"
      this.convert("link/dark-light", a)
      this.add("pointer", a)
      fragment.appendChild(a)
      parent?.appendChild(fragment)
      return a
    }

    if (event === "text/bottom-left") {

      const text = document.createElement("div")
      text.textContent = input
      text.style.position = "absolute"
      text.style.bottom = "0"
      text.style.left = "0"
      text.style.margin = "3px 13px"
      parent.style.position = "relative"
      parent.style.fontFamily = "sans-serif"
      parent?.appendChild(text)
      return text
    }

    if (event === "text/bottom-right") {

      const text = document.createElement("div")
      text.textContent = input
      text.style.position = "absolute"
      text.style.bottom = "0"
      text.style.right = "0"
      text.style.margin = "3px 13px"
      parent.style.position = "relative"
      parent.style.fontFamily = "sans-serif"
      parent?.appendChild(text)
      return text
    }

    if (event === "text/dark-light") {

      const fragment = document.createDocumentFragment()
      const div = document.createElement("div")
      fragment.appendChild(div)
      div.textContent = input
      div.style.margin = "0 34px"
      this.convert("text/dark-light", div)
      parent?.appendChild(fragment)
      return div
    }

    if (event === "text/info") {
      this.convert("parent/info", parent)
      parent.textContent = input
    }

    if (event === "text/code") {

      const code = document.createElement("div")
      code.textContent = input
      code.style.fontSize = "21px"
      code.style.fontFamily = "monospace"
      code.style.color = this.colors.light.text
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        code.style.color = this.colors.dark.text
      }
      parent?.append(code)
      return code

    }

    if (event === "text/link") {

      const link = this.create("box")
      link.textContent = input
      link.style.fontFamily = "sans-serif"
      link.style.padding = "13px 21px"
      link.style.display = "flex"
      link.style.justifyContent = "center"
      link.style.alignItems = "center"
      this.add("outline-hover", link)
      parent?.appendChild(link)
      return link
    }

    if (event === "text/div") {

      const fragment = document.createDocumentFragment()
      const div = document.createElement("div")
      fragment.appendChild(div)
      div.textContent = input
      div.style.margin = "0 34px"
      div.style.fontFamily = "sans-serif"
      parent?.appendChild(fragment)
      return div
    }

    if (event === "text/h3") {

      const h3 = this.create("h3")
      h3.textContent = input

      h3.style.color = this.colors.light.text
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        h3.style.color = this.colors.dark.text
      }

      if (parent !== undefined) parent.append(h3)
      return h3
    }

    if (event === "text/h2") {

      const h2 = this.create("h2")
      h2.textContent = input

      h2.style.color = this.colors.light.text
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        h2.style.color = this.colors.dark.text
      }

      if (parent !== undefined) parent.append(h2)
      return h2
    }

    if (event === "text/h1") {

      const h1 = this.create("h1")
      h1.textContent = input

      h1.style.color = this.colors.light.text
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        h1.style.color = this.colors.dark.text
      }

      if (parent !== undefined) parent.append(h1)
      return h1
    }

    if (event === "text/hover-bottom-right") {

      const text = this.render("text/bottom-right", input, parent)
      text.className = "text-hover"
      text.style.opacity = "0"
      this.add("onmouseover", {type: "this.querySelector('.text-hover').style.opacity = 1;", node: parent})
      this.add("onmouseout", {type: "this.querySelector('.text-hover').style.opacity = 0;", node: parent})
      return text
    }

    if (event === "text/hr") {

      const container = document.createElement("div")
      const text = document.createElement("div")
      text.textContent = input
      container.append(text)
      const hr = document.createElement("hr")
      container.append(hr)
      text.style.fontFamily = "sans-serif"
      text.style.fontSize = "21px"
      text.style.margin = "0 34px"
      hr.style.margin = "0 21px"
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        text.style.color = this.colors.dark.text
        hr.style.border = `1px solid ${this.colors.dark.text}`
      } else {
        text.style.color = this.colors.light.text
        hr.style.border = `1px solid ${this.colors.light.text}`
      }
      parent?.append(container)
      return container

    }

    if (event === "text/node/bottom-right-onhover") {

      const text = this.render("text/bottom-right", input, parent)
      text.style.opacity = "0"
      parent.addEventListener("mouseover", () => {
        text.style.opacity = "1"
      })
      parent.addEventListener("mouseout", () => {
        text.style.opacity = "0"
      })
      return parent

    }

    if (event === "text/mark") {

      const fragment = document.createDocumentFragment()
      const mark = document.createElement("mark")
      mark.textContent = input
      this.convert("color/dark-light")
      fragment.appendChild(mark)
      parent?.appendChild(fragment)
      return mark
    }

    if (event === "text/p") {

      const fragment = document.createDocumentFragment()
      const p = document.createElement("p")
      p.textContent = input
      p.style.margin = "21px 34px"
      p.style.fontFamily = "sans-serif"
      p.style.color = this.colors.light.text
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        p.style.color = this.colors.dark.text
      }
      fragment.appendChild(p)
      parent?.appendChild(fragment)
      return p
    }

    if (event === "text/pre") {

      const fragment = document.createDocumentFragment()
      const pre = document.createElement("pre")
      pre.textContent = input
      this.style(pre, {margin: "21px 34px", fontFamily: "monospace", fontSize: "8px"})
      this.convert("color/dark-light", pre)
      fragment.appendChild(pre)
      parent?.appendChild(fragment)
      return pre
    }

    if (event === "text/right-hr") {

      const container = document.createElement("div")

      container.text = document.createElement("div")
      container.text.textContent = input
      container.text.style.display = "flex"
      container.text.style.justifyContent = "flex-end"
      container.append(container.text)

      container.hr = document.createElement("hr")
      container.append(container.hr)

      container.text.style.fontFamily = "sans-serif"
      container.text.style.fontSize = "21px"
      container.text.style.margin = "0 34px"

      container.hr.style.margin = "0 21px"

      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        container.text.style.color = this.colors.dark.text
        container.hr.style.border = `1px solid ${this.colors.dark.text}`
      } else {
        container.text.style.color = this.colors.light.text
        container.hr.style.border = `1px solid ${this.colors.light.text}`
      }

      parent?.append(container)
      return container
    }

    if (event === "text/span") {

      const fragment = document.createDocumentFragment()
      const span = document.createElement("span")
      span.textContent = input
      span.style.margin = "21px 34px"
      span.style.fontFamily = "sans-serif"
      this.convert("color/dark-light")
      fragment.appendChild(span)
      parent?.appendChild(fragment)
      return span
    }

    if (event === "text/title") {
      const title = document.createElement("div")
      title.textContent = input
      title.style.margin = "21px 34px"
      title.style.fontSize = "21px"
      title.style.fontFamily = "sans-serif"

      title.style.color = this.colors.light.text
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        title.style.color = this.colors.dark.text
      }

      if (parent !== undefined) parent.append(title)

      return title
    }

    if (event === "text/top-right") {

      const fragment = document.createDocumentFragment()
      const text = document.createElement("div")
      text.textContent = input
      text.style.position = "absolute"
      text.style.top = "0"
      text.style.right = "0"
      text.style.margin = "1px 5px"
      parent.style.position = "relative"
      fragment.appendChild(text)
      parent?.appendChild(fragment)
      return text
    }

    if (event === "pdf") {

      return new Promise(async (resolve, reject) => {
        try {
          const pdfjs = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@4.6.82/+esm')
          pdfjs.GlobalWorkerOptions.workerSrc = "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.6.82/build/pdf.worker.min.mjs"
          const url = input
          const loadingTask = pdfjs.getDocument(url)
          const pdf = await loadingTask.promise
          let currentPage = 1
          const totalPages = pdf.numPages
          const scale = 1.5
          const container = document.createElement('div')
          container.style.width = '100%'
          container.style.height = 'auto'
          container.style.display = 'flex'
          container.style.flexDirection = 'column'
          container.style.alignItems = 'center'
          const canvas = document.createElement('canvas')
          const context = canvas.getContext('2d')
          canvas.style.width = '100%'
          canvas.style.height = 'auto'
          const controls = document.createElement('div')
          controls.style.marginTop = '10px'
          controls.style.display = 'flex'
          controls.style.justifyContent = 'space-between'
          controls.style.width = '50%'
          const prevButton = document.createElement('button')
          prevButton.textContent = 'Zurück'
          const nextButton = document.createElement('button')
          nextButton.textContent = 'Weiter'
          const pageNumberDisplay = document.createElement('span')
          pageNumberDisplay.textContent = `Seite ${currentPage} von ${totalPages}`
          controls.appendChild(prevButton)
          controls.appendChild(pageNumberDisplay)
          controls.appendChild(nextButton)
          container.appendChild(canvas)
          container.appendChild(controls)
          async function renderPage(pageNumber) {
            const page = await pdf.getPage(pageNumber)
            const viewport = page.getViewport({ scale })
            canvas.height = viewport.height
            canvas.width = viewport.width
            const renderContext = {
              canvasContext: context,
              viewport: viewport
            }
            await page.render(renderContext).promise
            pageNumberDisplay.textContent = `Seite ${pageNumber} von ${totalPages}`
          }
          renderPage(currentPage)
          prevButton.onclick = ev => {
            ev.stopPropagation()
            if (currentPage <= 1) return
            currentPage--
            renderPage(currentPage)
          }
          nextButton.onclick = ev => {
            ev.stopPropagation()
            if (currentPage >= totalPages) return
            currentPage++
            renderPage(currentPage)
          }
          parent.appendChild(container)
          resolve(container)
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "platform-values/closed") {

      new Promise(async(resolve, reject) => {
        try {
          const copyPathIcon = await this.convert("path/icon", "/public/chain.svg")
          copyPathIcon.style.width = "55px"
          const openPathIcon = await this.convert("path/icon", "/public/window-layout-14.svg")
          openPathIcon.style.width = "55px"
          const pathProtectedIcon = await this.convert("path/icon", "/public/shield-locked.svg")
          pathProtectedIcon.children[0].style.fill = this.colors.light.text
          const pathOpenIcon = await this.convert("path/icon", "/public/eye-open.svg")
          const pathClosedIcon = await this.convert("path/icon", "/public/eye-crossed.svg")
          this.convert("parent/flex-row", parent)
          parent.style.overflow = "auto"
          parent.style.justifyContent = "space-around"
          const fragment = document.createDocumentFragment()
          for (let i = 0; i < input.length; i++) {
            const value = input[i]
            const item = document.createElement("div")
            item.classList.add("checklist-item")
            item.style.padding = "8px"
            item.style.width = "377px"
            const itemHeader = document.createElement("div")
            itemHeader.classList.add("item-header")
            this.add("outline-hover", itemHeader)
            itemHeader.style.display = "flex"
            itemHeader.style.borderTopRightRadius = "21px"
            itemHeader.style.borderTopLeftRadius = "21px"
            itemHeader.style.borderBottomLeftRadius = "21px"
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
              itemHeader.style.backgroundColor = this.colors.matte.charcoal
            } else {
              itemHeader.style.backgroundColor = this.colors.gray[1]
            }
            itemHeader.style.cursor = "pointer"
            itemHeader.onclick = async () => {

              this.overlay("popup", buttonsOverlay => {
                buttonsOverlay.info.textContent = value.path

                const buttons = this.create("div/scrollable", buttonsOverlay)
                {
                  {
                    const button = this.create("button/left-right", buttons)
                    button.left.textContent = ".path"
                    button.right.textContent = "Pfad ändern"
                    button.onclick = () => {

                      this.overlay("popup", async overlay => {
                        overlay.info.textContent = ".value.path"
                        const funnel = this. create("div/scrollable", overlay)
                        {
                          const pathField = this.create("field/tag", funnel)
                          pathField.input.value = value.path.split("/")[3]
                          pathField.label.textContent = "Pfad"
                          pathField.input.maxLength = "144"
                          pathField.input.placeholder = "Meine Werteinheit"
                          pathField.input.addEventListener("input", (event) => this.verify("input/value", pathField.input))
                          this.verify("input/value", pathField.input)

                          const button = this.create("button/action", funnel)
                          button.textContent = "Pfad jetzt ändern"
                          button.addEventListener("click", async () => {

                            await this.verify("input/value", pathField.input)
                            const path = pathField.input.value

                            this.overlay("security", async securityOverlay => {

                              {
                                const res = await this.request("/verify/platform/value-path-exist/", {path: `/${value.path.split("/")[1]}/${value.path.split("/")[2]}/${path}/`})
                                if (res.status === 200) {
                                  window.alert("Pfad existiert bereits.")
                                  this.add("style/not-valid", pathField.input)
                                  pathField.scrollIntoView({behavior: "smooth"})
                                  securityOverlay.remove()
                                  throw new Error("path exist")
                                }
                              }

                              const res = await this.request("/register/platform/value-path-location-expert/", {old: value.path, new: path})
                              if (res.status === 200) {
                                window.alert("Pfad erfolgreich geändert.")
                                overlay.previousSibling.previousSibling.remove()
                                overlay.previousSibling.remove()
                                overlay.remove()
                                securityOverlay.remove()
                              } else {
                                window.alert("Fehler.. Bitte wiederholen.")
                                securityOverlay.remove()
                              }
                            })

                          })

                        }

                      })
                    }
                  }
                  {
                    const button = this.create("button/left-right", buttons)
                    button.left.textContent = ".alias"
                    button.right.textContent = "Alias ändern"
                    button.onclick = () => {

                      this.overlay("popup", async overlay => {
                        overlay.info.textContent = ".value.alias"
                        {
                          const funnel = this.create("div/scrollable", overlay)

                          const valueAliasField = this.create("field/text", funnel)
                          if (value.alias.includes("<mark>")) {
                            const cleanAlias = value.alias.replace(/<mark>(.*?)<\/mark>/gi, "$1")
                            const convertedAlias = this.convert("text/capital-first-letter", cleanAlias)
                            valueAliasField.input.value = convertedAlias
                          } else {
                            valueAliasField.input.value = value.alias
                          }
                          valueAliasField.label.textContent = "Alias"
                          valueAliasField.input.maxLength = "144"
                          valueAliasField.input.setAttribute("required", "true")
                          valueAliasField.input.placeholder = "Meine Werteinheit"
                          valueAliasField.input.oninput = () => this.verify("input/value", valueAliasField.input)
                          this.verify("input/value", valueAliasField.input)

                          const button = this.create("button/action", funnel)
                          button.textContent = "Alias jetzt ändern"
                          button.onclick = async () => {

                            await this.verify("input/value", valueAliasField.input)
                            const alias = valueAliasField.input.value

                            this.overlay("security", async securityOverlay => {

                              const res = await this.request("/register/platform/value-alias-location-expert/", {alias, path: value.path})
                              if (res.status === 200) {
                                window.alert("Alias erfolgreich geändert..")
                                overlay.previousSibling.previousSibling.remove()
                                overlay.previousSibling.remove()
                                overlay.remove()
                                securityOverlay.remove()
                              } else {
                                alert("Fehler.. Bitte wiederholen.")
                                securityOverlay.remove()
                              }
                            })


                          }
                        }

                      })
                    }
                  }
                  {
                    const button = this.create("button/left-right", buttons)
                    button.left.textContent = ".image"
                    button.right.textContent = "Bild ändern"
                    button.onclick = () => {

                      this.overlay("popup", overlay => {
                        overlay.info.append(this.convert("text/span", ".value.image"))
                        const funnel = this.create("div/scrollable", overlay)
                        const urlField = this.create("field/url", funnel)
                        urlField.input.setAttribute("required", "true")
                        urlField.input.accept = "text/https"
                        urlField.label.textContent = "Gebe hier die Quell-Url für dein Bild ein"
                        urlField.input.placeholder = "https://www.meine-quelle.de/mein-bild.svg"
                        urlField.input.value = value.image ?? "";
                        this.verify("input/value", urlField.input)
                        urlField.input.addEventListener("input", () => this.verify("input/value", urlField.input))
                        const submit = this.create("button/action", funnel)
                        submit.textContent = "Bild jetzt ändern"
                        submit.onclick = async () => {
                          await this.verify("input/value", urlField.input)
                          this.overlay("security", async securityOverlay => {
                            const res = await this.request("/register/platform/value-image-expert", {path: value.path, image: urlField.input.value})
                            if (res.status === 200) {
                              window.alert("Bild erfolgreich gespeichert..")
                              overlay.previousSibling.previousSibling.remove()
                              overlay.previousSibling.remove()
                              overlay.remove()
                              securityOverlay.remove()
                            } else {
                              window.alert("Fehler.. Bitte wiederholen.")
                              securityOverlay.remove()
                            }
                          })
                        }

                      })

                    }
                  }
                  {
                    const button = this.create("button/left-right", buttons)
                    button.left.textContent = ".lang"
                    button.right.textContent = "Sprache ändern"
                    button.onclick = () => {

                      this.overlay("popup", async overlay => {
                        overlay.info.textContent = ".value.lang"
                        const funnel = this.create("div/scrollable", overlay)
                        const langField = this.create("field/lang", funnel)
                        langField.input.value = value.lang ?? "";
                        const button = this.create("button/action", funnel)
                        button.textContent = "Sprache jetzt ändern"
                        button.addEventListener("click", async () => {
                          await this.verify("input/value", langField.input)
                          this.overlay("security", async securityOverlay => {
                            const res = await this.request("/register/platform/value-lang-location-expert/", {lang: langField.input.value, path: value.path})
                            if (res.status === 200) {
                              window.alert("Sprache erfolgreich geändert..")
                              overlay.previousSibling.previousSibling.remove()
                              overlay.previousSibling.remove()
                              overlay.remove()
                              securityOverlay.remove()
                            } else {
                              window.alert("Fehler.. Bitte wiederholen.")
                              securityOverlay.remove()
                            }
                          })
                        })
                      })
                    }
                  }
                  {
                    const button = this.create("button/left-right", buttons)
                    button.left.textContent = ".visibility"
                    button.right.textContent = "Sichtbarkeit der Werteinheit"
                    button.onclick = () => {
                      this.overlay("popup", async overlay => {
                        overlay.info.textContent = `${value.path}.visibility`
                        const funnel = this.create("info/loading", overlay)
                        const res = await this.request("/get/platform/value-visibility-location-expert/", {path: value.path})
                        if (res.status === 200) {
                          const map = JSON.parse(res.response)
                          map.path = value.path
                          renderVisibilityFunnel(map, funnel)
                          function renderVisibilityFunnel(input, parent) {
                            Helper.convert("parent/scrollable", parent)
                            const openClosedField = Helper.create("field/select", parent)
                            openClosedField.label.textContent = "Sichtbarkeit"
                            Helper.verify("input/value", openClosedField.input)
                            openClosedField.input.oninput = () => {
                              const value = openClosedField.input.value
                              input.visibility = value
                              renderVisibilityFunnel(input, parent)
                            }
                            if (input.visibility === "open") {
                              openClosedField.input.add(["open", "closed"])
                              const button = Helper.create("button/action", parent)
                              button.textContent = "Sichtbarkeit jetzt ändern"
                              button.onclick = async () => {
                                const visibility = openClosedField.input.value
                                Helper.overlay("security", async securityOverlay => {
                                  const res = await Helper.request("/register/platform/value-visibility-location-expert/", {path: input.path, visibility})
                                  if (res.status === 200) {
                                    window.alert("Sichtbarkeit erfolgreich geändert.")
                                    parent.parentElement.previousSibling.previousSibling.remove()
                                    parent.parentElement.previousSibling.remove()
                                    parent.parentElement.remove()
                                    securityOverlay.remove()
                                  } else {
                                    window.alert("Fehler.. Bitte wiederholen.")
                                    securityOverlay.remove()
                                  }
                                })
                              }
                            }

                            if (input.visibility === "closed") {
                              openClosedField.input.add(["closed", "open"])
                              const rolesField = Helper.create("field/select", parent)
                              rolesField.label.textContent = "Nutzer mit diesen Rollen dürfen mit deiner Werteinheit interagieren"
                              rolesField.input.multiple = true
                              const array = []
                              if (input.roles !== undefined) {
                                if (input.roles.available !== undefined) {
                                  for (let i = 0; i < input.roles.available.length; i++) {
                                    const role = input.roles.available[i]
                                    array.push(role.name)
                                  }
                                }
                              }
                              rolesField.input.add(array)
                              Helper.verify("input/value", rolesField.input)
                              const selected = []
                              for (let i = 0; i < input.roles.selected.length; i++) {
                                const roleId = input.roles.selected[i]
                                if (input.roles !== undefined) {
                                  if (input.roles.available !== undefined) {
                                    for (let i = 0; i < input.roles.available.length; i++) {
                                      const role = input.roles.available[i]
                                      if (role.created === roleId) {
                                        selected.push(role.name)
                                      }
                                    }
                                  }
                                }
                              }
                              for (let i = 0; i < selected.length; i++) {
                                const value = selected[i]
                                for (let i = 0; i < rolesField.input.options.length; i++) {
                                  const option = rolesField.input.options[i]
                                  if (option.value === value) {
                                    option.selected = true
                                  }
                                }
                              }
                              const authorizedField = Helper.create("field/emails", parent)
                              authorizedField.label.textContent = "Nutzer mit diesen E-Mail Adressen dürfen mit deiner Werteinheit interagieren"
                              authorizedField.input.value = JSON.stringify(input.authorized)
                              Helper.verify("input/value", authorizedField.input)
                              authorizedField.input.addEventListener("input", () => Helper.verify("input/value", authorizedField.input))
                              const button = Helper.create("button/action", parent)
                              button.textContent = "Sichtbarkeit jetzt ändern"
                              button.addEventListener("click", async () => {
                                await Helper.verify("field-funnel", parent)
                                const visibility = openClosedField.input.value
                                const roles = []
                                for (let i = 0; i < rolesField.input.options.length; i++) {
                                  const option = rolesField.input.options[i]
                                  if (option.selected === true) {
                                    if (input.roles !== undefined) {
                                      if (input.roles.available !== undefined) {
                                        for (let i = 0; i < input.roles.available.length; i++) {
                                          const role = input.roles.available[i]
                                          if (role.name === option.value) {
                                            roles.push(role.created)
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                                const authorized = JSON.parse(authorizedField.input.value)
                                Helper.overlay("security", async securityOverlay => {
                                  const res = await Helper.request("/register/platform/value-visibility-location-expert/", {visibility, roles, authorized, path: input.path})
                                  if (res.status === 200) {
                                    window.alert("Sichtbarkeit erfolgreich geändert.")
                                    parent.parentElement.previousSibling.previousSibling.remove()
                                    parent.parentElement.previousSibling.remove()
                                    parent.parentElement.remove()
                                    securityOverlay.remove()
                                  } else {
                                    window.alert("Fehler.. Bitte wiederholen.")
                                    securityOverlay.remove()
                                  }
                                })
                              })
                            }
                          }
                        }
                      })
                    }
                  }
                  {
                    const button = this.create("button/left-right", buttons)
                    button.right.textContent = "Schreibrechte an Teammitglieder vergeben"
                    button.left.textContent = ".writability"
                    button.onclick = () => {
                      this.overlay("popup", async overlay => {
                        overlay.info.textContent = `.${value.path}.writability`
                        const funnel = this.create("div/scrollable", overlay)
                        const searchField = this.create("field/text", funnel)
                        searchField.label.textContent = "Suche nach E-Mail Adressen"
                        searchField.input.placeholder = "get-your.de"
                        searchField.style.margin = "21px 34px"
                        this.verify("input/value", searchField.input)
                        this.add("outline-hover", searchField.input)
                        const emailsField = await this.create("field/closed-contacts-email-select", funnel)
                        const originalOptions = Array.from(emailsField.input.options).map(option => option.cloneNode(true))
                        searchField.input.oninput = (ev) => {
                          const searchTerm = ev.target.value.toLowerCase()
                          const options = originalOptions.map(it => it.value)
                          const filtered = options.filter(it => it.toLowerCase().includes(searchTerm))
                          emailsField.input.add(filtered)
                        }
                        emailsField.input.style.height = "21vh"
                        emailsField.input.setAttribute("multiple", "true")
                        for (let i = 0; i < emailsField.input.options.length; i++) {
                          const option = emailsField.input.options[i]
                          option.selected = false
                          if (value.writability) {
                            for (let i = 0; i < value.writability.length; i++) {
                              const writableEmail = value.writability[i]
                              if (option.value === writableEmail) option.selected = true
                            }
                          }
                        }
                        const submit = this.create("button/action", funnel)
                        submit.textContent = "Schreibrechte jetzt vergeben"
                        let clickCounter = 0
                        submit.onclick = () => {
                          try {
                            const array = Array.from(emailsField.input.selectedOptions).map(it => it.value)
                            for (let i = 0; i < array.length; i++) {
                              const item = array[i]
                              if (!this.verifyIs("text/email", item)) throw new Error("not an email")
                            }
                            this.add("style/valid", emailsField.input)
                            this.overlay("security", async securityOverlay => {
                              const res = await this.request("/register/platform/value-writability-location-expert/", {path: value.path, writability: array})
                              if (res.status === 200) {
                                window.alert("Schreibrechte erfolgreich gespeichert.")
                                overlay.previousSibling.previousSibling.remove()
                                overlay.previousSibling.remove()
                                overlay.remove()
                                securityOverlay.remove()
                              }
                              if (res.status !== 200) {
                                window.alert("Fehler.. Bitte wiederholen.")
                                securityOverlay.remove()
                              }
                            })
                          } catch (error) {
                            this.add("style/not-valid", emailsField.input)
                            if (clickCounter === 3) {
                              window.alert("Deine E-Mail Liste ist ungültig.")
                              clickCounter = 0
                            }
                            clickCounter++
                          }
                        }
                      })
                    }
                  }
                  {
                    const button = this.create("button/left-right", buttons)
                    button.right.textContent = "Aktualisiere deine Toolbox"
                    button.left.textContent = ".update-toolbox"
                    button.onclick = async () => {
                      const res = await this.request("/update/toolbox/path-location-expert/", {path: value.path})
                      if (res.status === 200) {
                        window.alert("Toolbox wurde erfolgreich aktualisiert.")
                      } else {
                        window.alert("Fehler.. Bitte wiederholen.")
                      }
                    }
                  }
                  {
                    const button = this.create("button/left-right", buttons)
                    button.left.textContent = ".remove"
                    button.right.textContent = "Werteinheit entfernen"
                    button.onclick = async () => {

                      const confirm = window.confirm("Möchtest du deine Werteinheit wirklich löschen? Alle enthaltenen Daten werden ebenfalls gelöscht.")
                      if (confirm === true) {
                        this.overlay("security", async securityOverlay => {
                          const res = await this.request("/remove/platform/value-expert/", {path: value.path})
                          if (res.status === 200) {
                            window.alert("Werteinheit erfolgreich entfernt.")
                            buttonsOverlay.previousSibling.remove()
                            buttonsOverlay.remove()
                            securityOverlay.remove()
                          } else {
                            window.alert("Fehler.. Bitte wiederholen.")
                            securityOverlay.remove()
                          }
                        })
                      }
                    }
                  }
                }
              })
            }
            const itemState = document.createElement("div")
            itemState.classList.add("item-state")
            itemState.style.display = "flex"
            itemState.style.justifyContent = "center"
            itemState.style.alignItems = "center"
            itemState.style.width = "89px"
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
              itemState.style.backgroundColor = this.colors.matte.black
            } else {
              itemState.style.backgroundColor = this.colors.gray[2]
            }
            if (value.visibility === "closed") {
              if (value.roles.length === 0) {
                if (value.authorized.length === 0) {
                  itemState.appendChild(pathClosedIcon.cloneNode(true))
                }
              }
            }
            if (value.visibility === "open") {
              if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                itemState.style.backgroundColor = this.colors.matte.seaGreen
              } else {
                itemState.style.backgroundColor = this.colors.matte.lime
              }
              itemState.appendChild(pathOpenIcon.cloneNode(true))
            }
            if (value.visibility === "closed") {
              if (value.roles.length !== 0 || value.authorized.length !== 0) {
                itemState.style.backgroundColor = "#eed202"
                itemState.appendChild(pathProtectedIcon.cloneNode(true))
              }
            }
            itemState.style.borderTopLeftRadius = "21px"
            itemState.style.borderBottomLeftRadius = "21px"
            const itemTitle = document.createElement("div")
            itemTitle.classList.add("item-title")
            itemTitle.style.padding = "21px 34px"
            itemTitle.style.fontSize = "21px"
            itemTitle.style.overflow = "auto"
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
              itemTitle.style.color = this.colors.dark.text
            } else {
              itemTitle.style.color = this.colors.light.text
            }
            {
              const alias = document.createElement("div")
              alias.innerHTML = await this.convert("text/purified", value.alias)
              alias.style.fontSize = "21px"
              itemTitle.append(alias)
            }
            {
              const path = document.createElement("div")
              path.textContent = `${value.path}`
              path.style.fontSize = "13px"
              itemTitle.append(path)
            }
            itemHeader.append(itemState, itemTitle)
            item.append(itemHeader)
            const itemBody = document.createElement("div")
            itemBody.classList.add("item-body")
            itemBody.style.marginLeft = "8%"
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
              itemBody.style.backgroundColor = this.colors.matte.slate
              itemBody.style.boxShadow = `0 1px ${this.colors.gray[4]}`
            } else {
              itemBody.style.boxShadow = `0 1px ${this.colors.gray[2]}`
              itemBody.style.backgroundColor = this.colors.gray[0]
            }
            itemBody.style.borderBottomRightRadius = "21px"
            itemBody.style.borderBottomLeftRadius = "21px"
            itemBody.style.padding = "21px"
            itemBody.style.display = "flex"
            itemBody.style.flexDirection = "column"
            const buttons = document.createElement("div")
            buttons.style.display = "flex"
            buttons.style.alignItems = "center"
            {
              const button = this.create("div", buttons)
              button.appendChild(openPathIcon.cloneNode(true))
              button.className = "button"
              button.style.margin = "8px"
              button.style.cursor = "pointer"
              button.onclick = () => window.open(value.path, "_blank")
            }
            {
              const button = this.create("div")
              button.className = "button"
              button.style.margin = "8px"
              button.appendChild(copyPathIcon.cloneNode(true))
              buttons.appendChild(button)
              button.style.cursor = "pointer"
              button.onclick = () => {

                navigator.clipboard.writeText(value.path)
                .then(() => window.alert(`Der Pfad '${value.path}' wurde erfolgreich in den Zwischenspeicher kopiert.`))
                .catch(() => window.alert("Fehler.. Bitte wiederholen."))

              }
            }
            itemBody.appendChild(buttons)
            if (value.requested) {
              const requested = document.createElement("div")
              requested.textContent = `Angefordert: ${this.convert("number/k-M", value.requested.length)} Mal`
              requested.style.fontSize = "21px"
              requested.style.color = this.colors.matte.orange
              itemBody.append(requested)
            }
            if (value.writability) {
              const writability = document.createElement("div")
              writability.textContent = `Schreibrechte: ${value.writability.join(", ")}`
              writability.style.fontSize = "21px"
              writability.style.color = this.colors.matte.orange
              itemBody.append(writability)
            }
            item.appendChild(itemBody)
            fragment.appendChild(item)
          }
          parent.appendChild(fragment)
          resolve()
        } catch (error) {
          reject(error)
        }
      })

    }

    if (event === "platform-values/location") {

      this.convert("parent/scrollable", parent)
      for (let i = 0; i < input.length; i++) {
        const value = input[i]
        const button = this.create("button/image-text", parent)
        button.text.textContent = this.convert("text/capital-first-letter", value.alias)
        if (!this.verifyIs("text/empty", value.image)) {
          button.image.style.maxHeight = "89vh"
          button.image.style.objectFit = "cover"
          button.image.src = value.image
        } else {
          button.image.remove()
        }
        button.onclick = () => window.open(value.path, "_blank")
      }

    }

    if (event === "platforms/closed") {

      this.convert("element/reset", parent)
      for (let i = 0; i < input.length; i++) {
        const platform = input[i]
        const button = this.create("button/image-text", parent)
        button.text.textContent = this.convert("tag/capital-first-letter", platform.name)
        if (!this.verifyIs("text/empty", platform.image)) {
          button.image.style.maxHeight = "89vh"
          button.image.style.objectFit = "cover"
          button.image.src = platform.image
        } else {
          button.image.remove()
        }
        button.onclick = () => {
          this.overlay("popup", async buttonsOverlay => {
            buttonsOverlay.info.textContent = platform.name
            const buttons = this.create("div/scrollable", buttonsOverlay)
            {
              const button = this.create("button/left-right", buttons)
              button.left.textContent = ".create"
              button.right.textContent = "Neue Werteinheit erstellen"
              button.onclick = () => {
                this.overlay("popup", overlay => {
                  overlay.info.textContent = `${platform.name}.value`
                  const funnel = this.create("div/scrollable", overlay)
                  const valuePathField = this.create("field/tag", funnel)
                  valuePathField.label.textContent = "Pfad"
                  valuePathField.input.maxLength = "144"
                  valuePathField.input.placeholder = "meine-werteinheit"
                  this.verify("input/value", valuePathField.input)
                  valuePathField.input.addEventListener("input", () => this.verify("input/value", valuePathField.input))
                  const valueAliasField = this.create("field/text", funnel)
                  valueAliasField.label.textContent = "Alias"
                  valueAliasField.input.maxLength = "144"
                  valueAliasField.input.setAttribute("required", "true")
                  valueAliasField.input.placeholder = "Meine Werteinheit"
                  valueAliasField.input.addEventListener("input", () => this.verify("input/value", valueAliasField.input))
                  this.verify("input/value", valueAliasField.input)
                  const button = this.create("button/action", funnel)
                  button.textContent = "Werteinheit jetzt speichern"
                  button.onclick = async () => {
                    await this.verify("field-funnel", funnel)
                    const path = valuePathField.input.value
                    const alias = valueAliasField.input.value
                    const res = await this.request("/verify/platform/value-path-exist/", {path: `/${window.location.pathname.split("/")[1]}/${platform.name}/${path}/`})
                    if (res.status === 200) {
                      window.alert("Pfad existiert bereits.")
                      this.add("style/not-valid", valuePathField.input)
                      valuePathField.scrollIntoView({behavior: "smooth"})
                      throw new Error("path exist")
                    }
                    this.overlay("security", async securityOverlay => {
                      const res = await this.request("/register/platform/value-expert/", {path, alias, platform: platform.name})
                      if (res.status === 200) {
                        alert("Werteinheit erfolgreich gespeichert. +1 XP")
                        overlay.remove()
                        securityOverlay.remove()
                      } else {
                        alert("Fehler.. Bitte wiederholen.")
                        securityOverlay.remove()
                      }
                    })
                  }
                })
              }
            }
            {
              const button = this.create("button/left-right", buttons)
              button.left.textContent = ".values"
              button.right.textContent = "Meine HTML Werteinheiten"
              button.onclick = () => {
                this.overlay("popup", async overlay => {
                  overlay.info.textContent = `${platform.name}.values`
                  const searchField = this.create("input/text", overlay)
                  searchField.input.placeholder = "Suche nach Alias"
                  this.verify("input/value", searchField.input)
                  const units = this.create("info/loading", overlay)
                  const res = await this.request("/get/platform/values-self/", {platform: platform.name})
                  if (res.status === 200) {
                    const values = JSON.parse(res.response)
                    searchField.input.oninput = (ev) => {
                      const filtered = values.filter(it => it.alias.toLowerCase().includes(ev.target.value.toLowerCase()))
                      const highlighted = filtered.map(it => {
                        const highlightedAlias = it.alias.replace(new RegExp(ev.target.value, 'i'), `<mark>${ev.target.value}</mark>`)
                        return { ...it, alias: highlightedAlias }
                      })
                      this.render("platform-values/closed", highlighted, units)
                    }
                    this.render("platform-values/closed", values, units)
                  } else {
                    this.convert("parent/info", units)
                    searchField.remove()
                    units.textContent = `Es wurden keine Werteinheiten gefunden.`
                    throw new Error("platform values is empty")
                  }
                })
              }
            }
            {
              const button = this.create("button/left-right", buttons)
              button.left.textContent = ".bulk-values"
              button.right.textContent = "Massen Funktionen für ausgewählte Werteinheiten"
              button.onclick = () => {
                this.overlay("popup", async overlay => {
                  overlay.info.textContent = `${platform.name}.bulk-values`

                  const content = this.create("info/loading", overlay)

                  const res = await this.request("/get/platform/paths-location-expert/", {platform: platform.name})
                  if (res.status === 200) {
                    const paths = JSON.parse(res.response)
                    this.convert("parent/scrollable", content)
                    content.style.marginTop = "21px"
                    this.render("text/hr", "Wähle deine Pfade", content)

                    const select = this.create("input/select", content)
                    select.input.multiple = true
                    select.input.required = true
                    this.verify("input/value", select.input)
                    select.input.oninput = () => this.verify("input/value", select.input)

                    let height = 0
                    select.input.textContent = ""
                    for (let i = 0; i < paths.length; i++) {
                      const option = document.createElement("option")
                      height += 34
                      option.value = paths[i]
                      option.text = paths[i].split("/")[3]
                      select.input.appendChild(option)
                    }

                    select.input.style.height = `${height}px`

                    this.render("text/hr", "Wähle eine Funktion", content)
                    const buttons = this.create("div/flex-row", content)
                    const addFeedbackButton = this.render("text/link", "Feedback Button anhängen", buttons)
                    addFeedbackButton.onclick = async () => {
                      await this.verify("input/value", select.input)
                      const selectedPaths = Array.from(select.input.selectedOptions).map(it => it.value)
                      this.overlay("security", async securityOverlay => {
                        const res = await this.request("/update/paths/html-add-feedback-script/", {paths: selectedPaths})
                        if (res.status === 200) {
                          window.alert("Pfad wurden erfolgreich aktualisiert.")
                          overlay.remove()
                          securityOverlay.remove()
                        } else {
                          window.alert("Fehler.. Bitte wiederholen.")
                          securityOverlay.remove()
                        }
                      })
                    }

                    const addRequestedButton = this.render("text/link", "Requested Statistik anhängen", buttons)
                    addRequestedButton.onclick = async () => {
                      await this.verify("input/value", select.input)
                      const selectedPaths = Array.from(select.input.selectedOptions).map(it => it.value)
                      this.overlay("security", async securityOverlay => {
                        const res = await this.request("/update/paths/html-add-requested-script/", {paths: selectedPaths})
                        if (res.status === 200) {
                          window.alert("Pfad wurden erfolgreich aktualisiert.")
                          overlay.remove()
                          securityOverlay.remove()
                        } else {
                          window.alert("Fehler.. Bitte wiederholen.")
                          securityOverlay.remove()
                        }
                      })
                    }

                  } else {
                    this.convert("parent/info", content)
                    content.textContent = "Keine Pfade gefunden"
                  }

                })
              }
            }
            {
              const button = this.create("button/left-right", buttons)
              button.left.textContent = ".roles"
              button.right.textContent = "Rollen definieren"
              button.onclick = () => {
                this.overlay("popup", async overlay => {
                  overlay.info.textContent = `${platform.name}.roles`
                  const create = this.create("button/left-right", overlay)
                  create.left.textContent = ".create"
                  create.right.textContent = "Neue Rolle definieren"
                  create.onclick = () => {
                    this.overlay("popup", async overlay => {
                      overlay.info.textContent = "create.role"
                      const funnel = this.create("field-funnel/role", overlay)
                      const res = await this.request("/get/platform/value-paths-location-expert/", {platform: platform.name})
                      if (res.status === 200) {
                        const paths = JSON.parse(res.response)
                        funnel.homeField.input.add(paths)
                        this.verify("input/value", funnel.homeField.input)
                      } else {
                        window.alert("Es wurden keine Werteinheiten definiert")
                        this.add("style/not-valid", funnel.homeField.input)
                      }
                      funnel.submit.onclick = async () => {
                        await this.verify("field-funnel", funnel)
                        const name = funnel.nameField.input.value
                        const home = funnel.homeField.input.value
                        const apps = JSON.parse(funnel.appsField.input.value)
                        const res = await this.request("/verify/platform/role-name/", {platform: platform.name, name})
                        if (res.status === 200) {
                          window.alert("Diese Rolle existiert bereits.")
                          this.add("style/not-valid", funnel.nameField.input)
                          throw new Error("name exist")
                        }
                        this.overlay("security", async securityOverlay => {
                          const res = await this.request("/register/platform/role-expert/", {platform: platform.name, name, apps, home})
                          if (res.status === 200) {
                            window.alert("Rolle erfolgreich gespeichert.")
                            await this.render("roles-expert", platform.name, roleList)
                            overlay.remove()
                            securityOverlay.remove()
                          }
                        })
                      }
                    })
                  }
                  this.render("text/hr", "Meine Rollen", overlay)
                  const roleList = this.create("info/loading", overlay)
                  await this.render("roles-expert", platform.name, roleList)
                })
              }
            }
            {
              const button = this.create("button/left-right", buttons)
              button.left.textContent = ".match-maker"
              button.right.textContent = "Match Maker definieren"
              button.onclick = () => {
                this.overlay("popup", async overlay => {
                  overlay.info.textContent = `.match-maker`

                  const create = this.create("button/left-right", overlay)
                  create.left.textContent = ".create"
                  create.right.textContent = "Neuen Match Maker definieren"
                  create.addEventListener("click", () => {
                    this.overlay("popup", async overlay => {
                      overlay.info.textContent = `.${platform.name}.match-maker`
                      const funnel = this.create("div/scrollable", overlay)
                      funnel.nameField = this.create("field/tag", funnel)
                      funnel.nameField.label.textContent = "Gebe deinem Match Maker einen einzigartigen Namen (text/tag)"
                      funnel.nameField.input.placeholder = "mein-match-maker"
                      this.verify("input/value", funnel.nameField.input)
                      funnel.nameField.input.oninput = () => this.verify("input/value", funnel.nameField.input)
                      funnel.submit = this.create("button/action", funnel)
                      funnel.submit.textContent = "Match Maker jetzt speichern"
                      funnel.submit.onclick = async () => {
                        await this.verify("input/value", funnel.nameField.input)
                        const name = funnel.nameField.input.value
                        const res = await this.request("/verify/match-maker/name/", {name})
                        if (res.status === 200) {
                          window.alert("Name existiert bereits.")
                          this.add("style/not-valid", funnel.nameField.input)
                          throw new Error("name exist")
                        }
                        this.overlay("security", async securityOverlay => {
                          const res = await this.request("/register/platform/match-maker-location-expert/", {platform: platform.name, name})
                          if (res.status === 200) {
                            window.alert("Match Maker wurde erfolgreich gespeichert.")
                            await this.render("match-maker/expert", platform.name, matchMakerContainer)
                            overlay.remove()
                            securityOverlay.remove()
                          } else {
                            window.alert("Fehler.. Bitte wiederholen")
                            securityOverlay.remove()
                          }
                        })
                      }
                    })
                  })
                  this.render("text/hr", "Meine Match Maker", overlay)
                  const matchMakerContainer = this.create("div/scrollable", overlay)
                  await this.render("match-maker/expert", platform.name, matchMakerContainer)
                })
              }
            }
            {
              const button = this.create("button/left-right", buttons)
              button.right.textContent = "Namen ändern"
              button.left.textContent = ".name"
              button.onclick = () => {
                this.overlay("popup", async overlay => {
                  overlay.info.textContent = `${platform.name}.name`
                  const funnel = this.create("div/scrollable", overlay)
                  const platformNameField = this.create("field/tag", funnel)
                  platformNameField.input.value = platform.name
                  platformNameField.label.textContent = "Plattform"
                  platformNameField.input.maxLength = "21"
                  platformNameField.input.placeholder = "meine-plattform"
                  platformNameField.input.oninput = () => this.verify("input/value", platformNameField.input)
                  this.verify("input/value", platformNameField.input)
                  const button = this.create("button/action", funnel)
                  button.textContent = "Namen jetzt speichern"
                  button.onclick = async () => {
                    await this.verify("input/value", platformNameField.input)
                    const platformName = platformNameField.input.value
                    this.overlay("security", async securityOverlay => {
                      {
                        const res = await this.request("/verify/platform/exist/", {platform: platformName})
                        if (res.status === 200) {
                          window.alert("Plattform existiert bereits.")
                          this.add("style/not-valid", platformNameField.input)
                          securityOverlay.remove()
                          throw new Error("platform exist")
                        }
                      }
                      const res = await this.request("/register/platform/name-location-expert/", {old: platform.name, new: platformName})
                      if (res.status === 200) {
                        window.alert("Plattform Name erfolgreich gespeichert.")
                        window.location.reload()
                      } else {
                        window.alert("Fehler.. Bitte wiederholen.")
                        securityOverlay.remove()
                      }
                    })
                  }
                })
              }
            }
            {
              const button = this.create("button/left-right", buttons)
              button.right.textContent = "Definiere einen Startpunkt für deine Plattform"
              button.left.textContent = ".start"
              button.onclick = () => {
                this.overlay("popup", async overlay => {
                  overlay.info.textContent = `.${platform.name}.start`
                  const content = this.create("div/scrollable", overlay)
                  const startField = this.create("field/select", content)
                  startField.label.textContent = "Wähle einen Start Pfad für deine Plattform"
                  const res = await this.request("/get/platform/value-paths-location-expert/", {platform: platform.name})
                  if (res.status === 200) {
                    const paths = JSON.parse(res.response)
                    this.add("select-options", {select: startField.input, options: paths})
                  }
                  if (platform.start) {
                    for (let i = 0; i < startField.input.options.length; i++) {
                      const option = startField.input.options[i]
                      if (option.value === platform.start) option.selected = true
                    }
                  }
                  const submit = this.create("toolbox/action", content)
                  submit.textContent = "Pfad jetzt speichern"
                  submit.onclick = () => {
                    const platformStart = startField.input.value
                    if (this.verifyIs("text/empty", platformStart)) {
                      this.add("style/not-valid", startField.input)
                      return
                    }
                    this.overlay("security", async securityOverlay => {
                      const res = await this.request("/register/platform/start-location-expert/", {platform: platform.name, start: platformStart})
                      if (res.status === 200) {
                        window.alert("Daten wurden erfolgreich gespeichert.")
                      } else {
                        window.alert("Fehler.. Bitte wiederholen.")
                      }
                      securityOverlay.remove()
                    })
                  }

                })
              }
            }
            {
              const button = this.create("button/left-right", buttons)
              button.right.textContent = "Bild ändern"
              button.left.textContent = ".image"
              button.onclick = () => {
                this.overlay("popup", async overlay => {
                  overlay.info.textContent = `${platform.name}.image`
                  const funnel = this.create("div/scrollable", overlay)
                  const urlField = this.create("field/text", funnel)
                  urlField.label.textContent = "Gebe hier die Quell-Url für dein Bild ein"
                  urlField.input.placeholder = "https://www.meine-quelle.de/mein-bild.svg"
                  urlField.input.value = platform.image
                  this.verify("input/value", urlField.input)
                  urlField.input.addEventListener("input", () => this.verify("input/value", urlField.input))
                  const submit = this.create("button/action", funnel)
                  submit.textContent = "Bild jetzt speichern"
                  submit.onclick = async () => {
                    await this.verify("input/value", urlField.input)
                    this.overlay("security", async securityOverlay => {
                      const res = await this.request("/register/platform/image-expert/", {platform: platform.name, image: urlField.input.value})
                      if (res.status === 200) {
                        window.alert("Bild erfolgreich gespeichert.")
                        window.location.reload()
                      } else {
                        window.alert("Fehler.. Bitte wiederholen.")
                        securityOverlay.remove()
                      }
                    })

                  }

                })
              }
            }
            {
              const button = this.create("button/left-right", buttons)
              button.right.textContent = "Sichtbarkeit der Plattform"
              button.left.textContent = ".visibility"
              button.onclick = () => {
                this.overlay("popup", async overlay => {
                  overlay.info.textContent = `${platform.name}.visibility`
                  const funnel = this.create("div/scrollable", overlay)
                  {
                    const visibilityField = this.create("field/select", funnel)
                    visibilityField.label.textContent = "Sichtbarkeit"
                    if (platform.visibility === "open") {
                      visibilityField.input.add(["open", "closed"])
                    }
                    if (platform.visibility === "closed") {
                      visibilityField.input.add(["closed", "open"])
                    }
                    this.verify("input/value", visibilityField.input)
                    const button = this.create("button/action", funnel)
                    button.textContent = "Sichtbarkeit jetzt speichern"
                    button.onclick = async () => {
                      const visibility = visibilityField.input.value
                      this.overlay("security", async securityOverlay => {
                        const res = await this.request("/register/platform/visibility-location-expert/", {platform: platform.name, visibility})
                        if (res.status === 200) {
                          window.alert("Sichtbarkeit erfolgreich geändert.")
                          window.location.reload()
                        } else {
                          window.alert("Fehler.. Bitte wiederholen.")
                          securityOverlay.remove()
                        }
                      })
                    }
                  }
                })
              }
            }
            {
              const button = this.create("button/left-right", buttons)
              button.right.textContent = "Plattform entfernen"
              button.left.textContent = ".remove"
              button.onclick = () => {
                const confirm = window.confirm("Möchtest du deine Plattform wirklich entfernen? Alle enthaltenen Werteinheiten werden ebenfalls gelöscht.")
                if (confirm === true) {
                  this.overlay("security", async securityOverlay => {
                    const res = await this.request("/remove/platform/expert/", {platform: platform.name})
                    if (res.status === 200) {
                      window.alert("Plattform erfolgreich entfernt.")
                      window.location.reload()
                    } else {
                      window.alert("Fehler.. Bitte wiederholen.")
                      securityOverlay.remove()
                    }
                  })
                }
              }
            }
          })
        }
      }
    }

    if (event === "platforms/location") {

      this.convert("element/reset", parent)
      for (let i = 0; i < input.length; i++) {
        const platform = input[i]
        const button = this.create("button/image-text", parent)
        button.text.textContent = this.convert("tag/capital-first-letter", platform.name)
        if (!this.verifyIs("text/empty", platform.image)) {
          button.image.style.maxHeight = "89vh"
          button.image.style.objectFit = "cover"
          button.image.src = platform.image
        } else {
          button.image.remove()
        }
        button.onclick = () => {
          this.overlay("popup", async overlay => {
            const content = this.create("info/loading", overlay)
            const res = await this.request("/get/platform/values-location-expert/", {platform: platform.name})
            if (res.status === 200) {
              const values = JSON.parse(res.response)
              this.render("platform-values/location", values, content)
            }
          })
        }
      }
    }

    if (event === "roles-expert") {

      return new Promise(async(resolve, reject) => {
        try {
          const res = await this.request("/get/platform/roles-expert/", {platform: input})
          if (res.status === 200) {
            const roles = JSON.parse(res.response)
            this.convert("parent/scrollable", parent)
            for (let i = 0; i < roles.length; i++) {
              const role = roles[i]
              const button = this.create("button/left-right", parent)
              button.left.textContent = role.name
              button.right.textContent = "Rolle bearbeiten"
              button.onclick = () => {
                this.overlay("popup", async roleButtons => {
                  roleButtons.info.textContent = `${input}.roles.${role.name}`
                  const buttons = this.create("div/scrollable", roleButtons)
                  {
                    const button = this.create("button/left-right", buttons)
                    button.left.textContent = ".update"
                    button.right.textContent = "Aktualisiere deine Rolle"
                    button.onclick = () => {
                      this.overlay("popup", async overlay => {
                        const funnel = this.create("field-funnel/role", overlay)
                        funnel.nameField.input.value = role.name
                        const res = await this.request("/get/platform/value-paths-location-expert/", {platform: input})
                        if (res.status === 200) {
                          const paths = JSON.parse(res.response)
                          funnel.homeField.input.add(paths)
                          funnel.homeField.input.select([role.home])
                          this.verify("input/value", funnel.homeField.input)
                        } else {
                          window.alert("Es wurden keine Werteinheiten definiert")
                          this.add("style/not-valid", funnel.homeField.input)
                        }
                        funnel.appsField.input.value = JSON.stringify(role.apps)
                        this.verify("field-funnel", funnel)
                        funnel.submit.onclick = async () => {
                          await this.verify("field-funnel", funnel)
                          const name = funnel.nameField.input.value
                          const home = funnel.homeField.input.value
                          const apps = JSON.parse(funnel.appsField.input.value)
                          this.overlay("security", async securityOverlay => {
                            const res = await this.request("/update/platform/role-expert/", {id: role.created, platform: input, name, apps, home})
                            if (res.status === 200) {
                              window.alert("Rolle erfolgreich gespeichert.")
                              await this.render(event, input, parent)
                              roleButtons.remove()
                              overlay.remove()
                              securityOverlay.remove()
                            }
                          })
                        }
                      })
                    }
                  }
                  {
                    const button = this.create("button/left-right", buttons)
                    button.left.textContent = ".remove"
                    button.right.textContent = "Entferne deine Rolle"
                    button.onclick = () => {
                      this.overlay("security", async securityOverlay => {
                        const res = await this.request("/remove/platform/role-expert/", {platform: input, id: role.created})
                        if (res.status === 200) {
                          window.alert("Deine Rolle wurde erfolgreich entfernt.")
                          await this.render(event, input, parent)
                          roleButtons.remove()
                          securityOverlay.remove()
                        }
                      })
                    }
                  }
                })
              }
            }
          } else {
            this.convert("parent/info", parent)
            parent.textContent = "Keine Rollen gefunden"
          }
          resolve()
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "funnel/source") {

      if (input.authors) parent.authors.input.value = input.authors.join(", ")
      if (input.title) parent.titel.input.value = input.title
      if (input.edition) parent.edition.input.value = input.edition
      if (input.publisher) parent.publisher.input.value = input.publisher.join(", ")
      if (input.published) parent.published.input.value = input.published
      if (input.isbn) parent.isbn.input.value = input.isbn.join(", ")
      if (input.weblink) parent.weblink.input.value = input.weblink
      if (input.language) parent.language.input.value = input.language.join(", ")
      if (input.type) parent.type.input.value = input.type
      if (input.keywords) parent.keywords.input.value = input.keywords.join(", ")
      if (input.description) parent.description.input.value = input.description
      if (input.image) parent.image.input.value = input.image
    }

    if (event === "field-funnel-fields-update") {

      if (input.classList.contains("field-funnel")) {
        this.convert("parent/scrollable", parent)
        for (let i = 0; i < input.children.length; i++) {
          const field = input.children[i]
          if (field.classList.contains("submit-field-funnel-button")) continue
          if (field.classList.contains("field")) {
            const fieldInput = field.querySelector(".field-input")
            const button = this.create("button/left-right", parent)
            button.left.textContent = field.id
            button.right.append(this.convert("element/alias", fieldInput))
            this.add("outline-hover", button)
            button.onclick = () => {
              this.overlay("toolbox", overlay => {
                overlay.info.append(this.convert("element/alias", fieldInput))
                const buttons = this.create("div/scrollable", overlay)
                {
                  const button = this.create("button/left-right", buttons)
                  button.left.textContent = ".id"
                  button.right.textContent = "Datenfeld Id aktualisieren"
                  this.add("outline-hover", button)
                  button.onclick = () => {
                    this.overlay("toolbox", overlay => {
                      overlay.info.textContent = `${this.convert("element/alias", fieldInput)}.id`
                      const idField = this.create("field/id", overlay)
                      idField.input.value = field.id
                      idField.input.oninput = () => {
                        this.verify("input/value", idField.input)
                        const id = idField.input.value
                        if (this.verifyIs("id/unique", id) && this.verifyIs("text/tag", id)) {
                          field.setAttribute("id", id)
                          this.render(event, input, parent)
                        } else {
                          this.add("style/not-valid", idField.input)
                        }
                      }
                    })
                  }
                }
                {
                  const button = this.create("button/left-right", buttons)
                  button.left.textContent = ".on-info-click"
                  button.right.textContent = "Erweitere dein Datenfeld mit mehr Informationen"
                  this.add("outline-hover", button)
                  button.onclick = () => {
                    this.overlay("toolbox", overlay => {
                      overlay.info.append(this.convert("element/alias", fieldInput))
                      overlay.info.append(".on-info-click")
                      const infoField = this.create("field/textarea", overlay)
                      infoField.label.textContent = "Hier kannst du, wenn du möchtest, mehr Informationen zu diesem Datenfeld, als HTML, für deine Nutzer, bereitstellen"
                      infoField.input.style.height = "144px"
                      infoField.input.placeholder = "<div>..</div>"
                      infoField.input.style.fontFamily = "monospace"
                      infoField.input.style.fontSize = "13px"
                      if (field.hasAttribute("on-info-click")) {
                        infoField.input.value = field.getAttribute("on-info-click")
                      }
                      this.verify("input/value", infoField.input)
                      infoField.input.oninput = () => {
                        field.setAttribute("on-info-click", infoField.input.value)
                        const script = this.create("script", {id: "on-info-click", js: 'Helper.add("on-info-click")'})
                        this.add("script-onbody", script)
                      }
                    })
                  }
                }
                {
                  const button = this.create("button/left-right", buttons)
                  button.left.textContent = ".remove"
                  button.right.textContent = "Datenfeld entfernen"
                  this.add("outline-hover", button)
                  button.onclick = () => {
                    try {
                      field.remove()
                      this.render(event, input, parent)
                      overlay.remove()
                      window.alert("Datenfeld erfolgreich entfernt.")
                    } catch (error) {
                      window.alert("Fehler.. Bitte wiederholen.")
                      console.error(error)
                    }
                  }
                }
              })
            }
          }
        }
      }
    }

    if (event === "field-funnel/fields") {

      if (parent === undefined) {
        document.querySelectorAll(".field-funnel-fields").forEach(div => {
          this.render(event, input, div)
        })
      }

      if (parent !== undefined) {
        if (!parent.classList.contains("field-funnel-fields")) {
          parent.classList.add("field-funnel-fields")
        }
      }

      if (parent !== undefined) {
        parent.textContent = ""
      }


      if (input.classList.contains("field-funnel")) {

        for (let i = 0; i < input.children.length; i++) {
          const field = input.children[i]

          if (field.classList.contains("submit-field-funnel-button")) continue

          if (field.classList.contains("field")) {
            const fieldInput = field.querySelector(".field-input")


            const button = this.create("button/left-right", parent)
            button.left.textContent = field.id

            button.right.append(this.convert("element/alias", fieldInput))
            button.addEventListener("click", () => {
              this.overlay("toolbox", overlay => {
                overlay.info.append(this.convert("element/alias", fieldInput))
                const content = this.create("div/scrollable", overlay)


                field.ok = () => {
                  this.get(event, parent, input)
                  overlay.remove()
                }

                this.get("funnel/field", content, field)






              })
            })
          }

        }





      }

    }

    if (event === "click-field/answers") {

      if (input.classList.contains("click-field")) {

        const container = input.querySelector(".answers")
        if (container !== null) {
          parent.textContent = ""
          for (let i = 0; i < container.children.length; i++) {
            const child = container.children[i]

            if (child.classList.contains("answer-box")) {
              const answer = child.querySelector(".answer")

              const button = this.create("button/left-right", parent)
              button.left.textContent = `Option ${i + 1}`
              button.right.textContent = answer.textContent
              button.addEventListener("click", () => {
                this.overlay("toolbox", answersFunnelOverlay => {
                  overlay.info.append(this.convert("element/alias", child))
                  const answerFunnel = this.create("div/scrollable", answersFunnelOverlay)
                  const answerField = this.create("field/textarea", answerFunnel)
                  answerField.input.value = answer.textContent
                  answerField.label.textContent = "Antwortmöglichkeit ändern"
                  answerField.input.setAttribute("required", "true")
                  this.verify("input/value", answerField.input)
                  answerField.input.addEventListener("input", async () => {
                    await this.verify("input/value", answerField.input)
                    try {
                      const value = answerField.input.value
                      answer.textContent = value
                    } catch (error) {
                      this.add("style/not-valid", answerField.input)
                    }
                    this.render(event, input, parent)
                  })
                  const selectedConditionButton = this.create("button/left-right", answerFunnel)
                  selectedConditionButton.left.textContent = ".onclick"
                  selectedConditionButton.right.textContent = "Klick Bedingung definieren"
                  selectedConditionButton.addEventListener("click", () => {
                    this.overlay("toolbox", conditionFunnelOverlay => {
                      overlay.info.append(this.convert("element/alias", child))
                      overlay.info.append(".onclick")
                      const content = this.create("div/scrollable", conditionFunnelOverlay)
                      const actionField = this.create("field/select", content)
                      actionField.label.textContent = "Wähle ein Event"
                      actionField.input.add(["skip", "path"])
                      if (answer.hasAttribute("onclick-condition")) {
                        const condition = JSON.parse(answer.getAttribute("onclick-condition"))
                        actionField.input.select([condition.event])
                      }
                      this.verify("input/value", actionField.input)
                      actionField.input.addEventListener("input", () => {

                        if (actionField.input.value === "skip") {

                          skipNumberField.input.disabled = false
                          skipNumberField.input.setAttribute("required", "true")
                          this.add("style/not-valid", skipNumberField.input)

                          pathField.input.disabled = true
                          pathField.input.required = false
                          pathField.input.value = ""
                          this.add("style/valid", pathField.input)

                        }

                        if (actionField.input.value === "path") {

                          skipNumberField.input.disabled = true
                          skipNumberField.input.required = false
                          skipNumberField.input.value = ""
                          this.add("style/valid", skipNumberField.input)

                          pathField.input.disabled = false
                          pathField.input.setAttribute("required", "true")
                          this.add("style/not-valid", pathField.input)

                        }

                      })

                      const skipNumberField = this.create("field/tel", content)
                      skipNumberField.input.disabled = false
                      skipNumberField.input.required = true
                      skipNumberField.input.pattern = "[1-9]"
                      skipNumberField.label.textContent = "Wieviele Fragen möchtest du überspringen"
                      if (answer.hasAttribute("onclick-condition")) {
                        const condition = JSON.parse(answer.getAttribute("onclick-condition"))
                        if (condition.event === "skip") {
                          skipNumberField.input.value = condition.skip
                        }
                      }
                      this.verify("input/value", skipNumberField.input)
                      skipNumberField.input.addEventListener("input", () => this.verify("input/value", skipNumberField.input))

                      const pathField = this.create("field/text", content)
                      pathField.input.disabled = true
                      pathField.input.setAttribute("required", "false")
                      pathField.input.accept = "text/path"
                      pathField.input.placeholder = "/meine-platform/mein-username/meine-werteinheit/"
                      pathField.label.textContent = "Gebe eine Pfad ein"
                      if (answer.hasAttribute("onclick-condition")) {
                        const condition = JSON.parse(answer.getAttribute("onclick-condition"))
                        if (condition.event === "path") {
                          pathField.input.value = condition.path
                        }
                      }
                      this.add("style/valid", pathField.input)
                      pathField.input.addEventListener("input", () => this.verify("input/value", pathField.input))

                      const conditionSubmitButton = this.create("button/action", content)
                      conditionSubmitButton.textContent = "Klick Bedingung hinzufügen"
                      conditionSubmitButton.addEventListener("click", async () => {

                        await this.verify("field-funnel", content)

                        const condition = {}
                        condition.event = actionField.input.value

                        if (condition.event === "skip") {
                          condition.skip = skipNumberField.input.value
                        }

                        if (condition.event === "path") {
                          condition.path = pathField.input.value
                        }

                        answer.setAttribute("onclick-condition", JSON.stringify(condition))

                        conditionFunnelOverlay.remove()
                      })

                    })



                  })

                })
              })
            }

          }
        }



      }

    }

    if (event === "click-funnel/questions") {

      if (input.classList.contains("click-funnel")) {



        parent.textContent = ""
        for (let i = 0; i < input.children.length; i++) {
          const child = input.children[i]

          if (child.classList.contains("start-click-funnel-button")) continue
          if (child.classList.contains("end-click-funnel-button")) continue

          if (child.classList.contains("click-field")) {
            const button = this.create("button/left-right", parent)
            button.left.textContent = child.id
            button.right.textContent = "Frage bearbeiten"
            button.addEventListener("click", () => {
              this.overlay("toolbox", questionsFunnelOverlay => {
                overlay.info.append(this.convert("element/alias", child))
                const questionsFunnel = this.create("div/scrollable", questionsFunnelOverlay)
                const idField = this.create("field/tag", questionsFunnel)
                idField.input.value = child.id
                idField.label.textContent = "Id"
                this.verify("input/value", idField.input)
                idField.input.addEventListener("input", async () => {

                  await this.verify("input/value", idField.input)
                  try {
                    const value = idField.input.value
                    if (document.querySelectorAll(`#${value}`).length === 0) {
                      child.id = value
                    } else this.add("style/not-valid", idField.input)

                    info.textContent = ""
                    info.append(this.convert("element/alias", child))

                    this.render(event, input, parent)

                  } catch (error) {
                    this.add("style/not-valid", idField.input)
                  }

                })


                const question = child.querySelector(".question")
                const labelField = this.create("field/textarea", questionsFunnel)
                labelField.input.value = question.textContent
                labelField.label.textContent = "Frage"
                labelField.input.setAttribute("required", "true")
                this.verify("input/value", labelField.input)

                labelField.input.addEventListener("input", async () => {

                  await this.verify("input/value", labelField.input)

                  try {
                    const value = labelField.input.value
                    question.textContent = value
                  } catch (error) {
                    this.add("style/not-valid", labelField.input)
                  }

                })

                const button = this.create("button/left-right", questionsFunnel)
                button.left.textContent = ".options"
                button.right.textContent = "Antworten bearbeiten"
                button.addEventListener("click", () => {
                  this.overlay("toolbox", answersOverlay => {
                    overlay.info.textContent = `${this.convert("element/alias", child)}.options`

                    {
                      const button = this.create("button/left-right", answersOverlay)
                      button.left.textContent = ".append"
                      button.right.textContent = "Neue Antwortmöglichkeit anhängen"
                      button.addEventListener("click", () => {
                        const answerBox = this.create("answer-box")
                        this.overlay("toolbox", appendAnswerOverlay => {
                          overlay.info.append(this.convert("element/alias", child))
                          overlay.info.append(".append")
                          const answerFunnel = this.create("div/scrollable", appendAnswerOverlay)
                          const answerField = this.create("field/textarea", answerFunnel)
                          answerField.label.textContent = "Antwortmöglichkeit"
                          answerField.input.setAttribute("required", "true")
                          this.verify("input/value", answerField.input)
                          answerField.input.addEventListener("input", () => this.verify("input/value", answerField.input))

                          const selectedConditionButton = this.create("button/left-right", answerFunnel)
                          selectedConditionButton.left.textContent = ".onclick"
                          selectedConditionButton.right.textContent = "Klick Bedingung definieren"
                          selectedConditionButton.addEventListener("click", () => {
                            this.overlay("toolbox", conditionFunnelOverlay => {
                              overlay.info.append(this.convert("element/alias", child))
                              overlay.info.append(".onclick")
                              const content = this.create("div/scrollable", conditionFunnelOverlay)
                              const actionField = this.create("field/select", content)
                              actionField.label.textContent = "Wähle ein Event"
                              actionField.input.add(["skip", "path"])
                              this.verify("input/value", actionField.input)
                              actionField.input.addEventListener("input", () => {
                                if (actionField.input.value === "skip") {
                                  skipNumberField.input.disabled = false
                                  skipNumberField.input.required = true
                                  this.add("style/not-valid", skipNumberField.input)
                                  pathField.input.disabled = true
                                  pathField.input.required = false
                                  pathField.input.value = ""
                                  this.add("style/valid", pathField.input)
                                }

                                if (actionField.input.value === "path") {

                                  skipNumberField.input.disabled = true
                                  skipNumberField.input.required = false
                                  skipNumberField.input.value = ""
                                  this.add("style/valid", skipNumberField.input)

                                  pathField.input.disabled = false
                                  pathField.input.required = true
                                  this.add("style/not-valid", pathField.input)

                                }

                              })

                              const skipNumberField = this.create("field/tel", content)
                              skipNumberField.input.setAttribute("required", "true")
                              skipNumberField.input.pattern = "[1-9]"
                              skipNumberField.label.textContent = "Wieviele Fragen möchtest du überspringen"
                              this.verify("input/value", skipNumberField.input)
                              skipNumberField.input.addEventListener("input", () => this.verify("input/value", skipNumberField.input))

                              const pathField = this.create("field/text", content)
                              pathField.input.disabled = true
                              pathField.input.accept = "text/path"
                              pathField.input.placeholder = "/meine-platform/mein-username/meine-werteinheit/"
                              pathField.label.textContent = "Gebe eine Pfad ein"
                              this.add("style/valid", pathField.input)
                              pathField.input.addEventListener("input", () => this.verify("input/value", pathField.input))

                              const conditionSubmitButton = this.create("button/action", content)
                              conditionSubmitButton.textContent = "Klick Bedingung hinzufügen"
                              conditionSubmitButton.addEventListener("click", async () => {

                                const condition = {}
                                condition.event = actionField.input.value

                                if (condition.event === "skip") {
                                  await this.verify("input/value", skipNumberField.input)
                                  condition.skip = skipNumberField.input.value
                                  answerBox.answer.setAttribute("onclick-condition", JSON.stringify(condition))
                                }

                                if (condition.event === "path") {
                                  await this.verify("input/value", pathField.input)
                                  condition.path = pathField.input.value
                                  answerBox.answer.setAttribute("onclick-condition", JSON.stringify(condition))
                                }

                                conditionFunnelOverlay.remove()
                              })

                            })



                          })

                          const appendAnswerButton = this.create("button/action", answerFunnel)
                          appendAnswerButton.textContent = "Option jetzt anhängen"
                          appendAnswerButton.addEventListener("click", async () => {

                            await this.verify("input/value", answerField.input)
                            const answer = answerField.input.value

                            answerBox.answer.textContent = answer

                            child.querySelector(".answers").append(answerBox)

                            this.render("click-field/answers", document.getElementById(child.id), answers)

                            appendAnswerOverlay.remove()

                          })



                        })
                      })
                    }

                    const answers = this.create("div/scrollable", answersOverlay)
                    this.render("click-field/answers", document.getElementById(child.id), answers)

                  })
                })




              })
            })
          }

        }





      }

    }

    if (event === "question/answers") {

      const output = document.createElement("div")
      for (let i = 0; i < input.length; i++) {
        const element = input[i]
        const button = this.create("button/left-right")
        button.left.textContent = `Option: ${i + 1}`
        button.right.textContent = element.value
        output.appendChild(button)
      }
      parent?.appendChild(output)
      return output
    }

    if (event === "funnel/field-input") {

      if (parent === undefined) {
        document.querySelectorAll(".funnel-field-input").forEach(div => {
          this.render(event, {type: input.type, field: input.field}, div)
        })
      }

      if (parent !== undefined) {
        if (!parent.classList.contains("funnel-field-input")) {
          parent.classList.add("funnel-field-input")
        }
      }

      if (parent !== undefined) {
        parent.textContent = ""
      }


      if (input !== undefined) {

        if (input.type !== "select") {

          const requiredField = this.create("field/checkbox", parent)
          requiredField.label.textContent = "Dieses Datenfeld ist notwendig"
          this.verify("input/value", requiredField.input)
          if (input.field !== undefined) {
            if (input.field.classList.contains("field")) {
              const fieldInput = input.field.querySelector(".field-input")
              if (fieldInput.hasAttribute("required")) {
                requiredField.input.checked = true
              }
            }
          }
          requiredField.input.addEventListener("input", (event) => {

            if (input.field !== undefined) {
              if (input.field.classList.contains("field")) {
                const fieldInput = input.field.querySelector(".field-input")

                if (event.target.checked === true) {
                  fieldInput.setAttribute("required", true)
                }

                if (event.target.checked === false) {
                  fieldInput.removeAttribute("required")
                }

              }
            }


          })

        }

        if (input.type === "select") {

          {
            const button = this.create("button/left-right", parent)
            button.left.textContent = ".options"
            button.right.textContent = "Antwortmöglichkeiten definieren"
            button.addEventListener("click", () => {
              const fieldInput = input.field.querySelector(".field-input")
              this.overlay("toolbox", overlay => {
                overlay.info.textContent = `${this.convert("element/alias", input.field)}.options`
                {
                  const button = this.create("button/left-right", overlay)
                  button.left.textContent = ".append"
                  button.right.textContent = "Neue Antwortmöglichkeit anhängen"
                  button.addEventListener("click", () => {
                    this.overlay("toolbox", overlay => {
                      overlay.info.append(this.convert("element/alias", fieldInput))
                      overlay.info.append(this.convert("text/span", ".option.append"))

                      fieldInput.ok = () => {
                        this.render("select/options", fieldInput)
                        overlay.remove()
                      }

                      this.get("funnel/select-option", overlay, fieldInput)

                    })
                  })
                }

                this.render("text/hr", "Meine Optionen", overlay)

                const options = this.create("div/scrollable", overlay)
                this.render("select/options", fieldInput, options)

              })
            })
          }

        }

        // add more input dom functions


      }

    }

    if (event === "funnel/questions") {

      const output = document.createElement("div")
      for (let i = 0; i < input.length; i++) {
        const element = input[i]

        const button = this.create("button/left-right")
        button.left.textContent = `Frage: ${i + 1}`
        button.right.textContent = element.id

        // on click
        // change id and value
        //
        // delete
        // change answers if exist
        output.append(button)


      }

      if (parent !== undefined) parent.append(output)
      return output
    }

    if (event === "link/css") {

      const link = document.createElement("link")
      link.id = input
      link.rel = "stylesheet"
      link.href = input
      link.type = "text/css"
      if (!document.getElementById(input)) {
        this.render("node", link, document.head)
      }
    }

    if (event === "link/js") {

      const script = document.createElement("script")
      script.id = input
      script.src = input
      script.type = "module"
      script.setAttribute("async", "true")
      if (!document.getElementById(input)) {
        this.render("node", script, document.head)
      }
    }

    if (event === "list") {

      const {list, tree, type} = input
      const key = this.convert("tree/key", tree)
      this.convert("parent/scrollable", parent.content)
      for (let i = 0; i < list.length; i++) {
        const it = list[i]
        const button = this.design(tree, it[key], parent.content)
        this.fn(type, {it, node: button, overlay: parent})
      }
    }

    if (event === "node") {

      const fragment = document.createDocumentFragment()
      fragment.appendChild(input)
      parent?.appendChild(fragment)
    }

    if (event === "object/selector/write-details") {

      const node = document.querySelector(parent)

      for (let i = 0; i < document.querySelectorAll("*").length; i++) {
        const child = document.querySelectorAll("*")[i]

        if (child.hasAttribute("write-details")) {

          child.removeAttribute("style")
          child.textContent = ""
          child.style.display = "flex"
          child.style.flexDirection = "column"
          child.style.gap = "8px"
          child.style.maxHeight = "144px"
          child.style.overflow = "auto"

          Object.entries(input).forEach(([key, value]) => {

            const keyValuePair = document.createElement("div")
            keyValuePair.classList.add("key-value-pair")
            keyValuePair.style.display = "flex"
            keyValuePair.style.flexWrap = "wrap"
            keyValuePair.style.borderRadius = "5px"
            child.append(keyValuePair)

            const keyDiv = document.createElement("key")
            keyDiv.classList.add("key")
            keyDiv.textContent = this.convert("tag/capital-first-letter", key) + ":"
            keyValuePair.append(keyDiv)

            const valueDiv = document.createElement("div")
            valueDiv.textContent = value
            valueDiv.classList.add("value")
            valueDiv.style.fontWeight = "bold"
            valueDiv.style.marginLeft = "5px"
            keyValuePair.append(valueDiv)

          })

        }

      }

    }

    if (event === "object/node/write-details") {

      if (parent.hasAttribute("write-details")) {

        parent.removeAttribute("style")
        parent.textContent = ""
        parent.style.display = "flex"
        parent.style.flexDirection = "column"
        parent.style.gap = "8px"
        parent.style.maxHeight = "144px"
        parent.style.overflow = "auto"

        Object.entries(input).forEach(([key, value]) => {

          const keyValuePair = document.createElement("div")
          keyValuePair.classList.add("key-value-pair")
          keyValuePair.style.display = "flex"
          keyValuePair.style.flexWrap = "wrap"
          keyValuePair.style.borderRadius = "5px"
          parent.append(keyValuePair)

          const keyDiv = document.createElement("key")
          keyDiv.classList.add("key")
          keyDiv.textContent = this.convert("tag/capital-first-letter", key) + ":"
          keyValuePair.append(keyDiv)

          const valueDiv = document.createElement("div")
          valueDiv.textContent = value
          valueDiv.classList.add("value")
          valueDiv.style.fontWeight = "bold"
          valueDiv.style.marginLeft = "5px"
          keyValuePair.append(valueDiv)

        })

      }

    }

    if (event === "object/node/popup-details") {
      if (parent.hasAttribute("popup-details")) {

        parent.style.cursor = "pointer"
        parent.onclick = () => {
          this.overlay("popup", overlay => {
            this.render("text/title", "Detailansicht", overlay)

            const content = this.create("div/scrollable", overlay)
            content.style.display = "grid"
            content.style.gridTemplateColumns = "repeat(auto-fit, minmax(300px, 1fr))"
            content.style.gap = "21px"
            content.style.margin = "21px 34px"

            Object.entries(input).forEach(([key, value]) => {

              const keyValuePair = document.createElement("div")
              keyValuePair.classList.add("key-value-pair")

              keyValuePair.style.backgroundColor = this.colors.gray[0]
              keyValuePair.style.border = this.colors.light.border
              keyValuePair.style.color = this.colors.light.text
              keyValuePair.style.boxShadow = this.colors.light.boxShadow
              if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                keyValuePair.style.backgroundColor = this.colors.matte.black
                keyValuePair.style.border = this.colors.dark.border
                keyValuePair.style.boxShadow = this.colors.dark.boxShadow
                keyValuePair.style.color = this.colors.dark.text
              }
              keyValuePair.style.display = "flex"
              keyValuePair.style.flexDirection = "column"
              keyValuePair.style.padding = "1rem"
              keyValuePair.style.borderRadius = "5px"
              content.append(keyValuePair)

              const keyDiv = document.createElement("key")
              keyDiv.classList.add("key")
              keyDiv.style.fontWeight = "bold"
              keyDiv.style.marginBottom = "0.5rem"
              keyDiv.textContent = key
              keyDiv.style.color = this.colors.key
              keyValuePair.append(keyDiv)

              const valueDiv = document.createElement("div")
              valueDiv.textContent = value
              valueDiv.classList.add("value")
              valueDiv.style.color = this.colors.value
              keyValuePair.append(valueDiv)

            })

          })
        }

      }

    }

    if (event === "object/selector/class") {

      const node = document.querySelector(parent)

      if (node) {

        Object.entries(input).forEach(([key, value]) => {
          for (let i = 0; i < node.querySelectorAll("*").length; i++) {
            const child = node.querySelectorAll("*")[i]

            if (child.classList.contains(key)) {
              child.textContent = value
            }
          }
        })

      }

    }

    if (event === "object/selector/all") {

      const node = document.querySelector(parent)

      if (node) {

        Object.entries(input).forEach(([key, value]) => {
          for (let i = 0; i < node.querySelectorAll("*").length; i++) {
            const child = node.querySelectorAll("*")[i]

            this.render("object/node/write-details", input, child)
            this.render("object/node/popup-details", input, child)

            if (child.classList.contains(key)) {

              if (key === "bild") {
                child.src = value
              } else {
                child.textContent = value
              }

            }
          }
        })

      }

    }

    if (event === "object/node/all") {

      Object.entries(input).forEach(([key, value]) => {
        for (let i = 0; i < parent.querySelectorAll("*").length; i++) {
          const child = parent.querySelectorAll("*")[i]

          this.render("object/node/write-details", input, child)
          this.render("object/node/popup-details", input, child)

          if (child.classList.contains(key)) {

            if (key === "image") {
              child.src = value
            } else {
              child.textContent = value
            }

          }
        }
      })

    }

    if (event === "selector") {

      let node = document.querySelector(input)
      if (node) return node
      const fragment = document.createDocumentFragment()
      const tag = this.convert("selector/tag", input)
      const id = this.convert("selector/id", input)
      const className = this.convert("selector/class", input)
      node = document.createElement(tag)
      if (id) node.id = id
      if (className) node.className = className
      fragment?.appendChild(node)
      parent?.appendChild(fragment)
      return node
    }

    if (event === "html-values-writable") {

      function renderHtmlValuesOverlay(values) {
        Helper.overlay("popup", async overlay => {
          const searchField = Helper.create("field/text", overlay)
          searchField.label.textContent = "Suche nach Alias"
          searchField.input.placeholder = "Werteinheiten mit Schreibrechte"
          Helper.verify("input/value", searchField.input)
          Helper.add("outline-hover", searchField.input)
          const buttons = Helper.create("div/scrollable", overlay)
          searchField.input.oninput = async (ev) => {
            const filtered = values.filter(it => it.alias.toLowerCase().includes(ev.target.value.toLowerCase()))
            const highlighted = filtered.map(it => {
              const highlightedAlias = it.alias.replace(new RegExp(ev.target.value, 'i'), `<mark>${ev.target.value}</mark>`)
              return { ...it, alias: highlightedAlias }
            })
            await renderHtmlValueButtons(highlighted, buttons)
          }
          await renderHtmlValueButtons(values, buttons)
        })
      }

      function renderHtmlValueButtons(values, node) {
        return new Promise(async(resolve, reject) => {
          try {
            const icon = await Helper.convert("path/icon", "/public/window-chain.svg")
            icon.style.width = "55px"
            icon.style.margin = "0 5px"
            Helper.convert("parent/scrollable", node)
            for (let i = 0; i < values.length; i++) {
              const value = values[i]
              const iconClone = icon.cloneNode(true)
              Helper.add("outline-hover", iconClone)
              const button = Helper.create("button/left-right", node)
              button.right.style.display = "flex"
              button.right.appendChild(iconClone)
              Helper.createNode("span", button.left, value.alias)
              Helper.createNode("br", button.left)
              Helper.createNode("span", button.left, value.path)
              button.onclick = () => window.open(value.path, "_blank")
              iconClone.onclick = (ev) => {
                ev.stopPropagation()
                navigator.clipboard.writeText(value.path)
                .then(() => window.alert(`Der Pfad '${value.path}' wurde erfolgreich in deinen Zwischenspeicher kopiert.`))
                .catch(() => window.alert("Fehler.. Bitte wiederholen."))
              }
            }
            resolve()
          } catch (error) {
            reject(error)
          }
        })
      }
      renderHtmlValuesOverlay(input)
    }

    if (event === "user-reputation") {

      const fragment = document.createDocumentFragment()
      function getRecommendation(reputation) {
        if (reputation < -610) {
          return "Es scheint, dass es ernsthafte Probleme gibt, die gelöst werden müssen. Wir empfehlen eine umfassende Überprüfung der Aktivitäten und möglicherweise professionelle Unterstützung, um Verhaltensänderungen herbeizuführen."
        } else if (reputation < -145) {
          return "Die Reputation ist besorgniserregend. Es wäre hilfreich, detaillierte Rückmeldungen und gezielte Unterstützung anzubieten, um die zugrunde liegenden Ursachen der negativen Bewertung zu adressieren."
        } else if (reputation < -90) {
          return "Die Reputation weist auf Herausforderungen hin. Ermutigen Sie den Nutzer, Feedback anzunehmen und Verbesserungsmaßnahmen zu implementieren, um seine Interaktionen zu verbessern."
        } else if (reputation < -34) {
          return "Der Nutzer hat einige Schwierigkeiten gezeigt. Eine positive Verstärkung und klar definierte Ziele könnten hilfreich sein, um die Reputation zu verbessern."
        } else if (reputation < -13) {
          return "Die Reputation zeigt eine leichte negative Tendenz. Geben Sie konstruktives Feedback und Unterstützung, um die Engagement-Qualität zu erhöhen."
        } else if (reputation === 0) {
          return "Neutral"
        } else if (reputation <= 13) {
          return "Der Nutzer hat eine gute Reputation. Weiterhin positives Engagement fördern und Möglichkeiten zur weiteren Verbesserung bieten."
        } else if (reputation <= 34) {
          return "Der Nutzer hat eine sehr gute Reputation. Anerkennung und zusätzliche Herausforderungen könnten motivierend wirken."
        } else if (reputation <= 89) {
          return "Der Nutzer zeigt herausragendes Engagement. Überlege, wie du diesen Beitrag weiter anerkennen und belohnen kannst."
        } else if (reputation <= 144) {
          return "Exzellente Leistung und Engagement. Erwäge besondere Anerkennung oder Belohnungen für den außergewöhnlichen Beitrag zur Community."
        } else if (reputation <= 610) {
          return "Der Nutzer hat eine beeindruckende Reputation. Dies ist ein wertvolles Mitglied der Community; eine bedeutende Auszeichnung oder persönliche Anerkennung könnten angebracht sein."
        } else {
          return "Der Nutzer hat eine außergewöhnliche Reputation. Biete herausragende Anerkennung und ziehe in Betracht, ihm spezielle Verantwortungen oder Auszeichnungen zu geben."
        }
      }

      const recommendation = getRecommendation(input)
      const text = this.render("text/p", `Reputation: ${recommendation}`, fragment)
      text.style.fontSize = "13px"
      parent.appendChild(fragment)
      return text
    }

    if (event === "user/selector/all") {

      const node = document.querySelector(parent)

      if (node) {

        let list = document.querySelector(`.${node.className}-list`)
        if (!list) {
          list = this.create("div", document.body)
          list.className = `${node.className}-list`
        }
        list.style.paddingBottom = "144px"

        const clone = node.cloneNode(true)
        node.style.display = "none"

        Object.entries(input).forEach(([key, value]) => {
          if (this.verifyIs("array", value)) {
            for (let i = 0; i < value.length; i++) {
              const item = value[i]
              if (item.created) clone.id = item.created

              this.render("object-node", item, clone)

              const itemNode = clone.cloneNode(true)
              list.append(itemNode)

            }
          }
        })


        for (let i = 0; i < list.children.length; i++) {
          const item = list.children[i]

          const singlePrice = item.querySelector("span.single-price")
          const totalAmount = item.querySelector("span.total-amount")
          const quantityInput = item.querySelector("input.quantity")
          if (singlePrice && totalAmount && quantityInput) {
            quantityInput.value = 1
            totalAmount.textContent = `${Number(singlePrice.textContent) * Number(quantityInput.value)}`

            quantityInput.oninput = () => {
              totalAmount.textContent = `${Number(singlePrice.textContent) * Number(quantityInput.value)}`

              if (this.verifyIs("text/+int", quantityInput.value)) {
                this.add("style/valid", quantityInput)
              } else {
                this.add("style/not-valid", quantityInput)
              }

            }
          }



          for (let i = 0; i < item.querySelectorAll("*").length; i++) {
            const child = item.querySelectorAll("*")[i]

            if (child.tagName === "INPUT") {
              this.add("outline-hover", child)
            }

            if (child.hasAttribute("popup-details")) {

              this.add("outline-hover", child)
              Object.entries(input).forEach(([key, value]) => {
                if (this.verifyIs("array", value)) {
                  for (let i = 0; i < value.length; i++) {
                    const locationListItem = value[i]
                    if (item.id === `${locationListItem.created}`) {
                      if (locationListItem["pdf-product"] !== undefined) {
                        child.onclick = () => window.open(locationListItem["pdf-product"], "_blank")
                      } else {
                        this.render("object/node/popup-details", locationListItem, child)
                      }
                    }
                  }
                }
              })

            }

            if (child.hasAttribute("open-cart")) {

              this.add("outline-hover", child)
              child.onclick = () => {

                const quantityInput = item.querySelector("input.quantity")
                if (this.verifyIs("text/+int", quantityInput.value)) {

                  const cart = JSON.parse(window.localStorage.getItem("cart")) || []

                  let found = false
                  for (let i = 0; i < cart.length; i++) {
                    const cartItem = cart[i]

                    if (item.id === `${cartItem.id}`) {
                      cartItem.quantity = Number(cartItem.quantity) + Number(quantityInput.value)
                      window.localStorage.setItem("cart", JSON.stringify(cart))
                      found = true
                    }

                  }

                  if (found === false) {
                    const map = {}
                    map.id = item.id
                    map.quantity = Number(quantityInput.value)
                    map.titel = item.querySelector(".titel").textContent
                    map.image = item.querySelector(".image").src
                    map.price = item.querySelector(".price").textContent
                    cart.unshift(map)
                  }
                  window.localStorage.setItem("cart", JSON.stringify(cart))

                  this.overlay("popup", overlay => {
                    this.render("text/h1", "Mein Angebot", overlay)
                    this.render("text/right-hr", "Preis", overlay)
                    const cart = JSON.parse(window.localStorage.getItem("cart")) || []
                    this.render("cart/node/open", cart, overlay)
                  })

                } else {
                  this.add("style/not-valid", quantityInput)
                }

              }
            }

          }

        }

      }
    }

    if (event === "user-trees-closed") {

      function renderUserInNode(user, node) {
        for (let i = 0; i < Object.keys(user).length; i++) {
          const key = Object.keys(user)[i]
          if (node.classList.contains(key)) {
            if (node.tagName === "IMG") {
              node.src = user[key]
              continue
            }
            node.textContent = user[key]
          }
        }
      }

      return new Promise(async(resolve, reject) => {
        try {
          const res = await this.request("/get/user/trees-closed/", {trees: input})
          if (res.status === 200) {
            const user = JSON.parse(res.response)
            const nodes = document.querySelectorAll(parent)
            if (nodes) {
              for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i]
                renderUserInNode(user, node)
                for (let i = 0; i < node.querySelector("*").length; i++) {
                  const child = node.querySelector("*")[i]
                  renderUserInNode(user, child)
                }
              }
            }
          }
          resolve()
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "user-trees-open") {

      return new Promise(async(resolve, reject) => {
        try {
          const res = await this.request("/get/user/trees-open/", {trees: input})
          if (res.status === 200) {
            const users = JSON.parse(res.response)
            for (let i = 0; i < users.length; i++) {
              const user = users[i]
              this.render("user/selector/all", user, parent)
            }
          }
          resolve()
        } catch (error) {
          reject(error)
        }
      })


    }

    if (event === "users-trees-open") {

      return new Promise(async(resolve, reject) => {
        try {
          const res = await this.request("/get/user/trees-open/", {trees: input})
          if (res.status === 200) {
            const users = JSON.parse(res.response)
            const parentNode = document.querySelector(parent)
            if (parentNode) {
              const childNode = parentNode.querySelector(".user")
              const fragment = document.createDocumentFragment()
              for (let i = 0; i < users.length; i++) {
                const user = users[i]
                const userNode = this.render("object-node", user, childNode.cloneNode(true))
                fragment.appendChild(userNode)
              }
              parentNode.appendChild(fragment)
              childNode.style.display = "none"
            }
          }
          resolve()
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "user-box") {

      const fragment = document.createDocumentFragment()
      const it = this.create("toolbox/left-right", fragment)
      this.style(it, {margin: "8px", justifyContent: "center"})
      this.style(it.right, {fontSize: "21px"})

      if (!this.verifyIs("text/empty", input.image)) {
        const img = document.createElement("img")
        img.src = input.image
        img.style.width = "144px"
        img.style.height = "144px"
        img.style.borderRadius = "50%"
        img.style.objectFit = "cover"
        img.style.objectPosition = "center"
        it.left.appendChild(img)
      }

      if (!this.verifyIs("text/empty", input.alias)) {
        it.alias = this.render("html/h1", input.alias, it.right)
      }

      if (!this.verifyIs("number/empty", input.created)) {
        it.created = this.render("text/p", `Auf der Plattform seit: ${this.convert("millis/since", input.created)}`, it.right)
      }

      if (!this.verifyIs("text/empty", input.status)) {
        it.status = this.render("text/p", `Status: ${input.status}`, it.right)
      }

      let reputation
      if (!this.verifyIs("number/empty", input.reputation)) {
        it.reputation = this.render("user-reputation", input.reputation, it.right)
      }

      if (input.highlight === true) {
        this.add("style/new-message", it)
        if (it.alias) it.alias.style.color = this.colors.light.text
        if (it.created) it.created.style.color = this.colors.light.text
        if (it.status) it.status.style.color = this.colors.light.text
        if (it.reputation) it.reputation.style.color = this.colors.light.text
      } else {
        it.newMessageText = this.render("text/node/bottom-right-onhover", "Keine neuen Nachrichten", it)
      }

      parent?.appendChild(fragment)
      return it
    }

    if (event === "video") {

      const video = document.createElement("video")
      this.render("node", video, parent)
      video.style.width = "100%"
      video.controls = true
      video.src = input
      return video
    }

  }

  static remove(event, input) {

    if (event === ";") {

      return input.replace(/;/g, "")
    }

    if (event === "//") {

      return input.replace(/\/\/.*$/gm, "")
    }

    if (event === "\n") {

      return input
        .split(event)
        .filter(it => it.trim() !== "")
        .join(event)
    }

    if (event === "element/selector") {
      return new Promise(async(resolve, reject) => {
        try {

          const promises = []
          input.element.querySelectorAll(input.selector).forEach(it => {
            const promise = new Promise(innerResolve => {
              it.remove()
              innerResolve()
            })
            promises.push(promise)
          })
          await Promise.all(promises)

          resolve()

        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "toolbox") {

      return new Promise(async(resolve, reject) => {
        try {

          await this.remove("element/selector", {element: input, selector: "#toolbox-getter"})
          await this.remove("element/selector", {element: input, selector: "[data-id]"})
          await this.remove("element/selector", {element: input, selector: "#toolbox"})
          await this.remove("element/selector", {element: input, selector: ".overlay"})

          resolve()

        } catch (error) {
          reject(error)
        }
      })

    }

    if (event === "element/selected-node") {

      return new Promise(async(resolve, reject) => {
        try {

          const promises = []
          input.querySelectorAll("*").forEach(element => {
            const promise = new Promise(innerResolve => {
              element.style.outline = null
              element.removeAttribute("selected-node")
              innerResolve()
            })
            promises.push(promise)
          })
          await Promise.all(promises)

          input.style.outline = null
          input.removeAttribute("selected-node")

          resolve()

        } catch (error) {
          reject(error)
        }
      })

    }

    if (event === "contenteditable") {

      input.removeAttribute("contenteditable")
      for (let i = 0; i < input.querySelectorAll("*").length; i++) {
        const child = input.querySelectorAll("*")[i]
        child.removeAttribute("contenteditable")
      }
    }

    if (event === "selected-node") {

      input.style.outline = null
      input.removeAttribute("selected-node")
      for (let i = 0; i < input.querySelectorAll("*").length; i++) {
        const child = input.querySelectorAll("*")[i]
        child.style.outline = null
        child.removeAttribute("selected-node")
      }
    }

    if (event === "style/circle") {

      this.style(input, {borderRadius: "0", border: "0", width: "auto", height: "auto", backgroundColor: "transparent"})
    }

    if (event === "style/new-message") {

      input.querySelectorAll("*").forEach(node => {
        if (node.textContent === "Neue Nachrichten gefunden" || node.textContent === "●") node.remove()
      })
      this.convert("button/dark-light", input)
    }

    if (event === "style/not-valid") {

      input.style.outline = null
      input.style.border = null
      input.parentNode.querySelectorAll("div.sign").forEach(sign => sign.remove())
    }

    if (event === "style/selected") {

      Helper.remove("style/circle", input)
      Helper.convert("parent/box", input)
    }

    if (event === "event-listener") {
      Array.from(document.querySelectorAll('*')).forEach(element => element.replaceWith(element.cloneNode(true)));
    }

    if (event === "overlays") {
      document.querySelectorAll(".overlay").forEach(it => it.remove())
    }

    if (event === "node/sign") {
      input.style.border = ""
      input.parentElement.querySelectorAll("div.sign").forEach(it => it.remove())
    }

  }

  static request(event, input, type = "json") {

    if (type === "json") {
      return new Promise(async(resolve, reject) => {
        try {
          if (input === undefined) input = {}
          input.location = window.location.href
          input.referer = document.referrer
          input.localStorageEmail = window.localStorage.getItem("email")
          input.localStorageId = window.localStorage.getItem("localStorageId")
          const xhr = new XMLHttpRequest()
          xhr.open("POST", event)
          xhr.setRequestHeader("Accept", "application/json")
          xhr.setRequestHeader("Content-Type", "application/json")
          xhr.overrideMimeType("text/html")
          xhr.withCredentials = true
          xhr.onload = () => resolve(xhr)
          xhr.send(JSON.stringify(input))
        } catch (error) {
          reject(error)
        }
      })
    }

    if (type === "beacon") {

      const url = new URL(event, window.location.origin)
      url.searchParams.append("id", input)
      return navigator.sendBeacon(url.href)
    }

  }

  static requestWith(event, input) {

    if (type === "beacon") {

      const url = new URL(input.path, window.location.origin)
      url.searchParams.append("created", input.created)
      return navigator.sendBeacon(url.href)
    }

    if (event === "url-id") {

      return new Promise(async(resolve, reject) => {
        try {
          const pathname = window.location.pathname
          const urlId = window.location.pathname.split("/")[4]
          if (this.verifyIs("text/empty", urlId)) return
          if (input === undefined) input = {}
          input.location = window.location.href
          input.referer = document.referrer
          input.localStorageEmail = window.localStorage.getItem("email")
          input.localStorageId = window.localStorage.getItem("localStorageId")
          const xhr = new XMLHttpRequest()
          xhr.open("POST", pathname)
          xhr.setRequestHeader("Accept", "application/json")
          xhr.setRequestHeader("Content-Type", "application/json")
          xhr.overrideMimeType("text/html")
          xhr.withCredentials = true
          xhr.onload = () => resolve(xhr)
          xhr.send(JSON.stringify(input))
        } catch (error) {
          reject(error)
        }
      })
    }

  }

  static sort(event, input) {
    // event = input/by/algorithm

    if (event === "fisher-yates") {

      const array = Array.from(input)
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array
    }

    if (event === "flag-true") {

      return input.array.sort((a, b) => {
        const flagA = a[input.flag] ?? false;
        const flagB = b[input.flag] ?? false;
        if (flagA && !flagB) return -1;
        if (!flagA && flagB) return 1;
        return 0;
      })
    }

    if (event === "created-desc") {

      return input?.sort((a, b) => {
        if (!a.created && !b.created) return 0
        if (!a.created) return 1
        if (!b.created) return -1
        b.created.localeCompare(a.created)
      })
    }

    if (event === "array/reputation/descending") {
      return input?.sort((a, b) => b.reputation - a.reputation)
    }

    if (event === "query"){

      const filtered = input.array.filter(it => it[input.filter]?.toLowerCase().includes(input.query.toLowerCase()))
      return filtered.map(it => {
        const highlightedHtml = it[input.filter]?.replace(new RegExp(input.query, 'ig'), `<mark>${input.query}</mark>`)
        return { ...it, query: highlightedHtml }
      })
    }

  }

  static style(node, input) {
    if (node) {
      if (input.letterSpacing) node.style.letterSpacing = input.letterSpacing
      if (input.lineHeight) node.style.lineHeight = input.lineHeight
      if (input.position) node.style.position = input.position
      if (input.backgroundColor) node.style.backgroundColor = input.backgroundColor
      if (input.backgroundRepeat) node.style.backgroundRepeat = input.backgroundRepeat
      if (input.backgroundPosition) node.style.backgroundPosition = input.backgroundPosition
      if (input.backgroundSize) node.style.backgroundSize = input.backgroundSize
      if (input.backgroundImage) node.style.backgroundImage = input.backgroundImage
      if (input.background) node.style.background = input.background
      if (input.fontWeight) node.style.fontWeight = input.fontWeight
      if (input.fontFamily) node.style.fontFamily = input.fontFamily
      if (input.fontSize) node.style.fontSize = input.fontSize
      if (input.flexShrink) node.style.flexShrink = input.flexShrink
      if (input.height) node.style.height = input.height
      if (input.minHeight) node.style.minHeight = input.minHeight
      if (input.width) node.style.width = input.width
      if (input.maxWidth) node.style.maxWidth = input.maxWidth
      if (input.minWidth) node.style.minWidth = input.minWidth
      if (input.objectFit) node.style.objectFit = input.objectFit
      if (input.overflow) node.style.overflow = input.overflow
      if (input.overflowX) node.style.overflowX = input.overflowX
      if (input.overflowY) node.style.overflowY = input.overflowY
      if (input.margin) node.style.margin = input.margin
      if (input.marginTop) node.style.marginTop = input.marginTop
      if (input.marginBottom) node.style.marginBottom = input.marginBottom
      if (input.marginLeft) node.style.marginLeft = input.marginLeft
      if (input.padding) node.style.padding = input.padding
      if (input.color) node.style.color = input.color
      if (input.cursor) node.style.cursor = input.cursor
      if (input.display) node.style.display = input.display
      if (input.justifyContent) node.style.justifyContent = input.justifyContent
      if (input.alignItems) node.style.alignItems = input.alignItems
      if (input.flexDirection) node.style.flexDirection = input.flexDirection
      if (input.bottom) node.style.bottom = input.bottom
      if (input.left) node.style.left = input.left
      if (input.top) node.style.top = input.top
      if (input.right) node.style.right = input.right
      if (input.textShadow) node.style.textShadow = input.textShadow
      if (input.transform) node.style.transform = input.transform
      if (input.flexWrap) node.style.flexWrap = input.flexWrap
      if (input.flex) node.style.flex = input.flex
      if (input.textDecoration) node.style.textDecoration = input.textDecoration
      if (input.textTransform) node.style.textTransform = input.textTransform
      if (input.textAlign) node.style.textAlign = input.textAlign
      if (input.textOverflow) node.style.textOverflow = input.textOverflow
      if (input.border) node.style.border = input.border
      if (input.borderRadius) node.style.borderRadius = input.borderRadius
      if (input.boxShadow) node.style.boxShadow = input.boxShadow
      if (input.alignSelf) node.style.alignSelf = input.alignSelf
      if (input.wordBreak) node.style.wordBreak = input.wordBreak
      if (input.whiteSpace) node.style.whiteSpace = input.whiteSpace
    }
  }

  static update(event, parent, input) {
    // event = tag/on/algorithm

    // no parent needed to get data
    if (arguments.length === 2) {
      input = parent
    }


    if (event === "toolbox-getter") {

      return new Promise(async resolve => {

        document.querySelectorAll("#toolbox-getter").forEach(getter => getter.remove())
        document.querySelectorAll("#toolbox").forEach(toolbox => toolbox.remove())
        document.querySelectorAll("[data-id='toolbox']").forEach(toolbox => toolbox.remove())

        if (document.getElementById("#toolbox-getter") === null) {
          await this.add("script/toolbox-getter")
          return resolve()
        }

      })

    }

    if (event === "input/type") {

      const create = document.createElement("input")

      if (parent.hasAttribute("id")) {
        create.setAttribute("id", parent.getAttribute("id"))
      }

      create.setAttribute("type", input)

      if (parent.hasAttribute("class")) {
        create.setAttribute("class", parent.getAttribute("class"))
      }

      if (parent.hasAttribute("style")) {
        create.setAttribute("style", parent.getAttribute("style"))
      }

      if (parent.hasAttribute("required")) {
        create.setAttribute("required", parent.getAttribute("required"))
      }

      if (parent.hasAttribute("on-info-click")) {
        create.setAttribute("on-info-click", parent.getAttribute("on-info-click"))
      }

      parent.before(create)
      parent.remove()
    }

    if (event === "field-input/type") {

      if (parent.tagName !== "TEXTAREA") {

        if (input === "textarea") {
          this.convert("element/textarea", parent)
        }

      }

      if (parent.tagName !== "SELECT") {
        if (input === "select") {
          this.convert("element/select", parent)
        }
      }

      this.update("input/type", parent, input)

    }

  }

  static skipSiblings(index, sibling) {

    let count = 0
    let currentSibling = sibling

    while (currentSibling) {
      if (count >= index) break

      const nextSibling = currentSibling.nextSibling

      if (currentSibling.nodeType === Node.ELEMENT_NODE) {
        count++
        currentSibling.style.visibility = 'hidden'
        currentSibling.style.position = 'absolute'
      }

      currentSibling = nextSibling
    }

    if (currentSibling && currentSibling.nodeType === Node.ELEMENT_NODE) {
      currentSibling.style.visibility = 'visible'
      currentSibling.style.position = 'static'
    }

    if (count < index) throw new Error("out of bounds")

  }

  static verify(event, input, check) {
    // promises only
    // event = input/algo

    if (event === "any/key/exist") {

      if (!this.verifyIs("object", input)) return false
      if (input.hasOwnProperty(check)) return true
      for (const key in input) {
        if (input.hasOwnProperty(key) && typeof input[key] === 'object') {
          if (this.verify(event, input[key], check)) {
            return true
          }
        }
      }
      return false

    }

    if (event === "funnel") {

      return new Promise(async(resolve, reject) => {
        try {
          const observer = new MutationObserver((mutationsList, observer) => {
            for (const mutation of mutationsList) {
              if (mutation.type === 'attributes') {
                if (mutation.attributeName === 'accept' || mutation.attributeName === 'maxlength') {
                  window.location.reload()
                }
              }
            }
          })
          const allNodes = []
          if (typeof input === "object") {
            for (const key in input) {
              if (input.hasOwnProperty(key)) {
                const div = input[key]
                const nodes = [...div.querySelectorAll("input"), ...div.querySelectorAll("textarea"), ...div.querySelectorAll("select")]
                allNodes.push(...nodes)
              }
            }
          }
          if (input instanceof Node) {
            const nodes = [...input.querySelectorAll("input"), ...input.querySelectorAll("textarea"), ...input.querySelectorAll("select")]
            allNodes.push(...nodes)
          }

          for (const node of allNodes) {
            observer.observe(node, { attributes: true, childList: true, subtree: true })
            node.oninput = () => this.verifyIs("input/valid", node)
            const isValid = await this.verifyIs("input/valid", node)
            if (!isValid) {
              node.scrollIntoView({ behavior: "smooth", block: "start" })
              throw new Error("funnel invalid")
            }
          }
          observer.disconnect()
          resolve()
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "field-funnel") {
      return new Promise(async(resolve, reject) => {
        try {

          const promises = []
          input.querySelectorAll(".field").forEach(async field => {
            const fieldInput = field.querySelector(".field-input")
            const promise = this.verifyIs("input/valid", fieldInput)

            promises.push(promise)
          })

          const results = await Promise.all(promises)

          if (results.every((element) => element === true)) {
            resolve()
          } else {
            for (let i = 0; i < input.querySelectorAll(".field").length; i++) {
              const field = input.querySelectorAll(".field")[i]
              const fieldInput = field.querySelector(".field-input")
              const res = await this.verifyIs("input/valid", fieldInput)
              if (res === false) {
                field.scrollIntoView({ behavior: "smooth", block: "start" })
                break
              }
            }
          }

        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "input/value") {

      return new Promise(async(resolve, reject) => {
        try {
          const res = await this.verifyIs("input/valid", input)
          if (res === true) resolve()
          if (res === false) throw new Error("input invalid")
        } catch (error) {
          reject(error)
        }
      })
    }

  }

  static verifyIs(event, input) {
    // return boolean only

    if (event === "array") {
      if (typeof input === "object") {
        if (Array.isArray(input)) return true
      }
      return false
    }

    if (event === "array/empty") {
      return !Array.isArray(input) || input.length === 0
    }

    if (event === "array/primitive") {

      return input.every(it => {
        for (const key in it) {
          if (it.hasOwnProperty(key)) {
            const value = it[key]
            return this.verifyIs("primitive", value)
          }
        }
      })
    }

    if (event === "object") {
      if (typeof input === "object") return true
      return false
    }

    if (event === "object/empty") {
      return typeof input !== "object" ||
      input === undefined ||
      input === null ||
      Object.getOwnPropertyNames(input).length <= 0
    }

    if (event === "file/extension") {
      try {

        const fileExtension = input.file.name.split('.').pop()
        if (fileExtension === input.extension) return true
        return false

      } catch (error) {
        return false
      }
    }

    if (event === "file/extensions") {
      return new Promise((resolve, reject) => {
        try {
          const fileExtension = input.file.name.split('.').pop()
          for (let i = 0; i < input.extensions.length; i++) {
            const extension = input.extensions[i]

            if (this.verifyIs("file/extension", {file: input.file, extension})) {
              resolve()
            }

          }
          throw new Error("file extension not allowed")
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "file/type") {
      if (input.file.type === input.type) return true
      return false
    }

    if (event === "file/types") {
      return new Promise((resolve, reject) => {
        try {
          for (let i = 0; i < input.types.length; i++) {
            const type = input.types[i]
            if (this.verifyIs("file/type", {file: input.file, type })) {
              resolve()
            }
          }
          throw new Error("mime type not allowed")
        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "file/image") {

      return new Promise(async(resolve, reject) => {
        try {

          const allowedMimeTypes = ["image/jpeg", "image/png", "image/svg+xml"]
          const allowedExtensions = ["jpg", "jpeg", "png", "svg"]

          const types = await this.verifyIs("file/mime-types", {file: input, types: allowedMimeTypes})

          if (types === false) {
            window.alert(`Erlaubte Formate: ${allowedExtensions.join(", ")}`)
            throw new Error("no image")
          }

          const extensions = await this.verifyIs("file/extensions", {file: input, extensions: allowedExtensions})

          if (extensions === false) {
            window.alert(`Erlaubte Formate: ${allowedExtensions.join(", ")}`)
            throw new Error("no image")
          }

          resolve(true)

        } catch (error) {
          resolve(false)
        }
      })


    }

    if (event === "file/pdf") {

      return new Promise(async(resolve, reject) => {
        try {

          const allowedMimeTypes = ["application/pdf"]
          const allowedExtensions = ["pdf"]

          const types = await this.verifyIs("file/mime-types", {file: input, types: allowedMimeTypes})

          if (types === false) {
            window.alert(`Erlaubte Formate: ${allowedExtensions.join(", ")}`)
            throw new Error("no pdf")
          }

          const extensions = await this.verifyIs("file/extensions", {file: input, extensions: allowedExtensions})

          if (extensions === false) {
            window.alert(`Erlaubte Formate: ${allowedExtensions.join(", ")}`)
            throw new Error("no pdf")
          }

          resolve(true)

        } catch (error) {
          resolve(false)
        }
      })


    }

    if (event === "file/html") {

      return new Promise(async(resolve, reject) => {
        try {

          const allowedMimeTypes = ["text/html"]
          const allowedExtensions = ["html"]

          const types = await this.verifyIs("file/mime-types", {file: input, types: allowedMimeTypes})

          if (types === false) {
            window.alert(`Erlaubte Formate: ${allowedExtensions.join(", ")}`)
            throw new Error("no html")
          }

          const extensions = await this.verifyIs("file/extensions", {file: input, extensions: allowedExtensions})

          if (extensions === false) {
            window.alert(`Erlaubte Formate: ${allowedExtensions.join(", ")}`)
            throw new Error("no html")
          }

          resolve(true)

        } catch (error) {
          resolve(false)
        }
      })


    }

    if (event === "file/svg+xml") {

      return new Promise(async(resolve, reject) => {
        try {

          const allowedMimeTypes = ["image/svg+xml"]
          const allowedExtensions = ["svg"]

          const types = await this.verifyIs("file/mime-types", {file: input, types: allowedMimeTypes})

          if (types === false) {
            window.alert(`Erlaubte Formate: ${allowedExtensions.join(", ")}`)
            throw new Error("no svg")
          }

          const extensions = await this.verifyIs("file/extensions", {file: input, extensions: allowedExtensions})

          if (extensions === false) {
            window.alert(`Erlaubte Formate: ${allowedExtensions.join(", ")}`)
            throw new Error("no svg")
          }

          resolve(true)

        } catch (error) {
          resolve(false)
        }
      })


    }

    if (event === "file/mp3") {
      return new Promise(async(resolve, reject) => {
        try {
          const reader = new FileReader()

          const blobSlice = input.slice(0, 4)

          reader.onloadend = () => {
            const arrayBuffer = new Uint8Array(reader.result)

            const bytes = []
            arrayBuffer.forEach(byte => {
              bytes.push(byte.toString(16))
            })
            const fileType = bytes.join('').toUpperCase()

            const mp3Signature = "494433"

            if (fileType.startsWith(mp3Signature)) {
              resolve(true)
            } else {
              resolve(false)
            }

          }

          reader.readAsArrayBuffer(blobSlice)

        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "key/object-array") {
      for (const object of input.array) {
        if (object.hasOwnProperty(input.key)) {
          return true
        }
      }
      return false
    }

    if (event === "number/empty") {
      return input === undefined ||
      input === null ||
      Number.isNaN(input) ||
      typeof input !== "number" ||
      input === ""
    }

    if (event === "primitive") {

      return typeof input === "string" || typeof input === "number" || typeof input === "boolean"
    }

    if (event === "script-id/disabled") {
      if (!this.verifyIs("text/empty", input)) {
        const scripts = JSON.parse(window.localStorage.getItem("scripts")) || []
        for (let i = 0; i < scripts.length; i++) {
          const script = scripts[i]
          if (script.id === input) {
            if (script.disabled) {
              return true
            }
          }
        }
      }
      return false
    }

    if (event === "tag/empty") {
      return this.verifyIs("text/empty", input) || !/^[a-z](?:-?[a-z]+)*$/.test(input)
    }

    if (event === "text/class") {

      return /^[A-Za-z0-9\-_:]+$/.test(input)
    }

    if (event === "text/json") {
      try {
        JSON.parse(input)
        return true
      } catch (error) {
        return false
      }
      return false
    }

    if (event === "text/operator") {
      if (input === "=") return true
      if (input === ">=") return true
      if (input === "<=") return true
      if (input === "!=") return true
      if (input === "<") return true
      if (input === ">") return true
      return false
    }

    if (event === "text/url") {
      try {
        new URL(input)
        return true
      } catch (error) {
        return false
      }
    }

    if (event === "text/email") {

      return /^(.+)@(.+)$/.test(input)
    }

    if (event === "text/empty") {
      return typeof input !== "string" ||
        input === "undefined" ||
        input === undefined ||
        input === null ||
        input === "null" ||
        input === "" ||
        input.replace(/\s/g, "") === ""
    }

    if (event === "text/js") {

      try {
        if (this.verifyIs("text/empty", input) === true) throw new Error("text is empty")
        new Function(input)
        return true
      } catch (error) {
        return false
      }

    }

    if (event === "text/script") {
      try {
        const fragment = this.convert("text/fragment", input)
        const script = fragment.querySelector("script")
        return script !== null && script.tagName === "SCRIPT"
      } catch {}
      return false
    }

    if (event === "text/tag") {
      if (typeof input !== "string") return false
      if (/^[a-z](?:-?[a-z]+)*$/.test(input) === true) return true
      return false
    }

    if (event === "text/tree") {

      if (/^(?!.*[-.]{2,})(?!.*^-)(?!.*\.$)(?!.*\.\.$)[a-z]+([-.][a-z]+|\.\d+)*$/.test(input)) {
        return true
      } else {
        return false
      }
    }

    if (event === "text/trees") {

      if (!input.startsWith("[")) return false
      if (!input.endsWith("]")) return false
      try {
        const array = JSON.parse(input)
        for (let i = 0; i < array.length; i++) {
          const text = array[i]
          if (this.verifyIs("text/tree", text)) return true
        }
      } catch {}
      return false
    }

    if (event === "text/tel") {
      if (typeof input !== "string") return false
      if (/^\+[0-9]+$/.test(input) === true) return true
      return false
    }

    if (event === "field-funnel/valid") {
      return new Promise(async(resolve, reject) => {
        try {

          const promises = []
          input.querySelectorAll(".field").forEach(async field => {
            const fieldInput = field.querySelector(".field-input")
            const promise = this.verifyIs("input/valid", fieldInput)

            promises.push(promise)
          })

          const results = await Promise.all(promises)

          if (results.every((element) => element === true)) {
            resolve(true)
          } else {
            resolve(false)
          }

        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "text/number") {

      try {
        return !isNaN(Number(input))
      } catch (error) {
        return false
      }

    }

    if (event === "text/int") {

      try {
        const number = Number(input)
        return Number.isInteger(number)
      } catch (error) {
        return false
      }

    }

    if (event === "text/+int") {

      try {
        const number = Number(input)
        return Number.isInteger(number) && number > 0
      } catch (error) {
        return false
      }

    }

    if (event === "text/isbn") {
      return /^\d{9}[\dXx]$/.test(input.replace(/-/g, '')) || /^\d{13}$/.test(input.replace(/-/g, ''))
    }

    if (event === "text/path") {

      if (input === "/") return true
      const regex = /^\/([a-z]+(?:-[a-z]+)*)(\/[a-z]+(?:-[a-z]+)*)*\/$/
      return regex.test(input)
    }

    if (event === "input/valid") {

      return new Promise((resolve) => {


        // required, no accept
        if (input.hasAttribute("required") && !input.hasAttribute("accept")) {
          if (this.verifyIs("input/required", input)) {
            this.add("style/valid", input)
            return resolve(true)
          } else {
            this.add("style/not-valid", input)
            if (input.parentElement) input.parentElement.scrollIntoView({behavior: "smooth"})
            return resolve(false)
          }
        }

        // accept, no required
        if (input.hasAttribute("accept") && !input.hasAttribute("required")) {

          if (input.value === "") {

            this.add("style/valid", input)
            return resolve(true)

          } else {

            if (this.verifyIs("input/accepted", input)) {

              this.add("style/valid", input)
              return resolve(true)

            } else {
              this.add("style/not-valid", input)
              if (input.parentElement) input.parentElement.scrollIntoView({behavior: "smooth"})
              return resolve(false)
            }

          }

        }

        // no accept, no required
        if (!input.hasAttribute("accept") && !input.hasAttribute("required")) {
          this.add("style/valid", input)
          return resolve(true)
        }

        // accept and required
        if (input.hasAttribute("required") && input.hasAttribute("accept")) {
          if (this.verifyIs("input/required", input)) {
            if (this.verifyIs("input/accepted", input)) {
              this.add("style/valid", input)
              return resolve(true)
            }
          }
          this.add("style/not-valid", input)
          if (input.parentElement) input.parentElement.scrollIntoView({behavior: "smooth"})
          return resolve(false)
        }


      })

    }

    if (event === "input/accepted") {

      const array = []
      const accept = input.getAttribute("accept")

      if (accept && accept.includes("application/pdf")) {

        return new Promise(async(resolve, reject) => {
          try {
            const promises = []
            for (var i = 0; i < input.files.length; i++) {
              const file = input.files[i]
              const promise = this.verifyIs("file/pdf", file)
              promises.push(promise)
            }
            const results = await Promise.all(promises)
            if (results.every((element) => element === true)) {
              array.push(true)
              resolve(true)
            } else {
              array.push(false)
              resolve(false)
            }
          } catch (error) {
            array.push(false)
            resolve(false)
          }
        })
      }

      if (accept && accept.includes("text/js")) {

        try {
          array.push(this.verifyIs("text/js", input.value))
        } catch (error) {
          array.push(false)
        }
      }

      if (accept && accept.includes("text/length")) {

        if (input.value.length <= input.maxLength) {
          array.push(true)
        } else {
          array.push(false)
        }
      }

      if (accept && accept.includes("text/trees")) {
        if (this.verifyIs("text/trees", input.value)) {
          array.push(true)
        } else {
          array.push(false)
        }
      }

      if (accept && accept.includes("text/tree")) {

        input.value = input.value.replace(/ /g, ".")
        if (this.verifyIs("text/tree", input.value) === true) {
          array.push(true)
        } else {
          array.push(false)
        }
      }

      if (accept && accept.includes("text/operator")) {
        array.push(this.verifyIs("text/operator", input.value))
      }

      if (accept && accept.includes("text/email")) {

        if (/^(.+)@(.+)$/.test(input.value) === true) {
          array.push(true)
        } else {
          array.push(false)
        }
      }

      if (accept && accept.includes("text/url")) {

        if (this.verifyIs("text/url", input.value)) {
          array.push(true)
        } else {
          array.push(false)
        }
      }

      if (accept && accept.includes("text/number")) {

        if (this.verifyIs("text/number", input.value)) {
          array.push(true)
        } else {
          array.push(false)
        }
      }

      if (input.requiredIndex !== undefined) {
        let selected = []
        for (let i = 0; i < input.options.length; i++) {
          const option = input.options[i]
          if (option.selected === true) {
            selected.push(option)
          }
        }
        for (let i = 0; i < selected.length; i++) {
          if (selected[i].value === input.options[input.requiredIndex].value) {
            array.push(true)
          }
        }
      }

      if (accept && accept.includes("text/tel")) {
        if (this.verifyIs("text/tel", input.value)) {
          array.push(true)
        } else {
          array.push(false)
        }
      }

      if (accept && accept.includes("text/id")) {

        input.value = input.value.replace(/ /g, "-")
        if (/^[a-z](?:-?[a-z]+)*$/.test(input.value) === true) {
          if (document.querySelectorAll(`#${input.value}`).length === 0) {
            array.push(true)
          } else {
            array.push(false)
          }
        }
      }

      if (accept && accept.includes("text/path")) {

        if (this.verifyIs("text/path", input.value)) {
          this.add("style/valid", input)
          array.push(true)
        } else {
          this.add("style/not-valid", input)
          array.push(false)
        }
      }

      if (accept && accept.includes("text/hex")) {

        if (/^[0-9A-Fa-f]+$/.test(input.value) === true) {
          array.push(true)
        } else {
          array.push(false)
        }
      }

      if (accept && accept.includes("text/tag")) {

        input.value = input.value.replace(/ /g, "-")
        input.value = input.value.replace(/ö/g, "oe")
        input.value = input.value.replace(/ä/g, "ae")
        input.value = input.value.replace(/ü/g, "ue")
        if (/^[a-z](?:-?[a-z]+)*$/.test(input.value) === true) {
          array.push(true)
        } else {
          array.push(false)
        }
      }

      if (accept && accept.includes("text/https")) {

        if (input.value.startsWith("https://")) {
          array.push(true)
        } else {
          array.push(false)
        }
      }

      if (accept && accept.includes("email/array")) {

        if (!input.value.startsWith("[")) array.push(false)
        if (!input.value.endsWith("]")) array.push(false)
        try {
          const array = JSON.parse(input.value)
          for (let i = 0; i < array.length; i++) {
            const email = array[i]
            if (Helper.verifyIs("email/empty", email)) throw new Error("email is empty")
          }
          array.push(true)
        } catch (error) {
          array.push(false)
        }


      }

      if (accept && accept.includes("string/array")) {

        if (!input.value.startsWith("[")) array.push(false)
        if (!input.value.endsWith("]")) array.push(false)
        try {
          const array = JSON.parse(input.value)
          for (let i = 0; i < array.length; i++) {
            const string = array[i]
            if (Helper.verifyIs("text/empty", string)) throw new Error("string is empty")
          }
          array.push(true)
        } catch (error) {
          array.push(false)
        }


      }

      if (accept && accept.includes("text/script")) {

        if (this.verifyIs("text/script", input.value)) {
          array.push(true)
        } else {
          array.push(false)
        }
      }

      if (accept && accept.includes("text/field-funnel")) {
        const funnel = this.convert("text/first-child", input.value)
        if (funnel.tagName === "DIV") {
          if (funnel.classList.contains("field-funnel")) {
            array.push(true)
          } else {
            array.push(false)
          }
        }
      }

      const allTrue = array.every(it => it === true)
      if (allTrue === true) return true
      return false
    }

    if (event === "input/required") {


      // input required
      if (
        input.hasAttribute("required") ||
        input.getAttribute("required") === "true" ||
        input.required === true
      ) {

        if (input.getAttribute("type") === "checkbox") {

          if (input.getAttribute("checked") === "true") return true
          if (input.checked === true) return true

          return false
        }

        if (!this.verifyIs("text/empty", input.value)) return true
        return false

      }

      // select required
      if (input.requiredIndex !== undefined) {
        for (let i = 0; i < input.options.length; i++) {
          const option = input.options[i]
          if (option.selected === true) {
            if (option.value !== input.options[input.requiredIndex].value) {
              return true
            }
          }
        }
      }
      return false
    }

    if (event === "id/unique") {
      return document.getElementById(input) === null
    }

    if (event === "text/id") {
      if (this.verifyIs("text/tag", input)) {
        if (document.querySelectorAll(`#${input}`).length === 0) {
          return true
        } else {
          return false
        }
      }
    }

    if (event === "class/closest-node") {

      try {

        const result = input.node.closest(`.${input.class}`)

        if (result === null) {
          return false
        } else {
          return true
        }

      } catch (error) {
        return false
      }
    }

    if (event === "class/found") {
      return new Promise(async(resolve, reject) => {
        try {
          let found = false
          input.node.querySelectorAll("*").forEach((item, i) => {
            if (item.classList.contains(input.class)) {
              found = true
            }
          })
          resolve(found)

        } catch (error) {
          reject(error)
        }
      })
    }

    if (event === "class/loaded") {
     return new Promise(async (resolve, reject) => {
        try {
          const observer = new MutationObserver((mutations, observer) => {
            for (let i = 0; i < mutations.length; i++) {
              const mutation = mutations[i]

              if (mutation.type === "childList") {

                if (mutation.target.classList.contains(input)) {
                  resolve(mutation.target)
                }

              }
            }
          })
          observer.observe(document.documentElement, {
            childList: true,
            subtree: true,
          })

        } catch (error) {
          reject(error)
        }
     })
    }

    if (event === "id/loaded") {

      return new Promise(async(resolve, reject) => {
        try {

          const observer = new MutationObserver((mutations, observer) => {
            for (let i = 0; i < mutations.length; i++) {
              const mutation = mutations[i]

              if (mutation.type === "childList") {

                mutation.addedNodes.forEach(node => {

                  if (node.id === input) {
                    resolve(node)
                  }

                })

              }

            }
          })
          observer.observe(document.documentElement, {
            childList: true,
            subtree: true,
          })

        } catch (error) {
          reject(error)
        }
      })

    }

    if (event === "element/loaded") {

      return new Promise(async(resolve, reject) => {
        try {

          const observer = new MutationObserver((mutations, observer) => {
            for (let i = 0; i < mutations.length; i++) {
              const mutation = mutations[i]

              if (mutation.type === "childList") {

                mutation.addedNodes.forEach(node => {

                  if (node.id === input) {
                    resolve(node)
                  }

                })

              }

            }
          })
          observer.observe(document.documentElement, {
            childList: true,
            subtree: true,
          })

        } catch (error) {
          reject(error)
        }
      })

    }

    if (event === "element/html") {
      const htmlString = input.outerHTML
      const parser = new DOMParser()
      const doc = parser.parseFromString(htmlString, 'text/html')

      const parsedElement = doc.body.firstChild
      if (!parsedElement) {
        return false
      }

      for (let i = 0; i < parsedElement.children.length; i++) {
        const child = parsedElement.children[i]
        if (!this.verifyIs("element/html", child)) {
          return false
        }
      }

      return true
    }

    if (event === "email/empty") {
      return this.verifyIs("text/empty", input) || !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(input)
    }

    if (event === "path/profil") {

      const split = window.location.pathname.split("/")
      const expert = split[1]
      const platform = split[2]
      const path = split[3]
      const checkExpert = !this.verifyIs("text/empty", expert)
      const checkPlatform = !this.verifyIs("text/empty", platform)
      const checkPath = !this.verifyIs("text/empty", path) && path === "profil"
      return heckExpert && checkPlatform && checkPath
    }

    if (event === "path/valid") {

      const split = window.location.pathname.split("/")
      const expert = split[1]
      const platform = split[2]
      const path = split[3]
      const checkLength = split.length === 5
      const checkLast = split[4] === ""
      const checkExpert = !this.verifyIs("text/empty", expert)
      const checkPlatform = !this.verifyIs("text/empty", platform)
      const checkPath = !this.verifyIs("text/empty", path)
      return checkLength && checkLast && checkExpert && checkPlatform && checkPath
    }

    if (event === "text/hex") {
      if (typeof input !== "string") return false
      if (/^[0-9A-Fa-f]+$/.test(input) === true) return true
      return false
    }

  }

}

Helper.registerHtmlButton = await Helper.create("toolbox/register-html")
Helper.removeOverlayButton = await Helper.create("button/remove-overlay")
Helper.createNode = Helper.fn("createNode")

let lastPage = document.referrer
window.goBack = () => {
  if (window.history.length === 1) {
    window.close()
    return
  }
  if (Helper.verifyIs("text/empty", document.referrer)) {
    window.history.back()
  }
  if (lastPage === window.location.href) {
    window.close()
    return
  }
  window.history.back()
  setTimeout(() => {
    window.close()
  }, 34)
}

Helper.render("link/css", "/public/classes.css", document.head)
Helper.render("link/js", "/public/functions.js", document.head)
